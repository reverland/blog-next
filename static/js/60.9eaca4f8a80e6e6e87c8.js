webpackJsonp([60,170],{349:function(n,e){n.exports={rawContent:"\n\n## 实验准备\n\n这是我的工具：\n\n- 一台linux机器，内核支持ip转发，arp代理。带无线网卡和有线网卡。比如一台笔记本电脑。\n- linux机器装好scapy，tcpdump\n- 网线，不一定是双绞线，现代网卡都应该支持双向通信模式的转换。\n- 一台windows台式机，带有线网卡和接口。\n\n## 一点scapy的小基础\n\nscapy是一种基于python的包操作工具，在python上实现了一种DSL(领域特定语言)。定义一个包很简单。比如一个`Ether`：\n\n    Ether(dst=\"ff:ff:ff:ff:ff:ff\")\n\n封包里的字段可以`ls`来查看：\n\n    ls(Ether)\n\n当我们想让一个Ethernet包封装一个IP包时，仅仅使用一个`/`:\n\n    ip = Ether()/IP()\n\n当我们想发包时，如果想在第三层上网络层以上发包：\n\n    send(ip)\n\n但你要发一个ARP包(在第二层上发包)的话，要用`srp`或`srp1`。\n\n## arp如何工作\n\n计算机仅仅知道ip地址是无法通信的，ip数据报在封装到数据链路层中时需要加上比如以太网报头，报头中应该含有数据链路层能理解的地址即MAC地址。ARP就是着么一种将IP转换成MAC地址的协议。\n\n如下例子，当我们Ping一台机器时，如果该ip在arp缓存中有，就可以直接找到mac地址，如果没有，就会广播一个请求询问对应ip的mac地址。\n\n    ~/Work/project/arp-pos ⮀ sudo arp -d 192.168.1.113\n    ~/Work/project/arp-pos ⮀ ping -c 1 192.168.1.113\n    PING 192.168.1.113 (192.168.1.113) 56(84) bytes of data.\n    64 bytes from 192.168.1.113: icmp_seq=1 ttl=64 time=142 ms\n\n    --- 192.168.1.113 ping statistics ---\n    1 packets transmitted, 1 received, 0% packet loss, time 0ms\n    rtt min/avg/max/mdev = 142.484/142.484/142.484/0.000 ms\n\n     ~ ⮀ sudo tcpdump -vv -eqtnni wlan0 arp\n    tcpdump: listening on wlan0, link-type EN10MB (Ethernet), capture size 65535 bytes\n    11:11:11:11:11:11 > ff:ff:ff:ff:ff:ff, ARP, length 42: Ethernet (len 6), IPv4 (len 4), Request who-has 192.168.1.113 tell 192.168.1.106, length 28\n    22:22:22:22:22:22 > 11:11:11:11:11:11, ARP, length 42: Ethernet (len 6), IPv4 (len 4), Reply 192.168.1.113 is-at 22:22:22:22:22:22, length 28\n\n## 抓包观察\n\n让我们看看机器获取IP的过程。这里我们用tcpdump，你可以在任何linux发行版的源里找到它。当然，也可以用wireshark。\n\n     ~ ⮀ sudo tcpdump -e -i wlan0 port bootps or port bootpc or arp\n    tcpdump: WARNING: wlan0: no IPv4 address assigned\n    tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\n    listening on wlan0, link-type EN10MB (Ethernet), capture size 65535 bytes\n    21:54:19.202074 11:11:11:11:11:11 (oui Unknown) > Broadcast, ethertype IPv4 (0x0800), length 371: 0.0.0.0.bootpc > 255.255.255.255.bootps: BOOTP/DHCP, Request from 11:11:11:11:11:11 (oui Unknown), length 329\n    21:54:19.277875 ec:88:8f:b4:d6:68 (oui Unknown) > 11:11:11:11:11:11 (oui Unknown), ethertype IPv4 (0x0800), length 590: 192.168.1.1.bootps > 192.168.1.101.bootpc: BOOTP/DHCP, Reply, length 548\n    21:54:19.352068 11:11:11:11:11:11 (oui Unknown) > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.1.102 tell 0.0.0.0, length 28\n    21:54:20.720541 11:11:11:11:11:11 (oui Unknown) > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.1.102 tell 0.0.0.0, length 28\n    21:54:22.155087 11:11:11:11:11:11 (oui Unknown) > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.1.102 tell 0.0.0.0, length 28\n    21:54:24.232076 11:11:11:11:11:11 (oui Unknown) > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.1.102 tell 192.168.1.102, length 28\n    21:54:26.234201 11:11:11:11:11:11 (oui Unknown) > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.1.102 tell 192.168.1.102, length 28\n    21:54:27.502047 11:11:11:11:11:11 (oui Unknown) > Broadcast, ethertype ARP (0x0806), length 42: Request who-has 192.168.1.1 tell 192.168.1.101, length 28\n    21:54:27.514492 ec:88:8f:b4:d6:68 (oui Unknown) > 11:11:11:11:11:11 (oui Unknown), ethertype ARP (0x0806), length 42: Reply 192.168.1.1 is-at ec:88:8f:b4:d6:68 (oui Unknown), length 28\n\n可以看到，先是dhcp的过程，下次我们再讲。紧接着我们的机器发出一个ARP探针(Probe)，哦，发了好几次来确认没有机器使用`192.168.1.1`，于是接着发了两个announcement宣告拥有了这个ip。接着询问`192.168.1.1`的MAC地址并收到来自`192.168.1.1`的回复。\n\n## 一个广播的ARP请求\n\n为了实验正确，我们先删除arp缓存内容：\n\n    ~/Work/project/arp ⮀ sudo arp -d 10.210.96.193\n    ~/Work/project/arp ⮀ sudo arp -n\n    Address                  HWtype  HWaddress           Flags Mask            Iface\n      10.210.96.193                    (incomplete)                              eth0\n\n\n首先，我们作为`10.210.96.200`，想知道`10.210.96.193`的MAC地址，我们广播一个ARP请求：\n\n    我是10.210.96.200,我的MAC地址是11:11:11:11:11:11,我想知道10.210.96.193的IP地址是什么。\n\n让我们先探索下ARP包的结构。\n\n    >>> ls(ARP)\n    hwtype     : XShortField          = (1)\n    ptype      : XShortEnumField      = (2048)\n    hwlen      : ByteField            = (6)\n    plen       : ByteField            = (4)\n    op         : ShortEnumField       = (1)\n    hwsrc      : ARPSourceMACField    = (None)\n    psrc       : SourceIPField        = (None)\n    hwdst      : MACField             = ('00:00:00:00:00:00')\n    pdst       : IPField              = ('0.0.0.0')\n\n参见[ARP协议封包结构](http://en.wikipedia.org/wiki/Address_Resolution_Protocol#Packet_structure)\n\n首先我们构造一个ARP请求。该请求工作在Ethernet上(`0x0001`)，协议类型是IPv4(`0x0800`), 是一个请求(`0x0001`或`who-has`)，发送者的MAC地址是`11:11:11:11:11:11`, 发送者的协议地址是`10.210.96.200`，想要知道MAC地址的协议地址是`10.210.96.193`。根据以太网包字段，该消息通过广播发送。\n\n    arp_request = Ether(dst=\"ff:ff:ff:ff:ff:ff\")/ARP(hwtype=0x0001,ptype=0x0800,op=0x0001,hwsrc='11:11:11:11:11:11', psrc='10.210.96.200', pdst='10.210.96.193')\n\nscapy会自动为我们设置`Ether`的某些字段，所以我们不用都指定。\n\n    >>> arp_request.show()\n    ###[ Ethernet ]###\n      dst= ff:ff:ff:ff:ff:ff\n      src= 11:11:11:11:11:11\n      type= 0x806\n    ###[ ARP ]###\n         hwtype= 0x1\n         ptype= 0x800\n         hwlen= 6\n         plen= 4\n         op= who-has\n         hwsrc= 11:11:11:11:11:11\n         psrc= 10.210.96.200\n         hwdst= 00:00:00:00:00:00\n         pdst= 10.210.96.193\n\n紧接着发送它：\n\n    >>> recv = srp(arp_request)\n    Begin emission:\n    Finished to send 1 packets.\n    *\n    Received 1 packets, got 1 answers, remaining 0 packets\n    >>> recv\n    (<Results: TCP:0 UDP:0 ICMP:0 Other:1>, <Unanswered: TCP:0 UDP:0 ICMP:0 Other:0>)\n    >>> recv[0].show()\n    0000 Ether / ARP who has 10.210.96.193 says 10.210.96.200 ==> Ether / ARP is at 3c:e5:a6:d2:39:ad says 10.210.96.193 / Padding\n\n可见我们得到了它的MAC地址。检查ARP缓存：\n\n    ~/Work/project/arp ⮀ sudo arp -n\n    Address                  HWtype  HWaddress           Flags Mask            Iface\n    10.210.96.193            ether   3c:e5:a6:d2:39:ad   C                     eth0\n\nBingo!\n\n## 一个ARP应答\n\n首先要设置静态IP。将一台win7机器设置为`172.16.0.17`.\n\n接着我们要发一个不请自答的ARP reply，这一技术常用来进行ARP Poison。\n\n    >>> arp_reply = Ether(src='11:11:11:11:11:11', dst='C8:1F:66:05:E2:6A')/ARP(hwtype=0x0001,ptype=0x0800,op=0x0002,hwsrc='11:11:11:11:11:11', hwdst='C8:1F:66:05:E2:6A', psrc='172.16.0.28', pdst='172.16.0.17')\n    recv = srp(arp_reply, timeout=1, iface='eth0')\n\n查看我们的监听：\n\n     ~ ⮀ sudo  tcpdump -nni eth0 arp \n    tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\n    listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes\n    17:22:10.465636 ARP, Reply 172.16.0.28 is-at 11:11:11:11:11:11, length 28\n\n然而检查另一台机器的arp缓存可能并没有`172.16.0.28`的项。这是因为操作系统可能不欢迎不请自来的arp应答。\n\n我们试着使用不请自来的arp请求看看：\n\n    >>> arp_request = Ether(dst=\"ff:ff:ff:ff:ff:ff\")/ARP(hwtype=0x0001,ptype=0x0800,op=0x0001,hwsrc='11:11:11:11:11:11', psrc='172.16.0.22', pdst='172.16.0.17')\n    >>> recv = srp(arp_request)\n\n则可以在另一台机器上的缓存表中发现`172.16.0.22`的项。说明操作系统默默接受了不请自来的请求。\n\n为了查看ARP响应的效果，我们同时打开两边机器，创造一个请求。先清空windows机器的缓存表。\n\n我们让windows机器ping`172.16.0.30`。同时开始抓包和准备应答(在win7上ping的同时执行下列命令)：\n\n    >>> arp_reply = Ether(src='11:11:11:11:11:11', dst='C8:1F:66:05:E2:6A')/ARP(hwtype=0x0001,ptype=0x0800,op=0x0002,hwsrc='11:11:11:11:11:11', hwdst='C8:1F:66:05:E2:6A', psrc='172.16.0.30', pdst='172.16.0.17')\n    >>> recv = srp(arp_reply, timeout=1, iface='eth0')Begin emission:\n    Finished to send 1 packets.\n    ...\n    Received 3 packets, got 0 answers, remaining 1 packets\n\n可以观察到包的前两个正是我们想要的。\n\n    ~ ⮀ sudo  tcpdump -nni eth0 arp \n    tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\n    listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes\n    17:28:55.041968 ARP, Request who-has 172.16.0.30 tell 172.16.0.17, length 46\n    17:28:55.165561 ARP, Reply 172.16.0.30 is-at 11:11:11:11:11:11, length 28\n\n同时发现win7的arp缓存中已经有了`172.16.0.30`。\n\n## ARP Announcement\n\n这是一种特殊的ARP请求，目标协议地址填入发送者的协议地址，将目标硬件地址设为0.\n\n或者，是一种特殊的ARP响应，目标协议地址和目标硬件地址都是发送者的协议和目标硬件地址。\n\nARP announcement意在更新其它收到这个包的机器的ARP缓存。这种免费的ARP(不请自来)常用来在机器启动或换网卡时通知其它机器。也用来做负载平衡。\n\n    >>> arp_announcement = Ether(src='11:11:11:11:11:11', dst=\"ff:ff:ff:ff:ff:ff\")/ARP(hwtype=0x0001,ptype=0x0800,op=0x0001,hwsrc='11:11:11:11:11:11', hwdst='00:00:00:00:00:00', psrc='172.16.0.40', pdst='172.16.0.40')\n    >>> recv = srp1(arp_announcement, timeout=2)\n    Begin emission:\n    Finished to send 1 packets.\n    \n    Received 0 packets, got 0 answers, remaining 1 packets\n    \n     ~ ⮀ sudo  tcpdump -enni eth0 arp \n    tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\n    listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes\n    22:15:39.645293 11:11:11:11:11:11 > ff:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Request who-has 172.16.0.40 tell 172.16.0.40, length 28\n\n遗憾的是，win7的ARP缓存没有接受`172.16.0.40`.\n\n一个响应Announcement：\n\n    >>> arp_announcement = Ether(src='11:11:11:11:11:11', dst=\"ff:ff:ff:ff:ff:ff\")/ARP(hwtype=0x0001,ptype=0x0800,op=0x0002,hwsrc='11:11:11:11:11:11', hwdst='11:11:11:11:11:11', psrc='172.16.0.40', pdst='172.16.0.40')\n    >>> recv = srp1(arp_announcement, timeout=2)\n\n     ~ ⮀ sudo  tcpdump -enni eth0 arp \n    tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\n    listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes\n    22:18:21.655256 11:11:11:11:11:11 > ff:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Reply 172.16.0.40 is-at 11:11:11:11:11:11, length 28\n\n## ARP probe\n\nARP探针是一个全0 IP地址的广播请求，用来检测IPv4地址冲突。在开始使用一个IP地址之前，实现这个规范(RFC5227)的主机必须通过ARP探针测试地址是否被使用。\n\n具体过程参见RFC5227.\n\n> A host probes to see if an address is already in use by broadcasting\n> an ARP Request for the desired address.  The client MUST fill in the\n> 'sender hardware address' field of the ARP Request with the hardware\n> address of the interface through which it is sending the packet.  The\n> 'sender IP address' field MUST be set to all zeroes; this is to avoid\n> polluting ARP caches in other hosts on the same link in the case\n> where the address turns out to be already in use by another host.\n> The 'target hardware address' field is ignored and SHOULD be set to\n> all zeroes.  The 'target IP address' field MUST be set to the address\n> being probed.  An ARP Request constructed this way, with an all-zero\n> 'sender IP address', is referred to as an 'ARP Probe'.\n\n类似这样：\n\n    >>> arp_probe = (Ether(dst='ff:ff:ff:ff:ff:ff')/ARP(psrc='0.0.0.0', pdst='172.16.0.17'))\n    >>> arp_probe.show()\n    ###[ Ethernet ]###\n      dst= ff:ff:ff:ff:ff:ff\n      src= 11:11:11:11:11:11\n      type= 0x806\n    ###[ ARP ]###\n         hwtype= 0x1\n         ptype= 0x800\n         hwlen= 6\n         plen= 4\n         op= who-has\n         hwsrc= 11:11:11:11:11:11\n         psrc= 0.0.0.0\n         hwdst= 00:00:00:00:00:00\n         pdst= 172.16.0.17\n    >>> recv = srp(arp_probe, iface='eth0')\n    Begin emission:\n    Finished to send 1 packets.\n    *\n    Received 1 packets, got 1 answers, remaining 0 packets\n\n开始监听然后发送：\n\n     ~ ⮀ sudo  tcpdump -nni eth0 arp \n    tcpdump: verbose output suppressed, use -v or -vv for full protocol decode\n    listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes\n    22:08:56.885470 ARP, Request who-has 172.16.0.17 tell 0.0.0.0, length 28\n    22:08:56.885831 ARP, Reply 172.16.0.17 is-at c8:1f:66:05:e2:6a, length 46\n\n说明有`172.16.0.17`这个地址。但可以检查一下，`0.0.0.0`并没有污染win7机器的arp缓存。\n\n## ARP mediation\n\n在VPN中不同网络架构时使用ARP。略\n\n## ARP Stuffing\n\n某些嵌入式系统，没有配置界面，用户无法使用地址分配协议，设备没有合适的IP地址，这时候主机人工填充一个IP地址到它的地址表，然后向设备发送特殊的包。设备于是采用这个IP地址和主机通信。\n\n## ARP Suppression\n\n禁用主机ARP，要求配置静态ARP缓存才能通信：\n\n    ip link set dev eth0 arp off\n    # ifconfig wlan0 -arp\n\n## ARP Proxy\n\n同一个IP网段被某台设备分成两个部分。arp代理可以让两端的机器好像在同一以太网内工作一样。\n\n举如下例子。\n\n当我们有一台linux机器。其中wlan0连接无线路由，另外有一台win7机器，没有无线网卡，和linux机器的eth0直接用网线相连。\n\n    Internet-----------无线路由-----------wlan0 [Linux] eth0---------------windows 7\n\n为了让windows7机器能够联网，我们可以设置windows7机器和linux机器在同一网段。比如设置：\n\n先设置ip地址：\n\n- 路由器网关地址`192.168.1.1`\n- linux在wlan0被路由器分配地址，`192.168.1.103`，子网掩码`255.255.255.0`\n- windows7机器设置静态ip`192.168.1.114`，子网掩码`255.255.255.0`\n\n下面我们开始设置ARP代理，在linux机器上设置内核允许代理和转发：\n\n    gentoo ~ # echo 1 > /proc/sys/net/ipv4/conf/eth0/proxy_arp\n    gentoo ~ # echo 1 > /proc/sys/net/ipv4/conf/wlan0/proxy_arp\n    gentoo ~ # echo 1 > /proc/sys/net/ipv4/ip_forward\n\n在wlan0上对应其MAC设置想要代理的对象的静态地址(`192.168.1.114`)，让linux对wlan0上以太网响应对`192.168.1.114`的响应，并把自己的无线网卡MAC作为响应内容。\n\n    sudo arp -i wlan0 -s 192.168.1.114 11:11:11:11:11:11 pub\n\n可以选择是否设置下一步，即使在eth0上没有ip地址也可以。\n\n设置eth0接口上的ip地址(默认netmask是`255.255.255.0`)：\n\n    sudo ifconfig eth0 inet 192.168.1.113\n\n添加路由：\n\n    sudo route add 192.168.1.114 eth0\n\nlinux和windows机器互ping以确保连接：\n\n    ⮀ ~ ⮀ ping -c 2 192.168.1.114\n    PING 192.168.1.114 (192.168.1.114) 56(84) bytes of data.\n    64 bytes from 192.168.1.114: icmp_seq=1 ttl=128 time=0.446 ms\n    64 bytes from 192.168.1.114: icmp_seq=2 ttl=128 time=0.469 ms\n    \n    --- 192.168.1.114 ping statistics ---\n    2 packets transmitted, 2 received, 0% packet loss, time 999ms\n    rtt min/avg/max/mdev = 0.446/0.457/0.469/0.024 ms\n\n对`eth0`上将自己的有线网卡MAC设置为对`192.168.1.1`的响应。\n\n    sudo arp -i eth0 -s 192.168.1.1 00:24:54:9a:05:8b pub\n\n接着在windows7上尝试`ping`一下`192.168.1.1`：\n\n如果在windows7机器上设置了正确的dns，就可以直接上网了。\n\n## Reference\n\n- [Address Resolution Protocol](en.wikipedia.org/wiki/Address_Resolution_Protocol)\n- [Address Resolution Protocol (ARP)](http://linux-ip.net/html/ether-arp.html)\n- [特殊狀況：路由器兩邊界面是同一個 IP 網段： ARP Proxy](http://linux.vbird.org/linux_server/0230router.php#arp_proxy)\n\n\n",metaData:{layout:"post",title:"Playing and Learning ARP in Action",excerpt:"动手学习计算机网络系列(一)",category:"network",tags:["network"],disqus:!0}}}});