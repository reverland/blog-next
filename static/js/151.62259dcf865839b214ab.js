webpackJsonp([151,192],{302:function(n,e){n.exports={rawContent:'\n\n# 最终版的Dice of Doom\n\n这个游戏终于结束了，基本上这本书的主要内容也算看完了。实际上，我根本就写不出这些东西，源码也读的云里雾里。但这是一本很有趣的书，我想看完htdp之后用htdp推荐风格重新处理下这本书的代码，顺便也复习一下。\n\n## 让Dice of Doom 更加的有趣\n\n我们上回完成的版本虽然很棒，但总缺乏些什么。因为之前程序的设计，我们可以很轻易的扩展它，让它变得更有趣\n\n先加载我们之前的游戏[^1]\n\n```cl\n(load "dice-v3");\n```\n\n### 增加玩家数\n\n因为我们之前的架构，增加玩家数很简单。为了增加玩家数后计算机能反应敏捷，让它变“傻”一点。\n\n```cl\n(defparameter *num-players* 4)\n(defparameter *die-colors* \'((255 63 63) (63 63 255) (63 255 63) (255 63 255)))\n(defparameter *max-dice* 5)\n(defparameter *ai-level* 2)\n```\n\n### 建立概率节点\n\n我们本质上是向游戏树中加入几率节点，先升级attacking-moves函数，增加个board-attack-fail分支。\n\n```cl\n(defun attacking-moves (board cur-player spare-dice)\n  (labels ((player (pos)\n             (car (aref board pos)))\n           (dice (pos)\n             (cadr (aref board pos))))\n    (lazy-mapcan (lambda (src)\n                   (if (eq (player src) cur-player)\n                     (lazy-mapcan\n                       (lambda (dst)\n                         (if (and (not (eq (player dst) cur-player))\n                                  (> (dice src) 1))\n                           (make-lazy (list (list (list src dst)\n                                                  (game-tree (board-attack board cur-player src dst (dice src))\n                                                             cur-player\n                                                             (+ spare-dice (dice dst))\n                                                             nil)\n                                                  (game-tree (board-attack-fail board cur-player src dst (dice src))\n                                                             cur-player\n                                                             (+ spare-dice (dice dst))\n                                                             nil))))\n                           (lazy-nil)))\n                       (make-lazy (neighbors src)))\n                     (lazy-nil)))\n                 (make-lazy (loop for n below *board-hexnum*\n                                  collect n)))))\n```\n\nboard-attack-fail函数遍历所有位置。如果这个位置是攻击方就只能留下一个骰子\n\n```cl\n(defun board-attack-fail (board player src dst dice)\n  (board-array (loop for pos from 0\n                     for hex across board\n                     collect (if (eq pos src)\n                               (list player 1)\n                               hex))))\n```\n\n### 让骰子滚动起来\n\n一下程序让一堆骰子滚动起来，并判断谁赢了\n\n```cl\n;rolling the dice\n(defun roll-dice (dice-num)\n  (let ((total (loop repeat dice-num\n                     sum (1+ (random 6)))))\n    (fresh-line)\n    (format t "On ~a dice rolled ~a. " dice-num total)\n    total))\n(defun roll-against (src-dice dst-dice)\n  (> (roll-dice src-dice) (roll-dice dst-dice)))\n```\n\n我们还需要在游戏引擎中调用让骰子滚动的代码,选出正确的子树\n\n```cl\n(defun pick-chance-branch (board move)\n  (labels ((dice (pos)\n             (cadr (aref board pos))))\n    (let ((path (car move)))\n      (if (or (null path) (roll-against (dice (car path))\n                                        (dice (cadr path))))\n        (cadr move)\n        (caddr move)))))\n```\n\n更新handle-computer函数让它调用选择几率分支的函数\n\n```cl\n(defun handle-human (tree)\n  (fresh-line)\n  (princ "choose your move:")\n  (let ((moves (caddr tree)))\n    (labels ((print-moves (moves n)\n               (unless (lazy-null moves)\n                 (let* ((move (lazy-car moves))\n                        (action (car move)))\n                   (fresh-line)\n                   (format t "~a. " n)\n                   (if action\n                     (format t "~a -> ~a" (car action) (cadr action))\n                     (princ "end turn")))\n                 (print-moves (lazy-cdr moves) (1+ n)))))\n      (print-moves moves 1))\n    (fresh-line)\n    (pick-chance-branch (cadr tree) (lazy-nth (1- (read)) moves))))\n```\n\n同样我们可以处理handle-computer函数\n\n```cl\n(defun handle-computer (tree)\n  (let ((ratings (get-ratings (limit-tree-depth tree *ai-level*) (car tree))))\n    (pick-chance-branch\n      (cadr tree)\n      (lazy-nth (position (apply #\'max ratings) ratings) (caddr tree)))))\n```\n\n### 升级AI\n\n但现在还有个问题，AI还没有考虑骰子的滚动，依然认为骰子多的一定获胜。因此需要更新AI。\n\n根据概率论原理，我们可以得到这样一个矩阵来表征攻击成功的概率\n\n|防守方\\攻击方|2|3|4|5|\n|:-:|:----:|:----:|:---:|:--:|\n|1|0.84|0.97|1.0|1.0|\n|2|0.44|0.78|0.94|0.99|\n|3|0.15|0.45|0.74|0.91|\n|4|0.04|0.19|0.46|0.72|\n|5|0.01|0.06|0.22|0.46|\n\n现在把这个概率交给计算机，更新get-ratings函数,给评分加权\n\n```cl\n(defun get-ratings (tree player)\n  (let ((board (cadr tree)))\n    (labels ((dice (pos)\n               (cadr (aref board pos))))\n      (take-all (lazy-mapcar\n                  (lambda (move)\n                    (let ((path (car move)))\n                      (if path\n                        (let* ((src (car path))\n                               (dst (cadr path))\n                               (odds (aref (aref *dice-odds*\n                                                 (1- (dice dst)))\n                                           (- (dice src) 2))))\n                          (+ (* odds (rate-position (cadr move) player))\n                             (* (- 1 odds) (rate-position (caddr move)\n                                                          player))))\n                        (rate-position (cadr move) player))))\n                  (caddr tree))))))\n```\n\n为了让修剪游戏树的函数能工作，还需要做些修改让它能处理新的游戏树。同时为了简化不再使用alpha-beta算法。\n\n```cl\n(defun limit-tree-depth (tree depth)\n  (list (car tree)\n        (cadr tree)\n        (if (zerop depth)\n          (lazy-nil)\n          (lazy-mapcar (lambda (move)\n                         (cons (car move)\n                               (mapcar (lambda (x)\n                                         (limit-tree-depth x (1- depth)))\n                                       (cdr move))))\n                       (caddr tree)))))\n;We mapcar across the tail of each move, so trimming is performed on\n;both branches of any chance nodes.\n```\n\n### 改进增援方案\n\n之前是依据消灭敌人多少来决定增援骰子数。现在我们换一种方法：依据占据的最大领地来决定增援多少。这使游戏的地缘性更加复杂。\n\n回想我们之前在[wumpus游戏][1]里写过的相似函数\n\n```cl\n(defun get-connected (board player pos)\n  (labels ((check-pos (pos visited)\n             (if (and (eq (car (aref board pos)) player)\n                      (not (member pos visited)))\n               (check-neighbors (neighbors pos) (cons pos visited))\n               visited))\n           (check-neighbors (lst visited)\n             (if lst\n               (check-neighbors (cdr lst) (check-pos (car lst) visited))\n               visited)))\n    (check-pos pos \'())))\n```\n\n获得最大的集群,最后添加援军，注意，spare-dice仍然作为参数传递但已经不再被add-new-dice使用了。\n\n```cl\n(defun largest-cluster-size (board player)\n  (labels ((f (pos visited best)\n             (if (< pos *board-hexnum*)\n               (if (and (eq (car (aref board pos)) player)\n                        (not (member pos visited)))\n                 (let* ((cluster (get-connected board player pos))\n                        (size (length cluster)))\n                   (if (> size best)\n                     (f (1+ pos) (append cluster visited) size)\n                     (f (1+ pos) (append cluster visited) best)))\n                 (f (1+ pos) visited best))\n               best)))\n    (f 0 \'() 0)))\n(defun add-new-dice (board player spare-dice)\n  (labels ((f (lst n)\n             (cond ((zerop n) lst)\n                   ((null lst) nil)\n                   (t (let ((cur-player (caar lst))\n                            (cur-dice (cadar lst)))\n                        (if (and (eq cur-player player) (< cur-dice *max-dice*))\n                          (cons (list cur-player (1+ cur-dice))\n                                (f (cdr lst) (1- n)))\n                          (cons (car lst) (f (cdr lst) n))))))))\n    (board-array (f (coerce board \'list)\n                   (largest-cluster-size board player)))))\n```\n\n享受你的劳动成果吧\n\n```cl\n(serve #\'dod-request-handleer)\n```\n\n## 疑问\n\n我发现我可以选中任何自己的领地，只要上面的骰子数大于2。我可以攻击任何强大的敌人，而且一定能成功。不知道哪里的更改或错误！！\n\n***\n\n## Footnotes\n\n[^1]: 对从官网下载的源码和书中的源码可能需要修改，具体参见前几篇读书笔记。\n\n[1]: http://reverland.org/Tech/2012/05/01/grand-theft-wumpus/\n',metaData:{layout:"post",title:"Dice of Doom v4",excerpt:"最终版的Dice of Doom",category:"lisp",tags:["land-of-lisp"],disqus:!0}}}});