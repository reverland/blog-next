webpackJsonp([157,170],{252:function(n,e){n.exports={rawContent:'\n\n## Lisp中的特殊数据结构\n\n引用原文中的话来形容Lisp,\n\n```bash\nThink of the Babel fish in the Hitchhiker’s Guide to the Galaxy trilogy—something \nso impossibly useful that it really has no business existing in the first place.\n```\n\n现在知道land of lisp的作者为什么把common lisp比作狼狗，为什么说cl强大了。支持list也就算了，支持个array、hash table、OOp、范型(generic)什么乱七八糟一堆其它语言中各种强大的东西，这么逆天的东西根本就不该存在！不过作为代价，丧失了一种纯粹的美。\n\n```cl\n\nlisp is symmetry,while common lisp is powerful.\n```\n\n### Arrays\n\n一些有用的命令\n\n- make-array\n- aref\n- setf\n\narray有比列表更高的效率\n\n### Hash Table\n\n这玩意强到逆天：\n\n- make-hash-table\n- gethash\n\n#### 返回多值\n\n- round\n- values\n- multiple-value-bind\n\nhash表性能总体还是很高的..比如说我们上回写的wumpus游戏，我们可以分别对hash表和alists运行效率做如下对比。先看alists：\n\n```cl\n(load "/home/lyy/Documents/lisp/wumpus.lisp")\n(setf *edge-num* 1000)\n(setf *node-num* 1000)\n(time (dotimes (i 100) (get-connected 1 (make-edge-list))))\n```\n\n好吧，我花的时间：\n\n```cl\n(time (dotimes (i 100) (get-connected 1 (make-edge-list))))\nReal time: 64.1503 sec.\nRun time: 64.025826 sec.\nSpace: 75275184 Bytes\nGC: 65, GC time: 0.43664 sec.\nNIL\n```\n\n下面我们更改之前的wumpus游戏。\n\n```cl\n;;生成hash表的边版本\n(defun hash-edges (edge-list)\n  (let ((tab (make-hash-table)))\n    (mapc (lambda (x);mapc返回副作用\n            (let ((node (car x)))\n              (push (cdr x) (gethash node tab))));推入新值\n          edge-list)\n    tab))\n;;生成hash表。如果与node相连，则hash表中值为t\n(defun get-connected-hash (node edge-tab)\n  (let ((visited (make-hash-table)))\n    (labels ((traverse (node)\n               (unless (gethash node visited);非则执行\n                 (setf (gethash node visited) t)\n                 (mapc (lambda (edge)\n                         (traverse edge))\n                       (gethash node edge-tab)))))\n      (traverse node))\n    visited))\n;;可以看看什么样的\n;;看看运行时间\n(time (dotimes (i 100)\n        (get-connected-hash 1 (hash-edges (make-edge-list)))))\n```\n\n很显然，效率高多了：\n\n```cl\n(time (dotimes (i 100)\n        (get-connected-hash 1 (hash-edges (make-edge-list)))))\nReal time: 1.530112 sec.\nRun time: 1.526567 sec.\nSpace: 64337496 Bytes\nGC: 56, GC time: 0.366641 sec.\nNIL\n```\n\n### Structures\n\n构建structure可以直接用defstruct：\n\n```cl\n(defstruct person\n  name\n  age\n  waist-size\n  favorite-color)\n;;然后进行跟改\n(defparameter *bob* (make-person :name "Bob";make-person函数自动生成\n                                 :age 35\n                                 :waist-size 32\n                                 :favorite-color "blue"))\n*bob* ;查看\n;#S(person :name "rob" :age 35 :waist-size 32 :favorite-color "blue")\n(person-age *bob*);自动生成person-age函数\n(setf (person-age *bob*) 36);generical programming\n```\n也可以直接这样：\n\n```cl\n(defparameter *that-guy* #S(person :name "rob" :age 35 :waist-size 32\n                                   :favorite-color "blue"))\n(print *that-guy*) \n```\n\n### Generical Programming\n\n有些范函可以接受多种类型参数,典型的sequence函数有：\n\n- length\n- sequence\n- find-if\n- count\n- position\n- some\n- every\n- reduce\n- subseq\n- sort\n\n通过类型检验创建generic function是可行的但不太好。有种叫作type dispatching的东西可以让用户自己通过defmethod来定义generic function。\n\n***\n\n## The Orc Battle Game\n\n好了，之前全是扯淡。开始进入正题，写我们的新游戏：\n\n```cl\n;;;player的三属性\n(defparameter *player-health* nil)\n(defparameter *player-agility* nil)\n(defparameter *player-strength* nil)\n;;;monsters\n(defparameter *monsters* nil)\n(defparameter *monster-builders* nil);各种怪物\n(defparameter *monster-num* 12)\n(princ *monster-builders*) \n;;;main function\n(defun orc-battle ()\n  (init-monsters)\n  (init-player)\n  (game-loop)\n  (when (player-dead)\n    (princ "You have been killed. Game Over."))\n  (when (monsters-dead)\n    (princ "Congratulations! You have vanquished all of your foes.")))\n;;;define game loop\n(defun game-loop ()\n  (unless (or (player-dead) (monsters-dead))\n    (show-player)\n  ;;依据敏捷计算攻击次数\n    (dotimes (k (1+ (truncate (/ (max 0 *player-agility*) 15))))\n      (unless (monsters-dead)\n        (show-monsters)\n        (player-attack)))\n    (fresh-line)\n    (map \'list\n         (lambda(m)\n           (or (monster-dead m) (monster-attack m)))\n         *monsters*)\n    (game-loop)))\n;;;manage players function\n(defun init-player ()\n  (setf *player-health* 30)\n  (setf *player-agility* 30)\n  (setf *player-strength* 30))\n(defun player-dead ()\n  (<= *player-health* 0))\n(defun show-player ()\n  (fresh-line)\n  (princ "You are a valiant knight with a health of ")\n  (princ *player-health*)\n  (princ ", an agility of ")\n  (princ *player-agility*)\n  (princ ", and a strength of ")\n  (princ *player-strength*))\n(defun player-attack ()\n  (fresh-line)\n  (princ "Attack style: [s]tab [d]ouble swing [r]oundhouse:")\n  (case (read);case函数\n    (s (monster-hit (pick-monster);monster-hit表monster被攻击\n                    (+ 2 (randval (ash *player-strength* -1)))))\n    (d (let ((x (randval (truncate (/ *player-strength* 6)))))\n         (princ "Your double swing has a strength of ")\n         (princ x)\n         (fresh-line)\n         (monster-hit (pick-monster) x)\n         (unless (monsters-dead);除非第一次攻击就消灭所有怪物\n           (monster-hit (pick-monster) x))))\n    (otherwise (dotimes (x (1+ (randval (truncate (/ *player-strength* 3)))))\n;否则一阵乱打\n                 (unless (monsters-dead);若之中有一次已经消灭所有怪物\n                   (monster-hit (random-monster) 1))))))\n;;;产生不小于1的1到n的随机数\n(defun randval (n)\n  (1+ (random (max 1 n))));以防n<1\n;;;Player Attacks的辅助函数\n;;随机活着的怪物编号\n(defun random-monster ()\n  (let ((m (aref *monsters* (random (length *monsters*)))))\n    (if (monster-dead m)\n      (random-monster)\n      m)))\n\n;;选择特定monster\n(defun pick-monster ()\n  (fresh-line)\n  (princ "Monster #:")\n  (let ((x (read)))\n    (if (not (and (integerp x) (>= x 1) (<= x *monster-num*)))\n      (progn (princ "That is not a valid monster number.")\n             (pick-monster))\n      (let ((m (aref *monsters* (1- x))))\n        (if (monster-dead m)\n          (progn (princ "That monster is alread dead.")\n                 (pick-monster))\n          m)))))\n;;Monster Management Functions\n(defun init-monsters ()\n  (setf *monsters*\n        (map \'vector\n             (lambda (x);I make no sense of it\n               (funcall (nth (random (length *monster-builders*))\n                             *monster-builders*)))\n             (make-array *monster-num*))))\n(defun monster-dead (m)\n  (<= (monster-health m) 0))\n(defun monsters-dead ()\n  (every #\'monster-dead *monsters*))\n\n(defun show-monsters ()\n  (fresh-line)\n  (princ "Your foes:")\n  (let ((x 0))\n    (map \'list\n         (lambda (m)\n           (fresh-line)\n           (princ "     ")\n           (princ (incf x))\n           (princ ". ")\n           (if (monster-dead m)\n             (princ "**dead**")\n             (progn (princ "(Health=")\n                    (princ (monster-health m))\n                    (princ ") ")\n                    (monster-show m))));怪物描述\n                  *monsters*)))\n;;定义monster的structure\n(defstruct monster (health (randval 10)))\n;;monster被攻击\n(defmethod monster-hit (m x)\n  (decf (monster-health m) x)\n  (if (monster-dead m)\n    (progn (princ "You killed the ")\n           (princ (type-of m))\n           (princ "! "))\n    (progn (princ "You hit the ")\n           (princ (type-of m))\n           (princ ", knocking off ")\n           (princ x)\n           (princ " health points! "))))\n;;(type-of (make-monster))\n;;;;MONSTER\n;;;总体定义下\n(defmethod monster-show (m)\n  (princ "A fierce ")\n  (princ (type-of m)))\n;;占位\n(defmethod monster-attack (m))\n;;;orc\n;;;defstruct还可以这样定义\n(defstruct (orc (:include monster)) (club-level (randval 8)))\n(push #\'make-orc *monster-builders*)\n(defmethod monster-show ((m orc));something like "defmethod function ((a number) (b string))"\n  (princ "A wicked orc with a level ")\n  (princ (orc-club-level m))\n  (princ " club"))\n(defmethod monster-attack ((m orc))\n  (let ((x (randval (orc-club-level m))))\n    (princ "An orc swings his club at you and knocks off ")\n    (princ x)\n    (princ " of your health points. ")\n    (decf *player-health* x)))\n;;;hydra,多头鸟\n(defstruct (hydra (:include monster)))\n(push #\'make-hydra *monster-builders*)\n(defmethod monster-show ((m hydra))\n  (princ "A malicious hydra with ")\n  (princ (monster-health m))\n  (princ " heads."))\n(defmethod monster-hit ((m hydra) x);x代表头数\n  (decf (monster-health m) x)\n  (if (monster-dead m)\n    (princ "The corpse of the fully decapitated and decapacitated hydra\n           falls to the floor!")\n    (progn (princ "You lop off ")\n           (princ x)\n           (princ " of the hydra\'s heads! "))))\n(defmethod monster-attack ((m hydra))\n  (let ((x (randval (ash (monster-health m) -1))))\n    (princ "A hydra attacks you with ")\n    (princ x)\n    (princ " of its heads! It also grows back one more head! ")\n    (incf (monster-health m))\n    (decf *player-health* x)))\n;;;slime\n(defstruct (slime-mold (:include monster)) (sliminess (randval 5)))\n(push #\'make-slime-mold *monster-builders*)\n(defmethod monster-show ((m slime-mold))\n  (princ "A slime mold with a sliminess of ")\n  (princ (slime-mold-sliminess m)))\n(defmethod monster-attack ((m slime-mold))\n  (let ((x (randval (slime-mold-sliminess m))))\n    (princ "A slime mold wraps around your legs and decreases your agility\n           by ")\n    (princ x)\n    (princ "! ")\n    (decf *player-agility* x)\n    ;;为了防止进入永无止境的僵持,使slime有几率攻击\n    (when (zerop (random 2))\n      (princ "It also squirts in your face, taking away a health point! ")\n      (decf *player-health*))))\n;The Cunning Brigand\n(defstruct (brigand (:include monster)))\n(push #\'make-brigand *monster-builders*)\n(defmethod monster-attack ((m brigand))\n  (let ((x (max *player-health* *player-agility* *player-strength*)))\n    (cond ((= x *player-health*)\n           (princ "A brigand hits you with his slingshot, taking off 2 health\n                  points! ")\n                  (decf *player-health* 2))\n          ((= x *player-agility*)\n           (princ "A brigand catches your leg with his whip, taking off 2\n                  agility points! ")\n           (decf *player-agility* 2))\n          ((= x *player-strength*)\n           (princ "A brigand cuts your arm with his whip, taking off 2\n                  strength points! ")\n           (decf *player-strength* 2)))))\n\n```\n\n然后这样开始游戏\n\n```cl\n(orc-battle)\n```\n\n不过游戏参数貌似设置的不太好，我基本是出来被秒的！！\n',metaData:{layout:"post",title:"The Orc Battle Game",excerpt:"Yet another game written by lisp",category:"lisp",tags:["land-of-lisp"],disqus:!0}}}});