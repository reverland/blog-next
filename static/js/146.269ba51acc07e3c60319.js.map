{"version":3,"sources":["webpack:///static/js/146.269ba51acc07e3c60319.js","webpack:///./src/posts/2012-05-31-tail-call-optimization.md"],"names":["webpackJsonp","263","module","exports","rawContent","metaData","layout","title","excerpt","category","tags","disqus"],"mappings":"AAAAA,cAAc,IAAI,MAEZC,IACA,SAASC,EAAQC,GCHvBD,EAAAC,SACAC,WAAA,61CACAC,UACAC,OAAA,OACAC,MAAA,yBACAC,QAAA,6CACAC,SAAA,OACAC,MACA,gBAEAC,QAAA","file":"static/js/146.269ba51acc07e3c60319.js","sourcesContent":["webpackJsonp([146,170],{\n\n/***/ 263:\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"rawContent\": \"\\n\\n## 什么是尾递归\\n\\n尾递归作为一种函数式编程优化方法。为了理解这个奇怪的名字，看下面这个计算列表长度函数的例子:\\n\\n```cl\\n(defun my-length (lst)\\n  (if lst\\n      (1+ (my-length (cdr lst)))\\n      0))\\n```\\n\\n首先，它会检查列表是否是空的，如果不是，它递归地调用自身计算剩下列表的长度并加上1,如果是空的则返回0.\\n\\n结果是这个函数相当没有效率…………我们可以试试一个“大列表”：\\n\\n```cl\\n(defparameter *biglist* (loop for i below 100000 collect 'x))\\n```\\n\\n在clisp中试试……\\n\\n```cl\\n(my-length *biglist*)\\n\\n*** - Program stack overflow. RESET\\n```\\n\\nstack overflow！！问题出现在`+1`函数上，它告诉lisp解释器：“首先计算列表的长度，然后对结果调用`+1`。”\\n问题是每次我们递归调用`my-length`时，lisp必须记住我们之后要向结果添加1。由于列表有100000项长，lisp在它能`+1`之前要记住99999次！！clisp的做法是在堆栈中放个提示符，这导致最后堆栈溢出。\\n\\n我们如何避免这个问题呢？我们重新定义我们的`my-length`函数\\n\\n```cl linenos\\n(defun my-length (lst)\\n  (labels ((f (lst acc)\\n              (if lst\\n                 (f (cdr lst) (1+ acc))\\n                 acc)))\\n     (f lst 0)))\\n```\\n\\n我们定义了一个局部函数`f`作为list-eater,但同时多了个acc累加器。这个累加器累加遇到的列表数目，最开始调用f时acc置0.\\n\\n通过使用累加器，递归调用f不再需要向结果`+1`。当我们到达列表尾部（lst is nil），acc即为列表项数目，所以我们返回它。\\n\\n`f`最后做的是，当列表没到结尾时不断,调用自己。这种函数调用自身或其它函数的行为叫做*尾递归*,lisp解释器足够哦聪明去认出这种尾递归，它知道可以直接调用自身而不用等着把当前程序推入堆栈。\\n\\n有点像Basic中的goto和c++中的longjmp，但lisp中尾递归十分安全。\\n\\n## clisp中的尾递归优化\\n\\n并非所有的lisp解释器并不会进行尾递归优化，因为尾递归这种减少使用堆栈的方式不适合调试。\\n\\n为了在clisp中使用尾递归，我们可以这样\\n\\n```cl\\n(compile 'my-length)\\n(my-length *biglist*)\\n```\\n\\n有没有感觉速度超快？\\n\\n## Variable Shadowing\\n\\n注意`my-length`函数中参数lst和f中的lst，在每次递归调用中后者将取代前者，这种处理方式叫做Variable Shadowing.\\n\",\n\t\t\"metaData\": {\n\t\t\t\"layout\": \"post\",\n\t\t\t\"title\": \"Tail Call Optimization\",\n\t\t\t\"excerpt\": \"Tail call optimization in lisp interpreter\",\n\t\t\t\"category\": \"lisp\",\n\t\t\t\"tags\": [\n\t\t\t\t\"land-of-lisp\"\n\t\t\t],\n\t\t\t\"disqus\": true\n\t\t}\n\t};\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** static/js/146.269ba51acc07e3c60319.js\n **/","module.exports = {\n\t\"rawContent\": \"\\n\\n## 什么是尾递归\\n\\n尾递归作为一种函数式编程优化方法。为了理解这个奇怪的名字，看下面这个计算列表长度函数的例子:\\n\\n```cl\\n(defun my-length (lst)\\n  (if lst\\n      (1+ (my-length (cdr lst)))\\n      0))\\n```\\n\\n首先，它会检查列表是否是空的，如果不是，它递归地调用自身计算剩下列表的长度并加上1,如果是空的则返回0.\\n\\n结果是这个函数相当没有效率…………我们可以试试一个“大列表”：\\n\\n```cl\\n(defparameter *biglist* (loop for i below 100000 collect 'x))\\n```\\n\\n在clisp中试试……\\n\\n```cl\\n(my-length *biglist*)\\n\\n*** - Program stack overflow. RESET\\n```\\n\\nstack overflow！！问题出现在`+1`函数上，它告诉lisp解释器：“首先计算列表的长度，然后对结果调用`+1`。”\\n问题是每次我们递归调用`my-length`时，lisp必须记住我们之后要向结果添加1。由于列表有100000项长，lisp在它能`+1`之前要记住99999次！！clisp的做法是在堆栈中放个提示符，这导致最后堆栈溢出。\\n\\n我们如何避免这个问题呢？我们重新定义我们的`my-length`函数\\n\\n```cl linenos\\n(defun my-length (lst)\\n  (labels ((f (lst acc)\\n              (if lst\\n                 (f (cdr lst) (1+ acc))\\n                 acc)))\\n     (f lst 0)))\\n```\\n\\n我们定义了一个局部函数`f`作为list-eater,但同时多了个acc累加器。这个累加器累加遇到的列表数目，最开始调用f时acc置0.\\n\\n通过使用累加器，递归调用f不再需要向结果`+1`。当我们到达列表尾部（lst is nil），acc即为列表项数目，所以我们返回它。\\n\\n`f`最后做的是，当列表没到结尾时不断,调用自己。这种函数调用自身或其它函数的行为叫做*尾递归*,lisp解释器足够哦聪明去认出这种尾递归，它知道可以直接调用自身而不用等着把当前程序推入堆栈。\\n\\n有点像Basic中的goto和c++中的longjmp，但lisp中尾递归十分安全。\\n\\n## clisp中的尾递归优化\\n\\n并非所有的lisp解释器并不会进行尾递归优化，因为尾递归这种减少使用堆栈的方式不适合调试。\\n\\n为了在clisp中使用尾递归，我们可以这样\\n\\n```cl\\n(compile 'my-length)\\n(my-length *biglist*)\\n```\\n\\n有没有感觉速度超快？\\n\\n## Variable Shadowing\\n\\n注意`my-length`函数中参数lst和f中的lst，在每次递归调用中后者将取代前者，这种处理方式叫做Variable Shadowing.\\n\",\n\t\"metaData\": {\n\t\t\"layout\": \"post\",\n\t\t\"title\": \"Tail Call Optimization\",\n\t\t\"excerpt\": \"Tail call optimization in lisp interpreter\",\n\t\t\"category\": \"lisp\",\n\t\t\"tags\": [\n\t\t\t\"land-of-lisp\"\n\t\t],\n\t\t\"disqus\": true\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/json-loader/0.5.4/json-loader!./loader/post-loader.js!./src/posts/2012-05-31-tail-call-optimization.md\n ** module id = 263\n ** module chunks = 146\n **/"],"sourceRoot":""}