{"version":3,"sources":["webpack:///static/js/140.cd6f54bb5219c5a6f349.js","webpack:///./src/posts/2012-06-13-macro-in-lisp.md"],"names":["webpackJsonp","212","module","exports","rawContent","metaData","layout","title","excerpt","category","tags","disqus"],"mappings":"AAAAA,cAAc,IAAI,MAEZC,IACA,SAASC,EAAQC,GCHvBD,EAAAC,SACAC,WAAA,ksKACAC,UACAC,OAAA,OACAC,MAAA,gBACAC,QAAA,gBACAC,SAAA,OACAC,MACA,gBAEAC,QAAA","file":"static/js/140.cd6f54bb5219c5a6f349.js","sourcesContent":["webpackJsonp([140,170],{\n\n/***/ 212:\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"rawContent\": \"\\n\\n# lisp宏的魔力\\n\\n## lisp的宏\\n\\n注意：此宏远与cpp中的宏有着天壤之别，而且远复杂很多倍。\\n宏编程允许你创造自己的语言。当面对一个复杂编程挑战时，有经验的程序猿会问自己：那种语言适合解决这个问题？然后他用宏把lisp变成了那种语言。太扯了……\\n\\n先举例说明什么是宏\\n\\n看这个例子\\n\\n```cl\\n(defun add (a b)\\n  (let ((x (+ a b)))\\n    (format t \\\"The sum is ~a\\\" x)\\n    x)) \\n(add 3 4)\\n```\\n\\n有没有感觉括号太多了？我们定义个let1宏\\n\\n```cl\\n(defmacro let1 (var val &body body)\\n  `(let ((,var ,val))\\n     ,@body))\\n```\\n\\n&body表示剩下的部分是表达式，而且隐含着一个progn的并行表达式，回忆\\\"`\\\"与\\\",\\\"的作用\\\",@\\\"相对于\\\"，\\\"用来表征并行表达式。\\n\\n试试你的宏\\n\\n```cl\\n(let ((foo (+ 2 3)))\\n  (* foo foo))\\n(let1 foo (+ 2 3)\\n  (* foo foo))\\n(defun add (a b)\\n  (let1 x (+ a b)\\n    (format t \\\"The sum is ~a\\\" x)\\n    x))\\n```\\n\\n## 宏展开\\n\\n宏的展开发生在运行期前，它把你非标准的程序转换成标准的lisp语言,然后传递给标准lisp解释器\\n\\n你可以用macroexpand来展开宏\\n\\n```cl\\n(macroexpand '(let1 foo (+ 2 3)\\n                (* foo foo)))\\n```\\n\\n这将是很有效的调试方法。\\n\\n## 更复杂一些的宏\\n\\n回忆下之前我们定义的尾递归优化length函数\\n\\n```cl\\n(defun my-length (lst)\\n  (labels ((f (lst acc)\\n             (if lst\\n               (f (cdr lst) (1+ acc))\\n               acc)))\\n    (f lst 0)))\\n```\\n\\n正如所见，我们反复使用cdr，反复检查列表是否为空。我们用冗长的工作去创造局部函数f，我们可以用宏让它更简洁一些。\\n\\n### 一个分割列表的宏\\n\\n一个能把列表分开，并能把列表头和尾提供给我们用split宏非常有用。我们可以得到这么一个有bug的宏：\\n\\n```cl\\n;Warning!Containing Bugs!\\n(defmacro split (val yes no)\\n  `(if ,val\\n     (let ((head (car ,val))\\n           (tail (cdr ,val)))\\n       ,yes)\\n     ,no))\\n```\\n\\n列表的car和cdr分别保存在head和tail中。如果列表不能split，将不会创建head和tail变量。\\n\\n于是my-length函数整洁些了\\n\\n```cl\\n(defun my-length (lst)\\n  (labels ((f (lst acc)\\n             (split lst\\n                    (f tail (1+ acc))\\n                    acc)))\\n    (f lst 0)))\\n```\\n\\n### 避免重复的执行\\n\\n试试这样：\\n\\n```cl\\n(split (progn (princ \\\"Lisp rocks!\\\")\\n              '(2 3))\\n       (format t \\\"This can be split into ~a and ~a.\\\" head tail)\\n       (format t \\\"This cannot be split.\\\"))\\n```\\n\\n哦～为什么会执行三次打印Lisp rocks！展开宏看看\\n\\n```cl\\n(macroexpand '(split (progn (princ \\\"Lisp rocks!\\\")\\n                            '(2 3))\\n                     (format t \\\"THis can be split into ~a and ~a.\\\" head tail)\\n                     (format t \\\"This cannot be split\\\")))\\n```\\n\\n你看到了什么……某动作被执行了三次。\\n\\n我很惊异的是这种情况common lisp也接受，还可以这样把命令写在函数中。\\n\\n```cl\\n(car (progn (princ \\\"Lisp rocks!\\\") '(2 3)))\\nLisp rocks!\\n2\\n```\\n\\n为了避免这种情况我们重新改写split宏，注意，还是有bug的版本\\n\\n```cl\\n;Warning! Still contains a bug!\\n(defmacro split (val yes no) \\n  `(let1 x ,val \\n     (if x \\n       (let ((head (car x))\\n             (tail (cdr x)))\\n         ,yes) \\n         ,no))) \\n```\\n\\n可以在宏内使用其它宏，像这里我们用了之前的let1宏。我们用一个变量绑定表达式，这时就不会重复执行了。但有了个新问题。\\n\\n### 避免变量捕获\\n\\n问题在哪里呢？试试下面的式子\\n\\n```cl\\n(let1 x 100\\n  (split '(2 3)\\n         (+ x head)\\n         nil))\\n```\\n\\n什么情况，竟然报错了！！我们展开它看看\\n\\n```cl\\n(macroexpand '(split '(2 3)\\n                     (+ x head)\\n                     nil))\\n```\\n\\nsplit意外地捕获了外部变量x并且覆盖了前者。怎么避免这个问题？？\\n这个函数专门用来解决这类问题\\n\\n```cl\\n(gensym)\\n```\\n\\n它返回随机的名字，并且一定不会和已有的变量重复。使用它我们可以获得最终能安全使用的split版本\\n\\n```cl\\n(defmacro split (val yes no)\\n  (let1 g (gensym)\\n    `(let1 ,g ,val\\n       (if ,g\\n         (let ((head (car ,g))\\n               (tail (cdr ,g)))\\n           ,yes)\\n         ,no))))\\n```\\n\\n两次绑定，先随机生成一个变量名，在把具体的值绑在这个随机生成的变量名上。可以展开看看\\n\\n```cl\\n;Each time is different\\n(macroexpand '(split '(2 3)\\n                     (+ x head)\\n                     nil))\\n```\\n\\n每次结果都不同。\\n\\n## 递归宏\\n\\n再次考虑我们的my-length函数\\n\\n```cl\\n(defun my-length (lst)\\n  (labels ((f (lst acc)\\n             (split lst\\n                    (f tail (1+ acc))\\n                    acc)))\\n    (f lst 0)))\\n```\\n\\n局部函数f重复的建立。我们可以通过宏来简化它。想象这么一个recurse宏：\\n\\n```cl\\n(recurse (n 9)\\n(fresh-line)\\n(if (zerop n)\\n(princ \\\"lift-off!\\\")\\n(progn (princ n)\\n(self (1- n)))))\\n9\\n8\\n7\\n6\\n5\\n4\\n3\\n2\\n1\\nlift-off!\\n```\\n\\n为了将列表奇数项作为变量偶数项作为值，可以写一个函数来生成cons对。像这样\\n\\n```cl\\n(pairs '(a b c d e f))\\n((A . B) (C . D) (E . F))\\n```\\n\\n函数可以这样定义,看着真绕……\\n \\n```cl\\n;tail-call-optimized list-eater\\n(defun pairs (lst)\\n  (labels ((f (lst acc)\\n             (split lst\\n                    (if tail\\n                      (f (cdr tail) (cons (cons head (car tail)) acc))\\n                      (reverse acc))\\n                    (reverse acc))))\\n    (f lst nil)))\\n```\\n\\n然后可以写出recurse宏\\n\\n```cl\\n(defmacro recurse (vars &body body)\\n  (let1 p (pairs vars)\\n    `(labels ((self ,(mapcar #'car p)\\n                ,@body))\\n       (self ,@(mapcar #'cdr p)))))\\n```\\n\\n重新定义我们的my-length函数\\n\\n```cl\\n(defun my-length (lst)\\n  (recurse (lst lst\\n                acc 0)\\n           (split lst\\n                  (f tail (1+ acc))\\n                  acc)))\\n```\\n\\n作者费了一大圈后认为现在看着很简洁，你觉得呢？\\n\\n## 宏的危险与其它选择\\n\\n把语言定义成任意你想要的模式，这当然很危险。若干岁月后回头都看不懂你自己写的什么，何况别人！所以，能用函数式解决的问题就别用宏来解决吧，骚年。看看我们的my-length函数，可以用高阶函数reduce轻松简化。\\n\\n```cl\\n(defun my-length (lst)\\n  (reduce (lambda (x i)\\n            (1+ x))\\n          lst\\n          :initial-value 0))\\n```\\n\\nreduce可以连续调用上次结果并与当前列表项一同运算。i代表当前为第几项，对我们没什么用，最后x初值为0一定要加上。\\n\\n然而仍然有些问题用函数式并不能很好解决而用宏可以轻易处理。下一章？拭目以待吧。\\n\\n## 小结\\n\\n- 宏允许你用代码生成代码，通过宏，你可以创造自己的语言，并在lisp解释器解释之前转化成标准lisp。\\n\\n- 宏允许你摆脱一种既视感。摆脱各种括号和重复\\n\\n- 当你写宏的时候你必须小心，这样才不会导致意外的重复执行的代码\\n\\n- 你需要避免变量捕获，这可以通过gensym来解决\\n\\n- 如果一个宏创造的变量故意暴露，作为宏的一个特性，这种宏叫做anaphoric macros\\n\\n- 宏编程是非常有力的技术。然而，尽量使用函数式编程代替宏来解决问题。宏是最后的法宝。\\n\\n## 最后的废话\\n\\n今天难得去图书馆了，三楼看到本real world haskell，只能感慨自己没空看了，二楼空无一人，看着散乱而泛黄的旧书顿生悲凉。一楼人倒挺多，都是来为四六级托福雅思考研等等等等自习的，很少有看书的。三楼人也有些，不过都集中在文学小说和艺术的区域。\\n\\n不知为什么，总有种世风日下的感觉。回忆起当初在图书馆看书的日子……\\n\",\n\t\t\"metaData\": {\n\t\t\t\"layout\": \"post\",\n\t\t\t\"title\": \"Macro in lisp\",\n\t\t\t\"excerpt\": \"简要介绍lisp中宏的使用\",\n\t\t\t\"category\": \"lisp\",\n\t\t\t\"tags\": [\n\t\t\t\t\"land-of-lisp\"\n\t\t\t],\n\t\t\t\"disqus\": true\n\t\t}\n\t};\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** static/js/140.cd6f54bb5219c5a6f349.js\n **/","module.exports = {\n\t\"rawContent\": \"\\n\\n# lisp宏的魔力\\n\\n## lisp的宏\\n\\n注意：此宏远与cpp中的宏有着天壤之别，而且远复杂很多倍。\\n宏编程允许你创造自己的语言。当面对一个复杂编程挑战时，有经验的程序猿会问自己：那种语言适合解决这个问题？然后他用宏把lisp变成了那种语言。太扯了……\\n\\n先举例说明什么是宏\\n\\n看这个例子\\n\\n```cl\\n(defun add (a b)\\n  (let ((x (+ a b)))\\n    (format t \\\"The sum is ~a\\\" x)\\n    x)) \\n(add 3 4)\\n```\\n\\n有没有感觉括号太多了？我们定义个let1宏\\n\\n```cl\\n(defmacro let1 (var val &body body)\\n  `(let ((,var ,val))\\n     ,@body))\\n```\\n\\n&body表示剩下的部分是表达式，而且隐含着一个progn的并行表达式，回忆\\\"`\\\"与\\\",\\\"的作用\\\",@\\\"相对于\\\"，\\\"用来表征并行表达式。\\n\\n试试你的宏\\n\\n```cl\\n(let ((foo (+ 2 3)))\\n  (* foo foo))\\n(let1 foo (+ 2 3)\\n  (* foo foo))\\n(defun add (a b)\\n  (let1 x (+ a b)\\n    (format t \\\"The sum is ~a\\\" x)\\n    x))\\n```\\n\\n## 宏展开\\n\\n宏的展开发生在运行期前，它把你非标准的程序转换成标准的lisp语言,然后传递给标准lisp解释器\\n\\n你可以用macroexpand来展开宏\\n\\n```cl\\n(macroexpand '(let1 foo (+ 2 3)\\n                (* foo foo)))\\n```\\n\\n这将是很有效的调试方法。\\n\\n## 更复杂一些的宏\\n\\n回忆下之前我们定义的尾递归优化length函数\\n\\n```cl\\n(defun my-length (lst)\\n  (labels ((f (lst acc)\\n             (if lst\\n               (f (cdr lst) (1+ acc))\\n               acc)))\\n    (f lst 0)))\\n```\\n\\n正如所见，我们反复使用cdr，反复检查列表是否为空。我们用冗长的工作去创造局部函数f，我们可以用宏让它更简洁一些。\\n\\n### 一个分割列表的宏\\n\\n一个能把列表分开，并能把列表头和尾提供给我们用split宏非常有用。我们可以得到这么一个有bug的宏：\\n\\n```cl\\n;Warning!Containing Bugs!\\n(defmacro split (val yes no)\\n  `(if ,val\\n     (let ((head (car ,val))\\n           (tail (cdr ,val)))\\n       ,yes)\\n     ,no))\\n```\\n\\n列表的car和cdr分别保存在head和tail中。如果列表不能split，将不会创建head和tail变量。\\n\\n于是my-length函数整洁些了\\n\\n```cl\\n(defun my-length (lst)\\n  (labels ((f (lst acc)\\n             (split lst\\n                    (f tail (1+ acc))\\n                    acc)))\\n    (f lst 0)))\\n```\\n\\n### 避免重复的执行\\n\\n试试这样：\\n\\n```cl\\n(split (progn (princ \\\"Lisp rocks!\\\")\\n              '(2 3))\\n       (format t \\\"This can be split into ~a and ~a.\\\" head tail)\\n       (format t \\\"This cannot be split.\\\"))\\n```\\n\\n哦～为什么会执行三次打印Lisp rocks！展开宏看看\\n\\n```cl\\n(macroexpand '(split (progn (princ \\\"Lisp rocks!\\\")\\n                            '(2 3))\\n                     (format t \\\"THis can be split into ~a and ~a.\\\" head tail)\\n                     (format t \\\"This cannot be split\\\")))\\n```\\n\\n你看到了什么……某动作被执行了三次。\\n\\n我很惊异的是这种情况common lisp也接受，还可以这样把命令写在函数中。\\n\\n```cl\\n(car (progn (princ \\\"Lisp rocks!\\\") '(2 3)))\\nLisp rocks!\\n2\\n```\\n\\n为了避免这种情况我们重新改写split宏，注意，还是有bug的版本\\n\\n```cl\\n;Warning! Still contains a bug!\\n(defmacro split (val yes no) \\n  `(let1 x ,val \\n     (if x \\n       (let ((head (car x))\\n             (tail (cdr x)))\\n         ,yes) \\n         ,no))) \\n```\\n\\n可以在宏内使用其它宏，像这里我们用了之前的let1宏。我们用一个变量绑定表达式，这时就不会重复执行了。但有了个新问题。\\n\\n### 避免变量捕获\\n\\n问题在哪里呢？试试下面的式子\\n\\n```cl\\n(let1 x 100\\n  (split '(2 3)\\n         (+ x head)\\n         nil))\\n```\\n\\n什么情况，竟然报错了！！我们展开它看看\\n\\n```cl\\n(macroexpand '(split '(2 3)\\n                     (+ x head)\\n                     nil))\\n```\\n\\nsplit意外地捕获了外部变量x并且覆盖了前者。怎么避免这个问题？？\\n这个函数专门用来解决这类问题\\n\\n```cl\\n(gensym)\\n```\\n\\n它返回随机的名字，并且一定不会和已有的变量重复。使用它我们可以获得最终能安全使用的split版本\\n\\n```cl\\n(defmacro split (val yes no)\\n  (let1 g (gensym)\\n    `(let1 ,g ,val\\n       (if ,g\\n         (let ((head (car ,g))\\n               (tail (cdr ,g)))\\n           ,yes)\\n         ,no))))\\n```\\n\\n两次绑定，先随机生成一个变量名，在把具体的值绑在这个随机生成的变量名上。可以展开看看\\n\\n```cl\\n;Each time is different\\n(macroexpand '(split '(2 3)\\n                     (+ x head)\\n                     nil))\\n```\\n\\n每次结果都不同。\\n\\n## 递归宏\\n\\n再次考虑我们的my-length函数\\n\\n```cl\\n(defun my-length (lst)\\n  (labels ((f (lst acc)\\n             (split lst\\n                    (f tail (1+ acc))\\n                    acc)))\\n    (f lst 0)))\\n```\\n\\n局部函数f重复的建立。我们可以通过宏来简化它。想象这么一个recurse宏：\\n\\n```cl\\n(recurse (n 9)\\n(fresh-line)\\n(if (zerop n)\\n(princ \\\"lift-off!\\\")\\n(progn (princ n)\\n(self (1- n)))))\\n9\\n8\\n7\\n6\\n5\\n4\\n3\\n2\\n1\\nlift-off!\\n```\\n\\n为了将列表奇数项作为变量偶数项作为值，可以写一个函数来生成cons对。像这样\\n\\n```cl\\n(pairs '(a b c d e f))\\n((A . B) (C . D) (E . F))\\n```\\n\\n函数可以这样定义,看着真绕……\\n \\n```cl\\n;tail-call-optimized list-eater\\n(defun pairs (lst)\\n  (labels ((f (lst acc)\\n             (split lst\\n                    (if tail\\n                      (f (cdr tail) (cons (cons head (car tail)) acc))\\n                      (reverse acc))\\n                    (reverse acc))))\\n    (f lst nil)))\\n```\\n\\n然后可以写出recurse宏\\n\\n```cl\\n(defmacro recurse (vars &body body)\\n  (let1 p (pairs vars)\\n    `(labels ((self ,(mapcar #'car p)\\n                ,@body))\\n       (self ,@(mapcar #'cdr p)))))\\n```\\n\\n重新定义我们的my-length函数\\n\\n```cl\\n(defun my-length (lst)\\n  (recurse (lst lst\\n                acc 0)\\n           (split lst\\n                  (f tail (1+ acc))\\n                  acc)))\\n```\\n\\n作者费了一大圈后认为现在看着很简洁，你觉得呢？\\n\\n## 宏的危险与其它选择\\n\\n把语言定义成任意你想要的模式，这当然很危险。若干岁月后回头都看不懂你自己写的什么，何况别人！所以，能用函数式解决的问题就别用宏来解决吧，骚年。看看我们的my-length函数，可以用高阶函数reduce轻松简化。\\n\\n```cl\\n(defun my-length (lst)\\n  (reduce (lambda (x i)\\n            (1+ x))\\n          lst\\n          :initial-value 0))\\n```\\n\\nreduce可以连续调用上次结果并与当前列表项一同运算。i代表当前为第几项，对我们没什么用，最后x初值为0一定要加上。\\n\\n然而仍然有些问题用函数式并不能很好解决而用宏可以轻易处理。下一章？拭目以待吧。\\n\\n## 小结\\n\\n- 宏允许你用代码生成代码，通过宏，你可以创造自己的语言，并在lisp解释器解释之前转化成标准lisp。\\n\\n- 宏允许你摆脱一种既视感。摆脱各种括号和重复\\n\\n- 当你写宏的时候你必须小心，这样才不会导致意外的重复执行的代码\\n\\n- 你需要避免变量捕获，这可以通过gensym来解决\\n\\n- 如果一个宏创造的变量故意暴露，作为宏的一个特性，这种宏叫做anaphoric macros\\n\\n- 宏编程是非常有力的技术。然而，尽量使用函数式编程代替宏来解决问题。宏是最后的法宝。\\n\\n## 最后的废话\\n\\n今天难得去图书馆了，三楼看到本real world haskell，只能感慨自己没空看了，二楼空无一人，看着散乱而泛黄的旧书顿生悲凉。一楼人倒挺多，都是来为四六级托福雅思考研等等等等自习的，很少有看书的。三楼人也有些，不过都集中在文学小说和艺术的区域。\\n\\n不知为什么，总有种世风日下的感觉。回忆起当初在图书馆看书的日子……\\n\",\n\t\"metaData\": {\n\t\t\"layout\": \"post\",\n\t\t\"title\": \"Macro in lisp\",\n\t\t\"excerpt\": \"简要介绍lisp中宏的使用\",\n\t\t\"category\": \"lisp\",\n\t\t\"tags\": [\n\t\t\t\"land-of-lisp\"\n\t\t],\n\t\t\"disqus\": true\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/json-loader/0.5.4/json-loader!./loader/post-loader.js!./src/posts/2012-06-13-macro-in-lisp.md\n ** module id = 212\n ** module chunks = 140\n **/"],"sourceRoot":""}