webpackJsonp([160,192],{293:function(n,l){n.exports={rawContent:"\n\n# 惰性求值\n\n## 啥叫惰性求值\n\n具体的含义可以参看这里 [惰性求值](http://zh.wikipedia.org/zh/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC) 。我的看法就是一种延迟计算方法，好像一个懒汉，只计算需要计算的东西。\n\n## 为什么要惰性求值\n\n因为惰性求值能极大优化程序的性能，想想那个[Dice of Doom](/lisp/2012/05/23/dice-of-doom/)的游戏，如果不需要每次都生成不需要的游戏树，将会节省多少时间和电力。同时，惰性求值能做到一些几乎不可能的事，构造无穷的东西。\n\n### 在common lisp中实现一整套惰性求值函数库\n\n据作者说，像Haskell和Clojure这样的预言直接把惰性求值作为语言默认的一部分，common lisp则没有这样，不过实现一整套惰性求值库也没有什么难度\n\n延迟求值我们想要得到这样的东西：lazy和force.lazy只返回函数。\n\n```cl\n(lazy (+ 1 2))\n#<FUNCTION...>\n(force (lazy (+ 1 2)))\n3\n```\n\nlazy可以用宏这么实现\n\n```cl\n(defmacro lazy (&body body)\n  (let ((forced (gensym))\n        (value (gensym)))\n    `(let ((,forced nil)\n           (,value nil))\n       (lambda ()\n         (unless ,forced;unless，when后是并行结构\n           (setf ,value (progn ,@body))\n           (setf ,forced t))\n         ,value))))\n```\n\nforce可以直接用简单的函数实现\n\n```cl\n(defun force (lazy-value)\n  (funcall lazy-value))\n```\n\n但我们需要的不只这些，要完成惰性求值需要一整套相应的函数比如延迟的cons、cdr、car、nth、mapcar等等等等。建立延迟的cons和相应的cdr和car\n\n```cl\n(defmacro lazy-cons (a d)\n  `(lazy (cons ,a ,d)))\n(defun lazy-car (x)\n  (car (force x)))\n(defun lazy-cdr (x)\n  (cdr (force x)))\n```\n\n猜猜这是在干什么\n\n```cl\n(defparameter *integers*\n  (labels ((f (n)\n             (lazy-cons n (f (1+ n)))))\n    (f 1)))\n(lazy-car (lazy-cdr *integers*)) \n(lazy-car (lazy-cdr (lazy-cdr *integers*)))\n```\n\n我们还需要延迟生成lazy-nil和判断空延迟求值的列表的lazy-null\n\n```cl\n(defun lazy-nil ()\n  (lazy nil))\n;(force (lazy-nil)) \n(defun lazy-null (x)\n  (not (force x)))\n```\n\n然后是将常规列表和惰性列表相互转换的函数make-lazy、take、take-all.注意take-all只能返回有限列表。\n\n```cl\n(defun make-lazy (lst)\n  (lazy (when lst\n          (cons (car lst) (make-lazy (cdr lst))))))\n(defun take (n lst)\n  (unless (or (zerop n) (lazy-null lst))\n    (cons (lazy-car lst) (take (1- n) (lazy-cdr lst)))))\n(defun take-all (lst)\n  (unless (lazy-null lst)\n    (cons (lazy-car lst) (take-all (lazy-cdr lst)))))\n(take 10 *integers*)\n(take 10 (make-lazy '(a s d f g h j k l q w e r t y u i)))\n(take-all (make-lazy '(a s d f g h j k l q w e r t y u i)))\n```\n\n是不是看不懂？作者说它深邃如禅宗公案，需要凝神细视许久才能了悟。\n\n然后是遍历和搜索整个惰性列表的mapcar、mapcan、find-if和nth函数。mapcar和mapcan返回的也是惰性列表，find-if和nth则返回原子。\n\n```cl\n(defun lazy-mapcar (fun lst)\n  (lazy (unless (lazy-null lst)\n          (cons (funcall fun (lazy-car lst))\n                (lazy-mapcar fun (lazy-cdr lst))))))\n;现在我还是得看着Hyperspec来分辨这一堆map\n(defun lazy-mapcan (fun lst)\n  (labels ((f (lst-cur)\n             (if (lazy-null lst-cur)\n               (force (lazy-mapcan fun (lazy-cdr lst)))\n               (cons (lazy-car lst-cur) (lazy (f (lazy-cdr lst-cur)))))))\n    (lazy (unless (lazy-null lst)\n            (f (funcall fun (lazy-car lst)))))))\n(defun lazy-find-if (fun lst)\n  (unless (lazy-null lst)\n    (let ((x (lazy-car lst)))\n      (if (funcall fun x)\n        x\n        (lazy-find-if fun (lazy-cdr lst))))))\n(defun lazy-nth (n lst)\n  (if (zerop n)\n    (lazy-car lst)\n    (lazy-nth (1- n) (lazy-cdr lst))))\n```\n\n使用也很直观\n\n```cl\n(take 10 (lazy-mapcar #'sqrt *integers*))\n(take 10 (lazy-mapcan (lambda (x)\n                        (if (evenp x)\n                          (make-lazy (list x))\n                          (lazy-nil)))\n                      *integers*))\n(lazy-find-if #'oddp (make-lazy '(2 4 6 7 8 10)))\n(lazy-nth 4 (make-lazy '(a b c d e f g)))\n```\n\n## 最后的废话\n\n不爽的事很多，人与人之间的差别太大，根本不能相互理解。上无聊的课，听老师扯淡，做无聊的事，这就是世界，这就是生活？\n\n老师说你该下定决心了，可我带着多少不舍与怀疑，甚至畏惧。\n\n室友dota视频依然放的很欢，还有想一暑假打dota的人。然而无关对错，谁也无法预言未来。\n\n然而我想珍惜我的生命，珍惜令我着迷的事物。不想在这里那里被各种无聊的人和事磨灭激情，唉……\n\n别人都在想些什么呢？别人想得差别怎么这么大？\n\n走下去，哪怕是条孤苦的路，此生不后悔。\n\n\n\n",metaData:{layout:"post",title:"惰性求值",excerpt:"在common lisp完成一套惰性求值函数库。",category:"lisp",tags:["land-of-lisp"],disqus:!0}}}});