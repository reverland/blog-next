webpackJsonp([163,177],{260:function(n,e){n.exports={rawContent:'\n\n## 满目的loop\n\nloop是lisp中饱受争议的命令，因为它看起来不这么lispy，但它真得很强大。以下列举下基本用法：\n\n```cl\n(loop for i\n      below 5\n      sum i) \n;counting from a starting point to an ending point\n(loop for i\n      from 5\n      to 10\n      sum i)\n;iterating through values in a list\n(loop for i\n      in \'(100 20 3)\n      sum i)\n;doing stuff in a loop\n(loop for i\n      below 5\n      do (print i))\n;dong stuff under certain conditions\n(loop for i\n      below 10\n      when (oddp i)\n      sum i)\n;breaking out of a loop early\n(loop for i\n      from 0\n      do (print i)\n      when (= i 5)\n      return \'falafel)\n;collecting a list of values\n(loop for i\n      in \'(2 3 4 5 6)\n      collect (* i i))\n;using multiple for clauses\n;loop 10 times\n(loop for x below 10\n      for y below 10\n      collect (+ x y))\n;nested loops for 10x10 times\n(loop for x below 10\n      collect (loop for y below 10\n                    collect (+ x y)))\n;track the index number of items in a list\n(loop for i\n      from 0\n      for day\n      in \'(monday tuesday wednesday thursday friday saturday sunday)\n      collect (cons i day))\n```\n\n当然还有很多，这个命令异常灵活，以致于作者做了个[loop周期表][1]。\n\n## Using Loop to Evolve\n\n这个游戏看上去还挺轻松的，很有意思的“生命游戏”。不多说了，上码\n\n```cl\n;;;The extent of the world\n(defparameter *width* 100)\n(defparameter *height* 30)\n(defparameter *jungle* \'(45 10 10 10))\n(defparameter *plant-energy* 80)\n;;;Growing plants in our world\n;;cons cells should be compared with equal\n(defparameter *plants* (make-hash-table :test #\'equal))\n;;Grow new plants\n(defun random-plant (left top width height)\n  (let ((pos (cons (+ left (random width)) (+ top (random height)))))\n    (setf (gethash pos *plants*) t)))\n(defun add-plants ()\n  (apply #\'random-plant *jungle*)\n  (random-plant 0 0 *width* *height*))\n;;;Creating animals\n(defstruct animal x y energy dir genes)\n;;x,y stand for the position\n;;energy represent its energy,when the energy exhausted,it will die\n;;dir is the direction it faced\n;;genes decide the direction it will choose\n;;Creating an animal in the center of the map\n(defparameter *animals*\n  (list (make-animal :x;we only use list to traverse animal,\n                     ;its efficient enough.\n                     (ash *width* -1)\n                     :y\n                     (ash *height* -1)\n                     :energy\n                     1000\n                     :dir\n                     0\n                     :genes\n                     (loop repeat 8\n                           ;collect is OK??\n                           collecting (1+ (random 10))))))\n;;;Handling animal motion\n(defun move (animal)\n  (let ((dir (animal-dir animal))\n        (x (animal-x animal))\n        (y (animal-y animal)))\n    ;如果达到*width*,置0\n    (setf (animal-x animal) (mod (+ x\n                                    (cond ((and (>= dir 2) (< dir 5)) 1)\n                                          ((or (= dir 1) (= dir 5)) 0)\n                                          (t -1))\n                                    *width*)\n                                 *width*))\n    (setf (animal-y animal) (mod (+ y\n                                    (cond ((and (>= dir 0) (< dir 3)) -1)\n                                          ((and (>= dir 4) (< dir 7)) 1)\n                                          (t 0))\n                                    *height*)\n                                 *height*))\n    (decf (animal-energy animal))))\n;;;Handling animal turning\n(defun turn (animal)\n  (let ((x (random (apply #\'+ (animal-genes animal)))))\n    ;;this was not easy to understand it,\n    ;;当随机数落在哪个区间就哪个方向的递归描述\n    (labels ((angle (genes x)\n               (let ((xnu (- x (car genes))))\n                 (if (< xnu 0)\n                   0\n                   (1+ (angle (cdr genes) xnu))))))\n      (setf (animal-dir animal)\n            (mod (+ (animal-dir animal) (angle (animal-genes animal) x))\n              8)))))\n;;;Handling animal eating\n(defun eat (animal)\n  (let ((pos (cons (animal-x animal) (animal-y animal))))\n    (when (gethash pos *plants*)\n      (incf (animal-energy animal) *plant-energy*)\n      (remhash pos *plants*))))\n;;;Handling animal reproduction\n;;定义繁殖时需要能量\n(defparameter *reproduction-energy* 200)\n(defun reproduce (animal)\n  (let ((e (animal-energy animal)))\n    (when (>= e *reproduction-energy*)\n      (setf (animal-energy animal) (ash e -1))\n      (let ((animal-nu (copy-structure animal));浅复制命令\n            (genes (copy-list (animal-genes animal)))\n            (mutation (random 8)))\n        (setf (nth mutation genes) \n              (max 1 (+ (nth mutation genes) (random 3) -1)))\n;This means the gene value will change plus or minus one, or\n;stay the same.\n        (setf (animal-genes animal-nu) genes)\n        (push animal-nu *animals*)))))\n;;;Simulating a day in our world\n(defun update-world ()\n  (setf *animals* (remove-if (lambda (animal)\n                               (<= (animal-energy animal) 0))\n                             *animals*))\n  (mapc (lambda (animal)\n          (turn animal)\n          (move animal)\n          (eat animal)\n          (reproduce animal))\n        *animals*)\n  (add-plants))\n;;;Drawing our world\n;;;This has low performance but will not matters\n(defun draw-world ()\n  (loop for y\n        below *height*\n        do (progn \n             (fresh-line);outputs a newline only if the output-stream\n             ;is not already at the start of a line\n             (princ "|")\n             (loop for x\n                   below *width*\n                   do (princ (cond ((some (lambda (animal)\n                                     ;可能不止一个动物\n                                            (and (= (animal-x animal) x)\n                                                 (= (animal-y animal) y)))\n                                          *animals*)\n                                    #\\M)\n                                   ((gethash (cons x y) *plants*) #\\*)\n                                   (t #\\space))))\n             (princ "|"))))\n;;;Creating a user interface\n(defun evolution ()\n  (draw-world)\n  (fresh-line)\n  (let ((str (read-line)))\n    (cond ((equal str "quit") ())\n;Recall Conrad’s Rule of Thumb for Comparing Stuff\n;use eq for symbols\n;use equal for everything else\n          (t (let ((x (parse-integer str :junk-allowed t)))\n               (if x\n                 (loop for i\n                       below x\n                       do (update-world)\n                       if (zerop (mod i 1000))\n                       do (princ #\\.))\n                 (update-world))\n               (evolution))))))\n\n```\n\n这样开始模拟\n\n```cl\n(evolution)\n```\n\n回车看看，100次看看，5000000次看看，据作者说5million次sbcl几分钟就可以搞定。我相信我的计算机比作者那时候好，可是....\n\n```cl\nEvaluation took:\n  789.430 seconds of real time\n  459.846682 seconds of total run time (456.986869 user, 2.859813 system)\n  [ Run times consist of 18.864 seconds GC time, and 440.983 seconds non-GC time. ]\n  58.25% CPU\n  1,785,005,533,676 processor cycles\n  125,872,778,768 bytes consed\n```\n\n什么叫手抖竟然开始打成了5billion.这时候科学计数法就发挥作用了，感谢自由建客。\n\n***\n\nLooks good however，\n\nM代表某无性生殖动物，`*`代表某随机生长植物\n\n<img src="http://lhtlyybox.googlecode.com/files/%E6%8A%93%E5%9B%BE75.png" hight="200" width="400" alt="虚拟进化" />\n\n***\n\n## 写在最后\n\n资源丰富区自然选择留下了那些逡巡不前的，资源短缺区留下了富于冒险的。\n\n之后有上网查查其它进化游戏，发现资源丰富时资源消耗小的被淘汰，资源缺乏时资源消耗大的被淘汰\n\n启发性的游戏啊\n\n最后看了个有关进化选择的视频，是某研究人员们通过进化设计人工大脑的，感觉很震惊。特别是看到最后对之失控，看到人工大脑进化出意想不到的特性时。\n\n[1]: http://landoflisp.com/\n',metaData:{layout:"post",title:"Using Loop To Evolve",excerpt:"Something like life game.",category:"lisp",tags:["land-of-lisp"],disqus:!0}}}});