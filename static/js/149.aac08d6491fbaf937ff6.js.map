{"version":3,"sources":["webpack:///static/js/149.aac08d6491fbaf937ff6.js","webpack:///./src/posts/2012-05-23-dice-of-doom.md"],"names":["webpackJsonp","260","module","exports","rawContent","metaData","layout","title","excerpt","category","tags","disqus"],"mappings":"AAAAA,cAAc,IAAI,MAEZC,IACA,SAASC,EAAQC,GCHvBD,EAAAC,SACAC,WAAA,giOACAC,UACAC,OAAA,OACAC,MAAA,eACAC,QAAA,gDACAC,SAAA,OACAC,MACA,gBAEAC,QAAA","file":"static/js/149.aac08d6491fbaf937ff6.js","sourcesContent":["webpackJsonp([149,170],{\n\n/***/ 260:\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"rawContent\": \"\\n\\n## 照例前面来些废话\\n\\n前一阵忙着看通信原理，近来各科都陆续结课，又接连有这么几科让写个什么论文，忙忙碌碌之后发现lisp就没怎么看了，以致于这一章都看快一星期了还没看完。不过回头多看几次后，因为对游戏要生成个什么样的game tree有了整体上的把握，理解起来简单多了。所以奉劝其它读者先搞清楚要生成个什么样的game tree和作者的设计方案，再来看后面的代码部分。\\n\\n昨天还激动终于看到用lisp来实现人工智能了，结果一看几行代码实现个[minmax][1]算法的问题……失望了。\\n\\n##Dice of Doom\\n\\n###游戏规则\\n\\n这是个怎么样的游戏？看看[这里][2]就知道了。我们现在就要用函数式编程风格写一个这样的游戏，当然，从简单的开始。简单到只有两个玩家，只以骰子数目多少来决定能否“占领”对方的领地。\\n\\n本想举个例子，不过画图挺麻烦的，现在没什么空。有空再补上。\\n\\n有这么一些规则：\\n\\n- 两个玩家占据着六边形阵列上的各个六边形。每个六边形都有一些立方体骰子，被两个玩家分别占有。\\n- 在一个回合内，玩家可以执行任意数目的移动，但至少移动一次。如果他不能移动那么他就输了。\\n- 移动包括攻击邻近的对方六边形。玩家发动攻击的六边形必须比要攻击的对方的六边形拥有更多骰子。将来可能我们会真的“转动”这些骰子。\\n- 攻击结束后，输者在被攻击六边形的骰子被移除，发动攻击的六边形留下一个骰子，将其它所有骰子移到占领的新地方。\\n- 当玩家完成他所有的移动，将获得他消灭的骰子总数减一的增援。增援从左上角开始给每个己方六角形增加一个骰子。若达到每个六边形的最大骰子数则跳过。\\n- 如果玩家都不能移动，游戏结束，占据最多六边形的玩家获胜。\\n\\n###然后是漫长的源码……\\n\\n```cl\\n;;Defining Some Global Variables\\n;玩家数二\\n(defparameter *num-players* 2)\\n;一个六边形最多3个骰子\\n(defparameter *max-dice* 3)\\n(defparameter *board-size* 2)\\n;2x2的board\\n(defparameter *board-hexnum* (* *board-size* *board-size*))\\n;clean\\n;将list转化为array，为今后优化做准备\\n(defun board-array (lst)\\n  (make-array *board-hexnum* :initial-contents lst))\\n;dirty\\n;生成随机的玩家分布和力量\\n(defun gen-board ()\\n  (board-array (loop for n below *board-hexnum*\\n                     collect (list (random *num-players*)\\n                                   (1+ (random *max-dice*))))))\\n;clean\\n;将玩家名由数字转换成字母\\n(defun player-letter (n)\\n  (code-char (+ 97 n)))\\n;dirty\\n;通过两层循环控制输出，绘制board\\n(defun draw-board (board)\\n  (loop for y below *board-size*\\n        do (progn (fresh-line)\\n                  (loop repeat (- *board-size* y)\\n                        do (princ \\\" \\\"))\\n                  (loop for x below *board-size*\\n                        for hex = (aref board (+ x (* *board-size* y)))\\n                        do (format t \\\"~a-~a \\\" (player-letter (first hex))\\n                                   (second hex))))))\\n;;;Decoupling Dice of Doom’s Rules from the Rest of the Game\\n;;Generating a Game Tree\\n;clean\\n;产生一个game-tree，形如(player board (moves))\\n(defun game-tree (board player spare-dice first-move)\\n  (list player\\n        board\\n        (add-passing-move board\\n                          player\\n                          spare-dice\\n                          first-move\\n                          (attacking-moves board player spare-dice))))\\n;;Calculating Passing Moves\\n;clean\\n;如果是第一次移动则返回原tree的moves，如果不是则添加nil表示\\n;无法移动，并递归调用game-tree添加玩家移动树\\n(defun add-passing-move (board player spare-dice first-move moves)\\n  (if first-move\\n    moves\\n    (cons (list nil\\n                (game-tree (add-new-dice board player (1- spare-dice))\\n                           (mod (1+ player) *num-players*)\\n                           0\\n                           t))\\n          moves)))\\n;clean\\n;Calculating Attacking Moves\\n;生成攻击可行的攻击game-tree中的moves\\n(defun attacking-moves (board cur-player spare-dice)\\n  (labels ((player (pos)\\n             (car (aref board pos)))\\n           (dice (pos)\\n             (cadr (aref board pos))))\\n    (mapcan (lambda (src)\\n              (when (eq (player src) cur-player)\\n                (mapcan (lambda (dst)\\n                          (when (and (not (eq (player dst) cur-player))\\n                                     (> (dice src) (dice dst)))\\n                            (list\\n                              (list (list src dst)\\n                                    (game-tree (board-attack board cur-player src dst (dice src))\\n                                               cur-player\\n                                               (+ spare-dice (dice dst))\\n                                               nil)))))\\n                        (neighbors src))))\\n            (loop for n below *board-hexnum*\\n              collect n))))\\n;Finding the Neighbors\\n;clean\\n;返回邻近的pos列表\\n(defun neighbors (pos)\\n  (let ((up (- pos *board-size*))\\n        (down (+ pos *board-size*)))\\n    (loop for p in (append (list up down)\\n                           (unless (zerop (mod pos *board-size*))\\n                             (list (1- up) (1- pos)))\\n                           (unless (zerop (mod (1+ pos) *board-size*))\\n                             (list (1+ pos) (1+ down))))\\n          when (and (>= p 0) (< p *board-hexnum*))\\n          collect p)))\\n;Attacking\\n;clean\\n;生成attack后的board\\n(defun board-attack (board player src dst dice)\\n  (board-array (loop for pos;第一个for为位置\\n                     for hex across board;数组用across\\n                     collect (cond ((eq pos src) (list player 1))\\n                                   ((eq pos dst) (list player (1- dice)))\\n                                   (t hex)))))\\n;Reinforcements\\n;clean\\n;根据spare-dice添加骰子,返回新的board（数组）\\n(defun add-new-dice (board player spare-dice)\\n  (labels ((f (lst n)\\n             (cond ((null lst) nil)\\n                   ((zerop n) lst)\\n                   (t (let ((cur-player (caar lst))\\n                            (cur-dice (cadar lst)))\\n                        (if (and (eq cur-player player) (< cur-dice *max-dice*))\\n                          (cons (list cur-player (1+ cur-dice))\\n                                (f (cdr lst) (1- n)))\\n                          (cons (car lst) (f (cdr lst) n))))))))\\n    (board-array (f (coerce board 'list) spare-dice))))\\n;;Playing Dice of Doom Against Another Human\\n;The Main Loop\\n;dirty\\n;人人对战主函数\\n(defun play-vs-human (tree)\\n  (print-info tree)\\n  (if (caddr tree)\\n    (play-vs-human (handle-human tree))\\n    (announce-winner (cadr tree))))\\n;Giving Information About the State of the Game\\n;dirty\\n;打印当前信息，包括当前玩家和board\\n(defun print-info (tree)\\n  (fresh-line)\\n  (format t \\\"current player = ~a\\\" (player-letter (car tree)))\\n  (draw-board (cadr tree)))\\n;Handling Input from Human Players\\n;dirty\\n;处理人的行动的函数，根据人的输入返回不同move的子树\\n(defun handle-human (tree)\\n  (fresh-line)\\n  (princ \\\"choose your move:\\\")\\n  (let ((moves (caddr tree)))\\n    (loop for move in moves\\n          for n from 1\\n          do (let ((action (car move)))\\n               (fresh-line)\\n               (format t \\\"~a. \\\" n)\\n               (if action\\n                 (format t \\\"~a -> ~a\\\" (car action) (cadr action))\\n                 (princ \\\"end turn\\\"))))\\n    (fresh-line)\\n    (cadr (nth (1- (read)) moves))))\\n\\n;Determining the Winner\\n(defun winners (board)\\n  (let* ((tally (loop for hex across board\\n                      collect (car hex)))\\n         (totals (mapcar (lambda (player)\\n                           (cons player (count player tally)))\\n                         (remove-duplicates tally)))\\n         (best (apply #'max (mapcar #'cdr totals))))\\n    (mapcar #'car\\n            (remove-if (lambda (x)\\n                         (not (eq (cdr x) best)))\\n                       totals))))\\n```\\n\\n现在可以试试新游戏：\\n\\n```cl\\n(play-vs-human (game-tree (gen-board) 0 0 t))\\n```\\n\\n其中0代表玩家0,第二个0代表刚开始获得的骰子为0,t代表第一次移动。\\n\\n##写在最后\\n\\n尼玛这怎么设计出来的，看起来倒容易，设计者真值得膜拜……\\n\\n着一个函数接着一个函数真是超级强烈的函数式编程风格好不好，我又想起来C语言这种强烈的面向过程风格，难道函数式就是功能式，其实就是过程式？\\n\\n要说有什么收获，什么cddrcdar搞得更清楚了，我觉得作者用one two three什么的看起来更方便些。loop for什么for什么的across什么算是开了眼界了。其它，只让我体会到强烈的面向过程风格，作为不能完美计划所有过程的小白我还是继续看c++去比较简单…………\\n\\n[1]: http://en.wikipedia.org/wiki/Minimax\\n\\n[2]: http://www.gamedesign.jp/flash/dice/dice.html\\n\\n\",\n\t\t\"metaData\": {\n\t\t\t\"layout\": \"post\",\n\t\t\t\"title\": \"Dice of Doom\",\n\t\t\t\"excerpt\": \"A game engine written in the functional style\",\n\t\t\t\"category\": \"lisp\",\n\t\t\t\"tags\": [\n\t\t\t\t\"land-of-lisp\"\n\t\t\t],\n\t\t\t\"disqus\": true\n\t\t}\n\t};\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** static/js/149.aac08d6491fbaf937ff6.js\n **/","module.exports = {\n\t\"rawContent\": \"\\n\\n## 照例前面来些废话\\n\\n前一阵忙着看通信原理，近来各科都陆续结课，又接连有这么几科让写个什么论文，忙忙碌碌之后发现lisp就没怎么看了，以致于这一章都看快一星期了还没看完。不过回头多看几次后，因为对游戏要生成个什么样的game tree有了整体上的把握，理解起来简单多了。所以奉劝其它读者先搞清楚要生成个什么样的game tree和作者的设计方案，再来看后面的代码部分。\\n\\n昨天还激动终于看到用lisp来实现人工智能了，结果一看几行代码实现个[minmax][1]算法的问题……失望了。\\n\\n##Dice of Doom\\n\\n###游戏规则\\n\\n这是个怎么样的游戏？看看[这里][2]就知道了。我们现在就要用函数式编程风格写一个这样的游戏，当然，从简单的开始。简单到只有两个玩家，只以骰子数目多少来决定能否“占领”对方的领地。\\n\\n本想举个例子，不过画图挺麻烦的，现在没什么空。有空再补上。\\n\\n有这么一些规则：\\n\\n- 两个玩家占据着六边形阵列上的各个六边形。每个六边形都有一些立方体骰子，被两个玩家分别占有。\\n- 在一个回合内，玩家可以执行任意数目的移动，但至少移动一次。如果他不能移动那么他就输了。\\n- 移动包括攻击邻近的对方六边形。玩家发动攻击的六边形必须比要攻击的对方的六边形拥有更多骰子。将来可能我们会真的“转动”这些骰子。\\n- 攻击结束后，输者在被攻击六边形的骰子被移除，发动攻击的六边形留下一个骰子，将其它所有骰子移到占领的新地方。\\n- 当玩家完成他所有的移动，将获得他消灭的骰子总数减一的增援。增援从左上角开始给每个己方六角形增加一个骰子。若达到每个六边形的最大骰子数则跳过。\\n- 如果玩家都不能移动，游戏结束，占据最多六边形的玩家获胜。\\n\\n###然后是漫长的源码……\\n\\n```cl\\n;;Defining Some Global Variables\\n;玩家数二\\n(defparameter *num-players* 2)\\n;一个六边形最多3个骰子\\n(defparameter *max-dice* 3)\\n(defparameter *board-size* 2)\\n;2x2的board\\n(defparameter *board-hexnum* (* *board-size* *board-size*))\\n;clean\\n;将list转化为array，为今后优化做准备\\n(defun board-array (lst)\\n  (make-array *board-hexnum* :initial-contents lst))\\n;dirty\\n;生成随机的玩家分布和力量\\n(defun gen-board ()\\n  (board-array (loop for n below *board-hexnum*\\n                     collect (list (random *num-players*)\\n                                   (1+ (random *max-dice*))))))\\n;clean\\n;将玩家名由数字转换成字母\\n(defun player-letter (n)\\n  (code-char (+ 97 n)))\\n;dirty\\n;通过两层循环控制输出，绘制board\\n(defun draw-board (board)\\n  (loop for y below *board-size*\\n        do (progn (fresh-line)\\n                  (loop repeat (- *board-size* y)\\n                        do (princ \\\" \\\"))\\n                  (loop for x below *board-size*\\n                        for hex = (aref board (+ x (* *board-size* y)))\\n                        do (format t \\\"~a-~a \\\" (player-letter (first hex))\\n                                   (second hex))))))\\n;;;Decoupling Dice of Doom’s Rules from the Rest of the Game\\n;;Generating a Game Tree\\n;clean\\n;产生一个game-tree，形如(player board (moves))\\n(defun game-tree (board player spare-dice first-move)\\n  (list player\\n        board\\n        (add-passing-move board\\n                          player\\n                          spare-dice\\n                          first-move\\n                          (attacking-moves board player spare-dice))))\\n;;Calculating Passing Moves\\n;clean\\n;如果是第一次移动则返回原tree的moves，如果不是则添加nil表示\\n;无法移动，并递归调用game-tree添加玩家移动树\\n(defun add-passing-move (board player spare-dice first-move moves)\\n  (if first-move\\n    moves\\n    (cons (list nil\\n                (game-tree (add-new-dice board player (1- spare-dice))\\n                           (mod (1+ player) *num-players*)\\n                           0\\n                           t))\\n          moves)))\\n;clean\\n;Calculating Attacking Moves\\n;生成攻击可行的攻击game-tree中的moves\\n(defun attacking-moves (board cur-player spare-dice)\\n  (labels ((player (pos)\\n             (car (aref board pos)))\\n           (dice (pos)\\n             (cadr (aref board pos))))\\n    (mapcan (lambda (src)\\n              (when (eq (player src) cur-player)\\n                (mapcan (lambda (dst)\\n                          (when (and (not (eq (player dst) cur-player))\\n                                     (> (dice src) (dice dst)))\\n                            (list\\n                              (list (list src dst)\\n                                    (game-tree (board-attack board cur-player src dst (dice src))\\n                                               cur-player\\n                                               (+ spare-dice (dice dst))\\n                                               nil)))))\\n                        (neighbors src))))\\n            (loop for n below *board-hexnum*\\n              collect n))))\\n;Finding the Neighbors\\n;clean\\n;返回邻近的pos列表\\n(defun neighbors (pos)\\n  (let ((up (- pos *board-size*))\\n        (down (+ pos *board-size*)))\\n    (loop for p in (append (list up down)\\n                           (unless (zerop (mod pos *board-size*))\\n                             (list (1- up) (1- pos)))\\n                           (unless (zerop (mod (1+ pos) *board-size*))\\n                             (list (1+ pos) (1+ down))))\\n          when (and (>= p 0) (< p *board-hexnum*))\\n          collect p)))\\n;Attacking\\n;clean\\n;生成attack后的board\\n(defun board-attack (board player src dst dice)\\n  (board-array (loop for pos;第一个for为位置\\n                     for hex across board;数组用across\\n                     collect (cond ((eq pos src) (list player 1))\\n                                   ((eq pos dst) (list player (1- dice)))\\n                                   (t hex)))))\\n;Reinforcements\\n;clean\\n;根据spare-dice添加骰子,返回新的board（数组）\\n(defun add-new-dice (board player spare-dice)\\n  (labels ((f (lst n)\\n             (cond ((null lst) nil)\\n                   ((zerop n) lst)\\n                   (t (let ((cur-player (caar lst))\\n                            (cur-dice (cadar lst)))\\n                        (if (and (eq cur-player player) (< cur-dice *max-dice*))\\n                          (cons (list cur-player (1+ cur-dice))\\n                                (f (cdr lst) (1- n)))\\n                          (cons (car lst) (f (cdr lst) n))))))))\\n    (board-array (f (coerce board 'list) spare-dice))))\\n;;Playing Dice of Doom Against Another Human\\n;The Main Loop\\n;dirty\\n;人人对战主函数\\n(defun play-vs-human (tree)\\n  (print-info tree)\\n  (if (caddr tree)\\n    (play-vs-human (handle-human tree))\\n    (announce-winner (cadr tree))))\\n;Giving Information About the State of the Game\\n;dirty\\n;打印当前信息，包括当前玩家和board\\n(defun print-info (tree)\\n  (fresh-line)\\n  (format t \\\"current player = ~a\\\" (player-letter (car tree)))\\n  (draw-board (cadr tree)))\\n;Handling Input from Human Players\\n;dirty\\n;处理人的行动的函数，根据人的输入返回不同move的子树\\n(defun handle-human (tree)\\n  (fresh-line)\\n  (princ \\\"choose your move:\\\")\\n  (let ((moves (caddr tree)))\\n    (loop for move in moves\\n          for n from 1\\n          do (let ((action (car move)))\\n               (fresh-line)\\n               (format t \\\"~a. \\\" n)\\n               (if action\\n                 (format t \\\"~a -> ~a\\\" (car action) (cadr action))\\n                 (princ \\\"end turn\\\"))))\\n    (fresh-line)\\n    (cadr (nth (1- (read)) moves))))\\n\\n;Determining the Winner\\n(defun winners (board)\\n  (let* ((tally (loop for hex across board\\n                      collect (car hex)))\\n         (totals (mapcar (lambda (player)\\n                           (cons player (count player tally)))\\n                         (remove-duplicates tally)))\\n         (best (apply #'max (mapcar #'cdr totals))))\\n    (mapcar #'car\\n            (remove-if (lambda (x)\\n                         (not (eq (cdr x) best)))\\n                       totals))))\\n```\\n\\n现在可以试试新游戏：\\n\\n```cl\\n(play-vs-human (game-tree (gen-board) 0 0 t))\\n```\\n\\n其中0代表玩家0,第二个0代表刚开始获得的骰子为0,t代表第一次移动。\\n\\n##写在最后\\n\\n尼玛这怎么设计出来的，看起来倒容易，设计者真值得膜拜……\\n\\n着一个函数接着一个函数真是超级强烈的函数式编程风格好不好，我又想起来C语言这种强烈的面向过程风格，难道函数式就是功能式，其实就是过程式？\\n\\n要说有什么收获，什么cddrcdar搞得更清楚了，我觉得作者用one two three什么的看起来更方便些。loop for什么for什么的across什么算是开了眼界了。其它，只让我体会到强烈的面向过程风格，作为不能完美计划所有过程的小白我还是继续看c++去比较简单…………\\n\\n[1]: http://en.wikipedia.org/wiki/Minimax\\n\\n[2]: http://www.gamedesign.jp/flash/dice/dice.html\\n\\n\",\n\t\"metaData\": {\n\t\t\"layout\": \"post\",\n\t\t\"title\": \"Dice of Doom\",\n\t\t\"excerpt\": \"A game engine written in the functional style\",\n\t\t\"category\": \"lisp\",\n\t\t\"tags\": [\n\t\t\t\"land-of-lisp\"\n\t\t],\n\t\t\"disqus\": true\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/json-loader/0.5.4/json-loader!./loader/post-loader.js!./src/posts/2012-05-23-dice-of-doom.md\n ** module id = 260\n ** module chunks = 149\n **/"],"sourceRoot":""}