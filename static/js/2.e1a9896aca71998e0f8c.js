webpackJsonp([2,192],{451:function(e,n){e.exports={rawContent:'\n## Prelude\n\nThis article is more a note than a formal post, I write this with days of small pieces of times when exploring and learning webpack.\n\nIt covers: \n\n0. How bundles work. What a bundled js file looks like.\n1. How loaders work. What a loader looks like\n2. How plugins work. What a plugin looks like\n3. The big picture of how webpack works, that is, webpack internals.\n4. Some thoughts that coming to my mind when exploring awesome webpack.\n\nI don\'t find any detail explanation on webpack internals, so I decided to share my explorations. However, writing in English is challenge for me, but, it\'s *Fun* to learn to writing in a language you are not familiar with.\n\nAs the [webpack\'s doc](http://webpack.github.io/docs/) said, it bundles every dependencies into static assets used for the web, it\'s production, it\'s unbiased\n,it\'s flexible, it\'s extensible, it\'s open source. it looks so good......\n\nit have rich plugins to support tons of function, it has tons of loaders to load tons of resources and it can help you split big code base into chunks, it has a good hot reloaded dev server with proxy support, it support all kinds of module format in the history from commonjs to amd to umd (with the help of babel support es modules in some extent), it has multiple caching levels with high performance incremental compilation, it can help you minimize optimize your code before bundle, and, it support multi target like browser, node and workers.\n\nit looks its really really powerful,\nand really really *COMPLEX* !\n\nYou may use it every day, however, you may not understand, why, and how it works. If you are curious about how it works, its the article for you. Lets dive into it.\n\n## Bundle Javascript\n\nOne of the most commonly use case for webpack is to bundle javascript modules into one or several files for serve.\n\n### How Bundles Works\n\n#### CommonJS modules\n\nThe example from documentation\n\n```bash\n┌─(~/work/webpack-learning/1)──────────(reverland@reverland-R478-R429:pts/13)─┐\n└─(19:14:41)──> tree                                            ──(五, 7月15)─┘\n.\n├── app.js\n└── cats.js\n\n0 directories, 2 files\n```\n\n`cats.js`\n\n```javascript\nvar cats = [\'dave\', \'henry\', \'reverland\']\nmodule.exports = cats;\n```\n\n`app.js`\n\n```javascript\n┌─(~/work/webpack-learning/1)──────────(reverland@reverland-R478-R429:pts/13)─┐\n└─(19:18:59)──> cat app.js                                      ──(五, 7月15)─┘\nvar cats = require(\'./cats.js\');\nconsole.log(cats)\n```\n\ntake the app.js as entry point\n\n```bash\n┌─(~/work/webpack-learning/1)──────────(reverland@reverland-R478-R429:pts/13)─┐\n└─(19:18:50)──> webpack app.js bundle.js                        ──(五, 7月15)─┘\nHash: b32c0c5126f5df66072b\nVersion: webpack 1.13.1\nTime: 94ms\n    Asset     Size  Chunks             Chunk Names\nbundle.js  1.58 kB       0  [emitted]  main\n   [0] ./app.js 51 bytes {0} [built]\n   [1] ./cats.js 65 bytes {0} [built]\n```\n\nLets see what is inside bundle.js\n\n```javascript\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cats = __webpack_require__(1);\n\tconsole.log(cats)\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tvar cats = [\'dave\', \'henry\', \'reverland\']\n\tmodule.exports = cats;\n\n\n/***/ }\n/******/ ]);\n```\n\nWow, clear output with comments, thanks to sokra.\n\nthe bundle have a IIFE which takes all the modules. Every module is a function, which takes `module` `exports` and `__webpack_require__` if needed as arguments. these arguments are injected into modules to support resolve dependencies and export something to module.exports.\n\na more word, modules are identified with their position in modules arrays as module Id. `require/__webpack_requrie__` just receive one parameter, that is the module id.\n\nWhenever the `__webpack_require__` works on a module ID , it first checks if the same Id\'s module has loaded in the cache, if not, it just add a new module and inject `module` and `module.exports` into that module function and runs it. with module function\'s enviroment has `this` point to `module.exports`. Finally, \'module.exports\' is returned with `__webpack_require__`, it can be used for who require it: )\n\nat the end of IIFE, `__webpack_require__(0)` is returned. its the `entry.js`, when evaluate entry.js, `__webpack_require__(1)` runs, so the modules\' dependencies have been handled.\n\nthats *ALL* about how webpack\'s bundler work when we glimpse of the bundler generated by webpack.\n\n#### AMD\n\nNext, lets take a look at how amd works\n\nthis example takes 3 files\n\n```bash\n┌─(~/work/webpack-learning/2)─────────(reverland@reverland-R478-R429:pts/13)─┐\n└─(20:20:00)──> tree                                           ──(五, 7月15)─┘\n.\n├── app.js\n└── cats.js\n\n0 directories, 2 files\n```\n\n`cats.js`, which is a AMD module\n\n```javascript\ndefine(\'cats\', [], function () {\n  var cats = [\'dave\', \'henry\', \'reverland\'];\n  return cats\n})\n```\n\n`dogs.js`\n\n```javascript\ndefine(\'dogs\', [\'./cats.js\'], function (cats) {\n  console.log(cats)\n  dogs = cats\n  return dogs\n})\n```\n\n`app.js`, a plain CommonJS entry point, you can just require a amd file\n\n```javascript\nvar cats = require(\'./dogs.js\');\nconsole.log(cats)\n```\n\nNow, the bundle becomes(the same part is leaved out)\n\n```javascript\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cats = __webpack_require__(1);\n\tconsole.log(cats)\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function (cats) {\n\t  console.log(cats)\n\t  dogs = cats\n\t  return dogs\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t  var cats = [\'dave\', \'henry\', \'reverland\'];\n\t  return cats\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n/***/ }\n/******/ ])\n```\n\nthe AMD modules was rewriten by webpack into a CommonJS one.\nWhenever `__webpack_require__` require a AMD module, it just runs the module function, and the IIFE inside the module function execute and export if there are any thing to export.\n\n(note: `!()` takes all inside the brackets as expression and execute it) \n\nreally neat!\n\n#### UMD\n\nLet\'s rewrite `dogs.js` in UMD\n\n```javascript\n(function(root, factory){\n  if (typeof define === "function" && define.amd) {\n\tdefine([\'./cats.js\'], factory);\n  } else if (typeof exports === \'object\') {\n\tfactory(require(\'./cats.js\'));\n  } else {\n\troot.dogs = factory(root.cats);\n  }\n}(this, function (cats) {\n  console.log(cats)\n  dogs = cats\n  return dogs\n}))\n```\n\nthe bundle now becomes\n\n```javascript\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cats = __webpack_require__(1);\n\tconsole.log(cats)\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory){\n\t  if (true) {\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === \'object\') {\n\t\tfactory(require(\'./cats.js\'));\n\t  } else {\n\t\troot.dogs = factory(root.cats);\n\t  }\n\t}(this, function (cats) {\n\t  console.log(cats)\n\t  dogs = cats\n\t  return dogs\n\t}))\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t  var cats = [\'dave\', \'henry\', \'reverland\'];\n\t  return cats\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n/***/ }\n/******/ ]);%    \n```\n\nso, the if statement to find out whether the module is in AMD is rewriten to `true`, all UMD modules just becomes the AMD ones, and finally, CommonJS ones.\n\nInteresting, but, how webpack achieve all of this?\n\n![Magic](http://i.imgur.com/YsbKHg1.gif)\n\nIt parse your codes into AST and static analyse them and operate on it, however, I dont\' understand how webpack do that in detail.\n\nso, magic.\n\n### How Code Split Works\n\nWebpack, can be used to split code into an on demand loaded chunk.It\'s quite an interesting feature. You should define split points for this to work.\n\nOne way to define a split point is to use `require.ensure`, a webpack specific API.\n`require.ensure` will ensure spliting modules in its first arguments and modules it reference in a new chunk(not always, in fact), but won\'t evaluate like `require` do, just scheduled to evaluate later.\n\n#### Code Split in Action\n\nLet\'s take a example(target the web)\n\nThe `app.js` is the entry point, nothing special\n\n```javascript\nvar cats = require(\'./dogs.js\');\nconsole.log(cats)\n```\n\nHowever, `dogs.js` defines the split point. We let webpack to load the bundle three seconds later, and evaluate one second later after loaded.\n\n```javascript\nvar dogs = [\'Alice\', \'Bob\', \'Reverland\']\nmodule.exports = dogs\nsetTimeout(function(){\n  require.ensure([\'./cats.js\'], function(require) {\n\tconsole.log(\'./cats.js loaded, but not evaluate\')\n\tsetTimeout(function () {\n\t  var cats = require(\'./cats.js\')\n\t  console.log(\'./cats.js evaluate\', cats)\n\t}, 1000)\n  })\n}, 3000)\n```\n\n`cats.js` remains the same, nothing special, an AMD module\n\n```javascript\ndefine(\'cats\', [], function () {\n  var cats = [\'dave\', \'henry\', \'reverland\'];\n  return cats\n})\n```\n\nNow, bundle it\n\n```bash\n┌─(~/work/webpack-learning/4)────────────────────────────────────────────────────(reverland@reverland-R478-R429:pts/13)─┐\n└─(11:03:29)──> webpack app.js bundle.js --display-error-details                                          ──(六, 7月16)─┘\nHash: c3653e88387af4a1f2f5\nVersion: webpack 1.13.1\nTime: 139ms\n      Asset       Size  Chunks             Chunk Names\n  bundle.js    4.04 kB       0  [emitted]  main\n1.bundle.js  454 bytes       1  [emitted]  \n   [0] ./app.js 51 bytes {0} [built]\n   [1] ./dogs.js 330 bytes {0} [built]\n   [2] ./cats.js 95 bytes {1} [built]\n```\n\ninteresting, it\'s bundled into two chunks. Lets prepare some file to see it really works in browsers.\n\nprepare an `index.html`\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n  </head>\n  <body>\n    <h1>Code Split</h1>\n    <script src="bundle.js"></script>\n  </body>\n</html>\n```\n\nYou can just include the `bundle.js`, which will responsible for loading `1.bundle.js`.\n\nserve it\n\n```bash\n┌─(~/work/webpack-learning/4)────────────────────────────────────────────────────(reverland@reverland-R478-R429:pts/13)─┐\n└─(11:09:21)──> httpserver                                                                                ──(六, 7月16)─┘\nlo: 127.0.0.1\nwlan0: 192.168.1.9\nserver started: http://0.0.0.0:8080\n```\n\nNow the magic, code works as you expected and chunk loaded as you expected. Check the time to confirm it.\n\n![codes works as you expected](https://img.vim-cn.com/35/f7608b28957114376e9666a13d457b22b1aa61.png)\n\n![chunk loaded as you expected](https://img.vim-cn.com/aa/a530afd4472c0742d35972d1abe939b12f97f4.png)\n\nHowever, how it works? Let\'s dive into the `bundle.js` and `1.bundle.js`\n\n#### The Runtime\n\n`bundle.js` contains the runtime to:\n\n1. resolve and evaluate modules\n2. register JsonP function\n3. function to load new chunks which wrapped in a Jsonp callback\n\n```javascript\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window["webpackJsonp"];\n/******/ \twindow["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add "moreModules" to the modules object,\n/******/ \t\t// then flag all "chunkIds" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n\n/******/ \t};\n\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// "0" means "already loaded"\n/******/ \t// Array means "loading", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t0:0\n/******/ \t};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// "0" is the signal for "already loaded"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n\n/******/ \t\t// an array means "currently loading".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName(\'head\')[0];\n/******/ \t\t\tvar script = document.createElement(\'script\');\n/******/ \t\t\tscript.type = \'text/javascript\';\n/******/ \t\t\tscript.charset = \'utf-8\';\n/******/ \t\t\tscript.async = true;\n\n/******/ \t\t\tscript.src = __webpack_require__.p + "" + chunkId + ".bundle.js";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = "";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar cats = __webpack_require__(1);\n\tconsole.log(cats)\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dogs = [\'Alice\', \'Bob\', \'Reverland\']\n\tmodule.exports = dogs\n\tsetTimeout(function(){\n\t  __webpack_require__.e/* nsure */(1, function(require) {\n\t\tconsole.log(\'./cats.js loaded, but not evaluate\')\n\t\tsetTimeout(function () {\n\t\t  var cats = __webpack_require__(2)\n\t\t  console.log(\'./cats.js evaluate\', cats)\n\t\t}, 1000)\n\t  })\n\t}, 3000)\n\n\n/***/ }\n/******/ ]);% \n```\n\nthe entry bundle register the JsonP function. This function accept chunk ID and `moreModules` that is bundled into this chunk. it will prepare all callbacks for a specific chunk added, flag chunk as loaded, add new loaded modules into modules list, and finally, evaluate every callbacks.\n\nYou may wonder what `parentJsonpFunction` for, it may, for example there are multi entry points, the same chunk or modules states should be flaged and callback for same chunk should be evaluated for every entry point.\n\nAs you can see, `require.ensure` is replaced with `__webpack_require__.e` in module functions and dependent modules will be replaced with a chunk Id. \n\nWhen a module function is resolved, `__webpack_require__.e` will:\n\n1. When chunk with specific ID is not loaded, create a script element to load it.\n2. When chunk with specific ID is loaded, evaluate the callback. (After loaded, modules in this chunk will be in module list now, so just require is ok)\n3. When chunk with specific ID is loading, push this callback into `installedChunks`, schedule it for evaluating.\n\nWhenever a new chunk is loaded, it is evaluate by the browser. The chunk looks like `1.bundle.js` below.\n\n```javascript\nwebpackJsonp([1/*chunk ID*/],{\n\n/***/ 2: // Module ID, below module function\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t  var cats = [\'dave\', \'henry\', \'reverland\'];\n\t  return cats\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n/***/ }\n});\n```\n\nthat\'s how the magic happened under the hood.\n\nWebpack is clever, so clever that it knows *What* you\'d like to split into chunks, *How* to merge chunks and remove unuseful chunks and so on. Really cool.\n\nLike a magic.\n\n![Magic](http://i.imgur.com/YsbKHg1.gif)\n\n## Loaders\n\n> Loaders are transformations that are applied on a resource file of your app. They are functions (running in node.js) that take the source of a resource file as the parameter and return the new source.\n\nOne of the most exciting feature in webpack is that it can load nearly everything into javascript. However, Webpack can do more than loading assets.\n\n> Loaders allow you to preprocess files as you require() or “load” them. Loaders are kind of like “tasks” are in other build tools, and provide a powerful way to handle frontend build steps. Loaders can transform files from a different language like, CoffeeScript to JavaScript, or inline images as data URLs. Loaders even allow you to do things like require() css files right in your JavaScript!\n\nYou can also integrate lint, test and documentation generation process in your workflow with webpack. That sounds *COOL*~\n\nBut, how this works in webpack? webpack\'s loaders are so powerful, however, the most common usecase for loader is changing the source into a javascript module function.\n\nLet\'s explore some interesting webpack loaders.\n\n### Raw\n\n> Loads raw content of a file (as utf-8).\n\nthe `dogs.js` file\n\n```javascript\nconsole.log(\'half dog\')\n```\n\n```javascript\n// raw-loader\nvar dogs = require(\'raw!./dogs.js\')\n```\n\nWhen checking `bundle.js`, except the webpack runtime we have seen before, you can see it export `dogs.js`\'s raw content in the generated module function.\n\n```javascript\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = "console.log(\'half dog\')"\n\n/***/ },\n```\n\nHow raw loader achieve this? lets look at what `raw-loader` looks like:\n\n```javascript\nmodule.exports = function(content) {\n\tthis.cacheable && this.cacheable();\n\tthis.value = content;  // I can\'t figure out why set loader context with previous content\n\treturn "module.exports = " + JSON.stringify(content);\n}\n```\n\nA plain javascript function who accept raw content of a file:\n\n1. mark the loader cacheable\n2. set the value in loader context. I dont know what it for, despite of the confusing api docs.\n3. return the module body, which exports such raw content.\n\n### Json\n\n> Loads file as JSON\n\n```javascript\n// json loader\nvar cats = require(\'json!./cats.json\');\n```\n`cats.json`\n\n```json\n["dave","henry","reverland"]\n```\n\n`bundle.js` looks like below:\n\n```javascript\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = [\n\t\t"dave",\n\t\t"henry",\n\t\t"reverland"\n\t];\n\n/***/ },\n```\n\n`json-loader`:\n\n```javascript\nmodule.exports = function(source) {\n\tthis.cacheable && this.cacheable();\n\tvar value = typeof source === "string" ? JSON.parse(source) : source;\n\tthis.value = [value];\n\treturn "module.exports = " + JSON.stringify(value, undefined, "\\t") + ";";\n}\n```\n\nObvious, however, I still don\'t know what `this.value` for.\n\n### Val\n\n> Executes code as module and consider exports as JavaScript code\n\n`dogs.js`, a module which exports js code.\n\n```javascript\nvar code = \'var dogs = \\\'a\\\'\'\nmodule.exports = code\n```\n\n`app.js`, the entry point.\n\n```javascript\n// val-loader\nvar dogs = require(\'val!./dogs.js\')\n```\n\n`bundle.js`\n\n```javascript\n/* 3 */\n/***/ function(module, exports) {\n\n\tvar dogs = \'a\'\n\n/***/ },\n```\n\n`val-loader`\n\n```javascript\nvar loaderUtils = require("loader-utils");\nmodule.exports = function(content) {\n\tvar query = loaderUtils.parseQuery(this.query);\n\tif(query.cacheable && this.cacheable)\n\t\tthis.cacheable();\n\tif(this.inputValue) {\n\t\treturn null, this.inputValue;\n\t} else {\n\t\treturn this.exec(content, this.resource);\n\t}\n}\n```\n\nneat(but what does `return null, this.inputValue` mean?)\n\nI still can not figure out how cacheable works\n\n### File\n\n`cats.json` is same as above.\n\n`app.js`\n\n```javascript\n// file-loader\nvar cats = require(\'file?name=new_cats.json!./cats.json\')\n```\n\nBundle it, a new file emitted by the loader.\n\n```bash\n┌─(~/work/webpack-learning/5)───────────(reverland@reverland-R478-R429:pts/1)─┐\n└─(00:19:24)──> webpack app.js bundle.js --module-bind \'png=file-loader\'\nHash: cc125205509143b0e940\nVersion: webpack 1.13.1\nTime: 905ms\n                                Asset      Size  Chunks             Chunk Names\n                        new_cats.json  29 bytes          [emitted]  \n...\n```\n\n`bundle.js`\n\n```javascript\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + "new_cats.json";\n\n/***/ },\n```\n\n`file-loader`\n\n```javascript\nvar loaderUtils = require("loader-utils");\n\nmodule.exports = function(content) {\n\tthis.cacheable && this.cacheable();\n\tif(!this.emitFile) throw new Error("emitFile is required from module system");\n\n\tvar query = loaderUtils.parseQuery(this.query);\n\tvar configKey = query.config || "fileLoader";\n\tvar options = this.options[configKey] || {};\n\n\tvar config = {\n\t\tpublicPath: false,\n\t\tname: "[hash].[ext]"\n\t};\n\n\t// options takes precedence over config\n\tObject.keys(options).forEach(function(attr) {\n\t\tconfig[attr] = options[attr];\n\t});\n\n\t// query takes precedence over config and options\n\tObject.keys(query).forEach(function(attr) {\n\t\tconfig[attr] = query[attr];\n\t});\n\n\tvar url = loaderUtils.interpolateName(this, config.name, {\n\t\tcontext: config.context || this.options.context,\n\t\tcontent: content,\n\t\tregExp: config.regExp\n\t});\n\n\tvar publicPath = "__webpack_public_path__ + " + JSON.stringify(url);\n\n\tif (config.publicPath) {\n\t\t// support functions as publicPath to generate them dynamically\n\t\tpublicPath = JSON.stringify(\n\t\t\t\ttypeof config.publicPath === "function" \n\t\t\t\t ? config.publicPath(url) \n\t\t\t\t : config.publicPath + url\n\t\t);\n\t}\n\n\tif (query.emitFile === undefined || query.emitFile) {\n\t\tthis.emitFile(url, content);\n\t}\n\n\treturn "module.exports = " + publicPath + ";";\n}\nmodule.exports.raw = true;\n```\n\nAccording to the option it parsed, it emit the file and export the path.\n\nIt\'s a raw loader, for file content need to be Buffer instead of String.\n\nBy the way, it talked about `publicPath`, that\'s where you\'d like your assets being served.\n\n### Url\n\n> The url loader works like the file loader, but can return a Data Url if the file is smaller than a limit.\n\n`cats.json` is the same as above.\n\n`app.js`\n\n```javascript\n// url-loader\nvar cats = require(\'url!./cats.json\')\nvar cats = require(\'url?limit=1!./cats.json\')\n```\n\n`bundle.js`\n\n```\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = "data:application/json;base64,WyJkYXZlIiwiaGVucnkiLCJyZXZlcmxhbmQiXQo="\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + "480cea2cf47df1df86c2f9540b86bc8f.json";\n\n/***/ },\n```\n\n`url-loader`\n\n```javascript\nvar loaderUtils = require("loader-utils");\nvar mime = require("mime");\nmodule.exports = function(content) {\n\tthis.cacheable && this.cacheable();\n\tvar query = loaderUtils.parseQuery(this.query);\n\tvar limit = (this.options && this.options.url && this.options.url.dataUrlLimit) || 0;\n\tif(query.limit) {\n\t\tlimit = parseInt(query.limit, 10);\n\t}\n\tvar mimetype = query.mimetype || query.minetype || mime.lookup(this.resourcePath);\n\tif(limit <= 0 || content.length < limit) {\n\t\treturn "module.exports = " + JSON.stringify("data:" + (mimetype ? mimetype + ";" : "") + "base64," + content.toString("base64"));\n\t} else {\n\t\tvar fileLoader = require("file-loader");\n\t\treturn fileLoader.call(this, content);\n\t}\n}\nmodule.exports.raw = true;\n```\n\nYeah, \n\n- if limit query is not present anywhere, it is zero, then export the files dataURL. \n- or it will decide whether export with limit. If file size is below limit, export dataURL, else export path like `file-loader`.\n\n### Css\n\n> Loads css file with resolved imports and returns css code\n\n`css-loader` is complex, I won\'t show the source code of the loader, but we can check what it generated to have a feeling of whats happening.\n\n`app.css`\n\n```css\n@import \'./b.css\';\nbody {\n  color: red;\n  background-image: url(\'./background.png\');\n}\n\nh1 {\n  color: gold;\n  text-shadow: 0 0 3px black;\n}\n```\n\n`b.css`\n\n```css\nh1 {\n  font-size: 3em;\n}\n```\n\n`app.js`\n\n```javascript\n// css-loader\nvar css = require(\'css!./app.css\')\n```\n\n`bundle.js`\n\n```javascript\n//...\n\t// css-loader\n\tvar css = __webpack_require__(7)\n//...\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(8)();\n\t// imports\n\texports.i(__webpack_require__(9), "");\n\n\t// module\n\texports.push([module.id, "body {\\n  color: red;\\n  background-image: url(" + __webpack_require__(10) + ");\\n}\\n\\nh1 {\\n  color: gold;\\n  text-shadow: 0 0 3px black;\\n}\\n", ""]);\n\n\t// exports\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\t// css base code, injected by the css-loader\n\tmodule.exports = function() {\n\t\tvar list = [];\n\n\t\t// return the list of modules as css string\n\t\tlist.toString = function toString() {\n\t\t\tvar result = [];\n\t\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\t\tvar item = this[i];\n\t\t\t\tif(item[2]) {\n\t\t\t\t\tresult.push("@media " + item[2] + "{" + item[1] + "}");\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(item[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.join("");\n\t\t};\n\n\t\t// import a list of modules into the list\n\t\tlist.i = function(modules, mediaQuery) {\n\t\t\tif(typeof modules === "string")\n\t\t\t\tmodules = [[null, modules, ""]];\n\t\t\tvar alreadyImportedModules = {};\n\t\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\t\tvar id = this[i][0];\n\t\t\t\tif(typeof id === "number")\n\t\t\t\t\talreadyImportedModules[id] = true;\n\t\t\t}\n\t\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\t\tvar item = modules[i];\n\t\t\t\t// skip already imported module\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\n\t\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\n\t\t\t\t\t}\n\t\t\t\t\tlist.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn list;\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(8)();\n\t// imports\n\n\n\t// module\n\texports.push([module.id, "h1 {\\n  font-size: 3em;\\n}\\n", ""]);\n\n\t// exports\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + "8fd2362368edec47b25aeb7218d3f5ba.png";\n\n/***/ },\n```\n\nAs we can see, `css-loader` should get all dependencies working well:\n\n1. generate modules for  `@import` css.\n2. generate modules for `url()` with url-loader/file-loader.\n3. correctly handle `mediaquery`\n\nThe `bundle.js` shows that it generate a runtime module which return a factory, every css module use the factory to construct a list and push its dependencies into the list. finally, export the list full of its module dependencies.\n\nIn this way, css loader handle all of the css modules correctly and export their dependencies in javascript.\n\nCool~\n\nBut `css-loader` is more than this, you may check their docs and source codes your self to learn more.\n\nHow to insert the generated css code into DOM to acturelly work?\n\nyou need a `style-loader` to do it.\n\n### Style\n\n> Add exports of a module as style to DOM\n\n`app.css` is as above\n\n`app.js`\n\n```javascript\n// style-loader\nrequire(\'style!raw!./app.css\')\n```\n\n`bundle.js`\n\n```javascript\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\n\t// load the styles\n\tvar content = __webpack_require__(12);\n\tif(typeof content === \'string\') content = [[module.id, content, \'\']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(13)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n  // ...\n\t}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n  // css content to insert\n\tmodule.exports = "@import \'./b.css\';\\nbody {\\n  color: red;\\n  background-image: url(\'./background.png\');\\n}\\n\\nh1 {\\n  color: gold;\\n  text-shadow: 0 0 3px black;\\n}\\n"\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n      // module to manipulate dom\n      // ...\n/***/ }\n/******/ ]);\n```\n\nit looks obviously how it works. but lets check the source code of `style-loader`\n\n```javascript\nvar loaderUtils = require("loader-utils"),\n\tpath = require("path");\nmodule.exports = function() {};\nmodule.exports.pitch = function(remainingRequest) {\n\tif(this.cacheable) this.cacheable();\n\tvar query = loaderUtils.parseQuery(this.query);\n\treturn [\n\t\t"// style-loader: Adds some css to the DOM by adding a <style> tag",\n\t\t"",\n\t\t"// load the styles",\n\t\t"var content = require(" + loaderUtils.stringifyRequest(this, "!!" + remainingRequest) + ");",\n\t\t"if(typeof content === \'string\') content = [[module.id, content, \'\']];",\n\t\t"// add the styles to the DOM",\n\t\t"var update = require(" + loaderUtils.stringifyRequest(this, "!" + path.join(__dirname, "addStyles.js")) + ")(content, " + JSON.stringify(query) + ");",\n\t\t"if(content.locals) module.exports = content.locals;",\n\t\t"// Hot Module Replacement",\n\t\t// ...\n\t\t"}"\n\t].join("\\n");\n};\n```\n\nIts a pitch loader. What does it mean?\n\n> The pitch method on the loaders is called from left to right before the loaders are called. If a loader delivers a result in the pitch method the process turns around and skips the remaining loaders, continuing with the calls to the more left loaders.\n\nsokra said...\n\n```\nIt\'s like the two phases of event bubbling...\n\na!b!c!resource\n\n    pitch a\n        pitch b\n            pitch c\n                read file resource (adds resource to dependencies)\n            run c\n        run b\n    run a\n\nWhen a loader return something in the pitch phase the process continues with the normal phase of the next loader... Example:\n\n    pitch a\n        pitch b (returns something)\n    run a\n```\n\nYou can do something before the resource being really read and evaluated. In fact,\n `style-loader` interupt the load process and restart the load process in its loader function, after loading the css code, it manipulate the dom(insert. check, replace, etc) to make the style acturally work.\n \n### Imports\n >Imports stuff to the module\n \n this transform `app.js`\n \n ```javascript\n // import-loader\nrequire(\'imports?this=>new_this,cats=./cats.js!./dogs.js\')\n ```\n \n and `cats.js`\n \n ```javascript\nvar cats = [\'meow\', \'nyaa\', \'miao\']\nmodule.exports = cats\n ```\n \n and `dogs.js`\n \n ```javascript\n var code = \'var dogs = \\\'a\\\'\'\nmodule.exports = code\n ```\n \n into `bundle.js`\n \n ```javascript\n /* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*** IMPORTS FROM imports-loader ***/\n\t(function() {\n\tvar cats = __webpack_require__(15);\n\n\tvar code = \'var dogs = \\\'a\\\'\'\n\tmodule.exports = code\n\n\t}.call(new_this));\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\tvar cats = [\'meow\', \'nyaa\', \'miao\']\n\tmodule.exports = cats\n\n/***/ }\n/******/ ]);\n```\n\n`imports-loader`\n\n```javascript\nvar loaderUtils = require("loader-utils");\nvar SourceNode = require("source-map").SourceNode;\nvar SourceMapConsumer = require("source-map").SourceMapConsumer;\nvar HEADER = "/*** IMPORTS FROM imports-loader ***/\\n";\nmodule.exports = function(content, sourceMap) {\n\tif(this.cacheable) this.cacheable();\n\tvar query = loaderUtils.parseQuery(this.query);\n\tvar imports = [];\n\tvar postfixes = [];\n\tObject.keys(query).forEach(function(name) {\n\t\tvar value;\n\t\tif(typeof query[name] == "string" && query[name].substr(0, 1) == ">") {\n\t\t\tvalue = query[name].substr(1);\n\t\t} else {\n\t\t\tvar mod = name;\n\t\t\tif(typeof query[name] === "string") {\n\t\t\t\tmod = query[name];\n\t\t\t}\n\t\t\tvalue = "require(" + JSON.stringify(mod) + ")";\n\t\t}\n\t\tif(name === "this") {\n\t\t\timports.push("(function() {");\n\t\t\tpostfixes.unshift("}.call(" + value + "));");\n\t\t} else {\n\t\t\timports.push("var " + name + " = " + value + ";");\n\t\t}\n\t});\n\tvar prefix = HEADER + imports.join("\\n") + "\\n\\n";\n\tvar postfix = "\\n" + postfixes.join("\\n");\n\tif(sourceMap) {\n    // generate source map\n    // ...\n\t}\n\treturn prefix + content + postfix;\n}\n```\n\nSo, with `imports-loader`, you can \n\n1. Pass query \'name=value\' to add `var name = require(value)` before source content\n2. Pass query \'name=>value\' to add `var name = value` before source content\n3. Pass query \'this=>value\' to wrap source content in a function and bind `this` to this value.\n\nQuite cool~\n\n### Exports\n \n > Exports stuff from the module \n \n`dogs.js` as shown above.\n\n`app.js`\n\n```javascript\n// exports-loader\nrequire(\'exports?kitten=cats,dogs!./dogs.js\')\n```\n\n`bundle.js`\n\n```javascript\n/* 16 */\n/***/ function(module, exports) {\n\n\tvar code = \'var dogs = \\\'a\\\'\'\n\tmodule.exports = code\n\n\n\t/*** EXPORTS FROM exports-loader ***/\n\texports["kitten"] = (cats);\n\texports["dogs"] = (dogs);\n\n/***/ }\n/******/ ]);\n```\n\n`exports-loader`\n\n```javascript\nvar loaderUtils = require("loader-utils");\nvar SourceNode = require("source-map").SourceNode;\nvar SourceMapConsumer = require("source-map").SourceMapConsumer;\nvar FOOTER = "/*** EXPORTS FROM exports-loader ***/\\n";\nmodule.exports = function(content, sourceMap) {\n\tif(this.cacheable) this.cacheable();\n\tvar query = loaderUtils.parseQuery(this.query);\n\tvar exports = [];\n\tvar keys = Object.keys(query);\n\tif(keys.length == 1 && typeof query[keys[0]] == "boolean") {\n\t\texports.push("module.exports = " + keys[0] + ";");\n\t} else {\n\t\tkeys.forEach(function(name) {\n\t\t\tvar mod = name;\n\t\t\tif(typeof query[name] == "string") {\n\t\t\t\tmod = query[name];\n\t\t\t}\n\t\t\texports.push("exports[" + JSON.stringify(name) + "] = (" + mod + ");");\n\t\t});\n\t}\n\tif(sourceMap) {\n    // emit source map\n    // ...\n\t}\n\treturn content + "\\n\\n" + FOOTER + exports.join("\\n");\n}\n```\n\nSo, clearly, with `exports-loader` you can:\n\n1. Pass `name` query to append `exports[\'name\'] = name` to source content\n2. Pass `name=value` query to append `exports[\'value\'] = name` to source content\n\n### Expose\n \n > Exports stuff from the module\n \n`qpp.js`\n \n```javascript\n// exports-loader\nrequire(\'expose?dogs.name.value!./dogs.js\')\n```\n\n`bundle.js`\n\n```javascript\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {if(!global["dogs"]) global["dogs"] = {};\n\tif(!global["dogs"]["name"]) global["dogs"]["name"] = {};\n\tmodule.exports = global["dogs"]["name"]["value"] = __webpack_require__(18);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tvar code = \'var dogs = \\\'a\\\'\'\n\tmodule.exports = code\n\n\n/***/ }\n/******/ ]);\n```\n\n`expose-loader`\n\n```javascript\nfunction accesorString(value) {\n\tvar childProperties = value.split(".");\n\tvar length = childProperties.length;\n\tvar propertyString = "global";\n\tvar result = "";\n\n\tfor(var i = 0; i < length; i++) {\n\t\tif(i > 0)\n\t\t\tresult += "if(!" + propertyString + ") " + propertyString + " = {};\\n";\n\t\tpropertyString += "[" + JSON.stringify(childProperties[i]) + "]";\n\t}\n\n\tresult += "module.exports = " + propertyString;\n\treturn result;\n}\n\nmodule.exports = function() {};\nmodule.exports.pitch = function(remainingRequest) {\n\tthis.cacheable && this.cacheable();\n\tif(!this.query) throw new Error("query parameter is missing");\n\treturn accesorString(this.query.substr(1)) + " = " +\n\t\t"require(" + JSON.stringify("-!" + remainingRequest) + ");";\n};\n```\n\nYes, if you pass `expose-loader` with query `a.b.c`, it will expose the module\'s exports to `global.a.b.c`.\n\nBy using a pitch loader, it can interupt the process if no query.\n\n### Script\n\n> Executes a JavaScript file once in global context (like in script tag), requires are not parsed.\n\n`app.js`\n\n```javascript\n\n```\n \n`bundle.js`\n\n```javascript\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(20)(__webpack_require__(21))\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t/*\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\n\t\tAuthor Tobias Koppers @sokra\n\t*/\n\tmodule.exports = function(src) {\n\t\tif (typeof execScript !== "undefined")\n\t\t\texecScript(src);\n\t\telse\n\t\t\teval.call(null, src);\n\t}\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = "var code = \'var dogs = \\\\\'a\\\\\'\'\\nmodule.exports = code\\n"\n\n/***/ }\n/******/ ]);\n```\n\nIn fact, it just `eval()` the source content in global context.\n\n`script-loader`\n\n```javsascript\nvar path = require("path");\n\nvar addScript = function(src) {\n  if (typeof execScript !== "undefined")\n\t\texecScript(src);\n\telse\n\t\teval.call(null, src);\n}\n\nmodule.exports = function() {};\nmodule.exports.pitch = function(remainingRequest) {\n\tthis.cacheable && this.cacheable();\n\treturn "require(" + JSON.stringify("!!" + path.join(__dirname, "addScript.js")) + ")"+\n\t\t\t"(require(" +\n\t\t\tJSON.stringify("!!" + require.resolve("raw-loader") + "!" + remainingRequest) + ")" +\n\t\t\t\t(this.debug ?\n\t\t\t\t\t"+" +\n\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t"\\n\\n// SCRIPT-LOADER FOOTER\\n//# sourceURL=script:///" +\n\t\t\t\t\t\t\t\tencodeURI(remainingRequest.replace(/^!/, "")).replace(/%5C|%2F/g, "/").replace(/\\?/, "%3F").replace(/^\\//, "")\n\t\t\t\t\t\t) :\n\t\t\t\t\t"") +\n\t\t\t")";\n};\n```\n\nAwesome!\n\n### Still A Magic\n\nIn fact, there are more things a loader can do. And there are different loaders which can access loader context api to achieve more. \n\nHow all of these magic works?\n\nI dont know now, however.\n\nso, \n\n![Magic](http://i.imgur.com/YsbKHg1.gif)\n\nBut I\'ll try to explore it in the next chapter.\n\n## Webpack Internals\n\n> ...Using staged build callbacks, developers can introduce their own behaviors into the Webpack build process. ...you\'ll need to understand some of the Webpack low-level internals to hook into them. Be prepared to read some source code!\n\nIt\'s great that loaders can load nearly everything and map behaviors during loading. But with plugins, you can introduce your behaviours into all build process in Webpack.\n\nIn fact, Webpack itself is composite with some internal plugins, which makes it really versatile as well as composable.\n\n### Big Picture\n\nBefore we dive into plugins, we should have a idea of how webpack work in a big picture.\n\nFor example, when you start webpack to package you modules in this way.\n\n```bash\n┌─(~/work/webpack-learning/6)──────────(reverland@reverland-R478-R429:pts/14)─┐\n└─(20:36:09)──> webpack app.js bundle.js \n```\n\nWebpack will simply do the following things:\n\n1. require a local installed webpack if possible.\n2. parse options to give webpack\n3. require real webpack library function which create a compiler represent the fully configured webpack enviroment. \n4. run the compiler.\n5. the compiler start a compilation which represent a single compilation process\n6. compilation load modules and build it into bundled js file, and resolve and build its dependencies\n7. bundled file and other assets is emitted.\n\nHow all of the process be assembled? The key is [tapable](https://github.com/webpack/tapable/blob/master/lib/Tapable.js).\n\n### Tapable\n\n> Tapable is a class for plugin binding and applying.\n\nIn my eyes, tapable is just a "EventEmitter" in essence. Every thing that participate in the bundle process is extended with tapable. So they can register functions onto different events, they can fire diferent events at diferent stages. In this way, webpack works.\n\ntwo methods are used for plugin binding: `apply` and `plugin`\n\nThe interface is simple, when calling `apply` method on plugins you\'d like to registered, different functions you like to execute with diferent event will be registered onto tapable\'s `_plugin` property.\n\n`plugin` is the interface tapable expose for plugins to actually register callbacks.\n\nLots of `applyPlugins***` is used to fire callbacks with arguments registerd in for different events(callbacks registerd in `_plugin` property). \n\nTapable in this way can inject any logic function into different building stage.\n\n### A Glimpse of Plugin\n\nHere is the helloworld plugin modified from [how to write a plugin](https://github.com/webpack/docs/wiki/How-to-write-a-plugin#basic-plugin-architecture), which is a plugin constructor:\n\n```javascript\nfunction HelloWorldPlugin(options) {\n  // Setup the plugin instance with options...\n}\n\nHelloWorldPlugin.prototype.apply = function(compiler) {\n  compiler.plugin(\'compilation\', function(compilation) {\n    compilation.plugin("optimize", function() {\n      console.log("Assets are being optimized.");\n    });\n  });\n  compiler.plugin(\'done\', function() {\n    console.log(\'Hello World!\'); \n  });\n};\n\nmodule.exports = HelloWorldPlugin;\n```\n\nThere are two important objects extending with tapable very important:\n\n1. compiler: which represents the fully configured(configuration, loader, plugin, etc.) webpack enviroment\n2. compilation:  represents a single build of versioned assets\n\nA plugin is used in this way(Just for showing how it works):\n\n```javascript\ncompiler.apply(new HelloWorldPlugin())\n```\n\nCheck `compiler.apply`\n\n```javascript\nTapable.prototype.apply = function apply() {\n\tfor(var i = 0; i < arguments.length; i++) {\n\t\targuments[i].apply(this);\n\t}\n};\n```\n\nSo `HelloWorldPlugin.prototype.apply` is executed. that is, `compiler.plugin`.\n\nCheck its source\n\n```javascript\nTapable.prototype.plugin = function plugin(name, fn) {\n\tif(Array.isArray(name)) {\n\t\tname.forEach(function(name) {\n\t\t\tthis.plugin(name, fn);\n\t\t}, this);\n\t\treturn;\n\t}\n\tif(!this._plugins[name]) this._plugins[name] = [fn];\n\telse this._plugins[name].push(fn);\n};\n```\n\nIt just register callback on different event on `_plugins`.\n\nWhen a new compilation is started, [compiler will emit `compilation`](https://github.com/webpack/webpack/blob/314c897682b556845fea36d329de8016d1740900/lib/Compiler.js#L398):\n\n```javascript\nthis.applyPlugins("compilation", compilation, params);\n```\n\ncheck `applyPlugins` in `tapable`\n\n```javascript\nTapable.prototype.applyPlugins = function applyPlugins(name) {\n\tif(!this._plugins[name]) return;\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\tvar plugins = this._plugins[name];\n\tfor(var i = 0; i < plugins.length; i++)\n\t\tplugins[i].apply(this, args);\n};\n```\n\nIts obviously applyPlugins will execute callbacks registered on `_plugins` with specific name.\n\nThat\'s how plugins work.\n\nIn fact, webpack itself is organized with lots of internal plugins, which make it composable and flexible. Check [`lib/webpackOptionsApply.js`](https://github.com/webpack/webpack/blob/314c897682b556845fea36d329de8016d1740900/lib/WebpackOptionsApply.js), After the options is parsed and transfer to webpack core, it apply lots of plugins according to options configured.\n\nInteresting~\n\n### Build Process\n\nI won\'t cover too much about a compiler\'s or a compilation\'s lifecycle, but, now, lets write a simple plugin to inspect what happened inside webpack building process.\n\n```bash\n┌─(~/work/webpack-learning/6)──────────(reverland@reverland-R478-R429:pts/14)─┐\n└─(14:55:12)──> tree                                            ──(日, 7月24)─┘\n.\n├── app.js\n├── b.js\n└── InspectPlugin.js\n```\n\n`app.js`\n\n```javascript\nvar b = require(\'./b.js\')\nmodule.exports = b\n```\n\n`b.js`\n\n```javascript\nvar b = \'i\\\'m b\'\nmodule.exports = b\n```\n\nFinally, `InspectPlugins.js`, the inspect plugin we write to inspect the building process.\n\n```javascript\nvar events = ["resolver","this-compilation","global-hash-paths","hash","startup","render","local-vars","require","module-obj","require-extensions","normal-module-factory","before-resolve","after-resolve","emit","compilation","make","run","after-compile","seal","after-environment","normal-module-loader","optimize-chunk-assets","environment","module","expression ","evaluate Identifier __filename","evaluate Identifier __dirname","expression require.main","expression require.extensions","expression module.exports","expression module.loaded","expression module.id","evaluate Identifier module.hot","expression module","after-optimize-chunk-assets","context-module-factory","entry-option","done","invalid","jsonp-script","require-ensure","bootstrap","hot-bootstrap","call require","record","after-hash","additional-chunk-assets","module-require","global-hash","current-hash","expression __webpack_hash__","evaluate typeof __webpack_hash__","call module.hot.accept","call module.hot.decline","expression module.hot","build-module","asset-path","hash-for-chunk","expression process","expression global","expression console","expression Buffer","expression setImmediate","expression clearImmediate","after-resolvers","evaluate typeof ","evaluate Literal","evaluate LogicalExpression","evaluate BinaryExpression","evaluate UnaryExpression","evaluate typeof undefined","evaluate Identifier","evaluate MemberExpression","evaluate CallExpression","evaluate CallExpression .replace","evaluate CallExpression .","evaluate CallExpression .split","evaluate ConditionalExpression","evaluate ArrayExpression","typeof ","expression __webpack_amd_options__","evaluate typeof define.amd","evaluate typeof require.amd","evaluate Identifier define.amd","evaluate Identifier require.amd","can-rename define","rename define","call define","call define:amd:array","call define:amd:item","call define:amd:context","expression require.cache","expression require","call require:commonjs:item","call require:commonjs:context","evaluate typeof require.ensure","typeof require.ensure","evaluate typeof require.include","typeof require.include","call require:amd:array","call require:amd:item","call require:amd:context","alternatives","evaluate typeof module","assign require","can-rename require","rename require","typeof module","evaluate typeof exports","call require.resolve","call require.resolveWeak","call require.resolve(Weak)","call require.resolve(Weak):item","call require.resolve(Weak):context","statement if","expression ?:","evaluate Identifier __resourceQuery","expression __resourceQuery","succeed-module","optimize","before-hash","before-chunk-assets","optimize-assets","record-modules","revive-modules","record-chunks","revive-chunks","should-emit","should-record","call require.config","call requirejs.config","expression require.version","expression requirejs.onError","optimize-chunks","after-optimize-tree","package","chunk-hash","add-module","modules","optimize-module-order","optimize-chunk-order","optimize-chunk-ids","can-rename ","factory","evaluate Identifier ","compile","before-module-ids","optimize-extracted-chunks"]\n\nfunction InspectPlugin(options) {\n}\n\nInspectPlugin.prototype.apply = function(compiler) {\n  events.forEach(function(event) {\n    compiler.plugin(event, function() {\n      console.log(\'[compiler emit]\' + event + \'(\' + (arguments[0] ? arguments[0].constructor.name : \'\') + \')\')\n\n      if (event === \'compilation\') {\n        compilation = arguments[0]\n\n        events.forEach(function(e) {\n          if (typeof compilation.plugin === \'function\') {\n            compilation.plugin(e, function() {\n              console.log(\'[compilation emit]\' + e)\n\n              if (typeof arguments[arguments.length - 1] === \'function\') {\n                arguments[arguments.length - 1]()\n              }\n            })\n          }\n        })\n      }\n\n      if (typeof arguments[arguments.length - 1] === \'function\') {\n        arguments[arguments.length - 1]()\n      }\n\n    })\n  })\n}\n\nmodule.exports = InspectPlugin\n```\n\nBundle it:\n\n```bash\n┌─(~/work/webpack-learning/6)───────────(reverland@reverland-R478-R429:pts/7)─┐\n└─(13:53:46)──> webpack app.js bundle.js --plugin ./InspectPlugin.js \n[compiler emit]entry-option(String)\n[compiler emit]after-resolvers(Compiler)\n[compiler emit]environment()\n[compiler emit]after-environment()\n[compiler emit]run(Compiler)\n[compiler emit]normal-module-factory(NormalModuleFactory)\n[compiler emit]context-module-factory(ContextModuleFactory)\n[compiler emit]compile(Object)\n[compiler emit]this-compilation(Compilation)\n[compiler emit]compilation(Compilation)\n[compiler emit]make(Compilation)\n[compilation emit]build-module  // build app.js\n[compilation emit]normal-module-loader\n[compilation emit]succeed-module\n[compilation emit]build-module  // build b.js\n[compilation emit]normal-module-loader\n[compilation emit]succeed-module\n[compilation emit]seal\n[compilation emit]optimize\n[compilation emit]optimize-chunks\n[compilation emit]after-optimize-tree\n[compilation emit]should-record\n[compilation emit]revive-modules\n[compilation emit]optimize-module-order\n[compilation emit]before-module-ids\n[compilation emit]record-modules\n[compilation emit]revive-chunks\n[compilation emit]optimize-chunk-order\n[compilation emit]optimize-chunk-ids\n[compilation emit]record-chunks\n[compilation emit]before-hash\n[compilation emit]chunk-hash\n[compilation emit]after-hash\n[compilation emit]before-chunk-assets\n[compilation emit]additional-chunk-assets\n[compilation emit]record\n[compilation emit]optimize-chunk-assets\n[compilation emit]after-optimize-chunk-assets\n[compilation emit]optimize-assets\n[compiler emit]after-compile(Compilation)\n[compiler emit]should-emit(Compilation)\n[compiler emit]emit(Compilation)\n[compiler emit]done(Stats)\nHash: c771d64aa3c56fcbe3c1\nVersion: webpack 1.13.1\nTime: 98ms\n    Asset     Size  Chunks             Chunk Names\nbundle.js  1.55 kB       0  [emitted]  main\n   [0] ./app.js 45 bytes {0} [built]\n   [1] ./b.js 36 bytes {0} [built]\n```\n\nSo we can inspect how webpack works in a cleaner way, you can play it with [plugin api doc](https://github.com/webpack/docs/wiki/plugins) to have a better understanding on webpack\'s internals.\n\n### Module Build Process\n\nLast but not least, I\'d like to mention about how modules resolved and builded. the core loader functionality is implement by plugins.\n\nAs we can see from above our inspectplugin\'s output, a module is loaded with three events fired:\n\n0. build-module\n1. normal-module-build\n2. succeed-module\n\nyou can check it in [`lib/compilation.js`](https://github.com/webpack/webpack/blob/37540b647e9f7b26774d341c947a1c7487b77074/lib/Compilation.js#L126)\n\n```javascript\nCompilation.prototype.buildModule = function(module, thisCallback) {\n\tthis.applyPlugins("build-module", module);\n\tif(module.building) return module.building.push(thisCallback);\n\tvar building = module.building = [thisCallback];\n\n\tfunction callback(err) {\n\t\tmodule.building = undefined;\n\t\tbuilding.forEach(function(cb) {\n\t\t\tcb(err);\n\t\t});\n\t}\n\tmodule.build(this.options, this, this.resolvers.normal, this.inputFileSystem, function(err) {\n\t\tmodule.errors.forEach(function(err) {\n\t\t\tthis.errors.push(err);\n\t\t}, this);\n\t\tmodule.warnings.forEach(function(err) {\n\t\t\tthis.warnings.push(err);\n\t\t}, this);\n\t\tmodule.dependencies.sort(Dependency.compare);\n\t\tif(err) {\n\t\t\tmodule.error = err;\n\t\t\tthis.applyPlugins("failed-module", module);\n\t\t\treturn callback(err);\n\t\t}\n\t\tthis.applyPlugins("succeed-module", module);\n\t\treturn callback();\n\t}.bind(this));\n};\n```\n\nit\'s obvious, `module.build` will emit `normal-module-build` event.\n\nwhat `module.build`do?\n\nit\'s in [`lib/NormalModule.js`](https://github.com/webpack/webpack/blob/37540b647e9f7b26774d341c947a1c7487b77074/lib/NormalModule.js#L169), actually, it calls `doBuild`, in [this method](https://github.com/webpack/webpack/blob/37540b647e9f7b26774d341c947a1c7487b77074/lib/NormalModule.js#L120) we see it emit `normal-module-loader` event.\n\nnow check [`lib/dependencies/LoaderPlugin.js`](https://github.com/webpack/webpack/blob/37540b647e9f7b26774d341c947a1c7487b77074/lib/dependencies/LoaderPlugin.js#L17), we see\n\n```javascript\n\t\tcompilation.plugin("normal-module-loader", function(loaderContext, module) {\n\t\t\tloaderContext.loadModule = function loadModule(request, callback) {\n\t\t\t\tvar dep = new LoaderDependency(request);\n\t\t\t\tdep.loc = request;\n\t\t\t\tcompilation.addModuleDependencies(module, [\n\t\t\t\t\t[dep]\n], true, "lm", false, function(err) {\n```\n\nThis plugin call [`compilation.addModuleDependencies`](https://github.com/webpack/webpack/blob/37540b647e9f7b26774d341c947a1c7487b77074/lib/Compilation.js#L173). In this function, module dependencies are build and their dependencies are processed recursively if configured so.\n\nThat\'s how recursively module resolve and build works.\n\nA little twisted, I think I haven\'t understand it well...\n\n### Back To Loaders\n\nWhen a module is builded. [doBuild method in `core/lib/NormalModuleMixin.js`](https://github.com/webpack/core/blob/master/lib/NormalModuleMixin.js#L49) is the method to call. I think the source code a little confused, but let\'s try to understand it. It do following things\n\n1. prepare public loaderContext, so you can call some value and method in loader functions.\n2. prepare the function to evaluate loader function or pitch function in loader context closure.\n\nthen, loaders are actually loaded into memory, private loader context are prepared, pitch functions are evaluated one by one. Note, `loadPitch` is function to evaluate loader\'s pitch function one by one in recursive way, weired!\n\nWhenever a pitch function return something, the pitch is stopped and the loader functions is evaluated from loader which its next pitch function return something.\n\n`nextLoader` handle all of loaders evaluate, the first loader receive source code, transform it, and feed it to next loader, and the next loader evaluated in the same way. finally, when all loaders evaluated,`onModuleLoaded` is triggered with the last loader\'s result as parameter, that is, set the module\'s `_source` with the transformed source.\n\nThen the control of program transfer to `doBuild`\'s callback.\n\nThat\'s how loaders works under the hood.\n\n*Coolllllllll*, isn\'t it, despite of it employee recursive call to implement a loop like use black magic.\n\n## Conclusion\n\nSo, I may have to stop my exploration on webpack internals and start my new journey in a coming project soon. But I\'ve learned a lot from this simple exploration.\n\nIt takes me two weeks pieces of small times and weekends, I try to use debugger, try to write my own plugins and loaders, try to follow the source code to understand docs. I see how I\'ve learned before, such as event emitter is useful to organize projects, seperate of concerns, but make it hareder to debug and understand. I also see how callbacks and recursive twisted my head.: ) I have better understand in how it facilitate my work and how I could improve my work with webpack\'s power.\n\nWebpack is still so complex, so complex I don\'t believe I can understand anything in just two weeks. sokra and some other contributer in this project is, absolutely geniuses, thanks!\n\nNow, it finished, my sharing with exploration in webpack. However, no review, ton\'s of Syntax Error, misunderstand maybe everywhere. Any comments and instructions will be appreciated\n\nBTW: I don\'t have a stable network especially visit codepen, when the network fail, `everypage.js` behave strange and just crashed. then, I nearly lost unsaved post forever(in vim mode?). I can see it on screen but I can\'t save and can\'t even copy out post and just find each time i scroll codemirror, parts of my posts in dom generated and parts is removed, I can\'t even get the whole post to copy out...\n\nAfter hours of hard work, I find my self not easy to rescue all of my posts from the crashed codepen page, its really **ANNOY**\n\n<style>\nem {\n  color: red;\n}\n\nh2,h3,h4,h5 {\n  color: brown;\n  cursor: crosshair;\n}\n\nh2:hover,h3:hover, h4:hover, h5:hover {\n  animation: flash 1s infinite;\n}\n\nh3:before,h4:before,h5:before {\n  content: \'❄\';\n  color: tomato;\n}\nh2:before {\n  content: \'☕\';\n  color: tomato;\n}\n\n\n@keyframes flash {\n  0%, 100% {\n    color: brown;\n  }\n \t50% {\n    color: tomato;\n  }\n}\n</style>\n',
metaData:{layout:"post",title:"Exploring Webpack",excerpt:"webpack internals - from loaders to plugins",category:"javascript",tags:["webpack","javascript"],disqus:!0}}}});