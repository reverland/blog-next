{"version":3,"sources":["webpack:///static/js/143.d7b274f7f89115230258.js","webpack:///./src/posts/2012-06-08-first-ai-in-lisp.md"],"names":["webpackJsonp","266","module","exports","rawContent","metaData","layout","title","excerpt","category","tags","disqus"],"mappings":"AAAAA,cAAc,IAAI,MAEZC,IACA,SAASC,EAAQC,GCHvBD,EAAAC,SACAC,WAAA,+yDACAC,UACAC,OAAA,OACAC,MAAA,mBACAC,QAAA,kBACAC,SAAA,OACAC,MACA,gBAEAC,QAAA","file":"static/js/143.d7b274f7f89115230258.js","sourcesContent":["webpackJsonp([143,170],{\n\n/***/ 266:\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"rawContent\": \"\\n\\n## 创造一个智能的对手\\n\\n我们的[Dice of Doom][1]游戏树代码有个分开的游戏树生成使向游戏引擎添加AI很容易。事实上，让我们跟着作者添加23行代码来实现AI！！\\n\\n让我们先看看AI如何决定移动：\\n\\n- 查看每个可允许的移动\\n- 对每一步的后的board评分\\n- 选择分值最高的移动\\n\\n看起来很容易，那么怎么实现评分？如果一步后就赢了，很容易评分。如果不是的话怎么办？我们的移动将取决于对手的移动，为了不陷入不断考虑对手的境地中，提出一种算法。\\n\\n## 最小最大算法\\n\\n当赛场上只有两个玩家时，有这么个规则：对他人好的对我不好。这意味着我们可以采取如下模式决定对手的移动：\\n\\n- 查看每个可行移动\\n- 对每一步后的board评分\\n- 选择最小的评分的移动\\n\\n综上，这就是最大最小算法。这很关键，结果是我们可以避免分别为自己和对手计算评分，然后向下搜索游戏树中好的移动变得更简单和更快。为了让算法成为代码，还需要做少许调整。\\n\\n## 将最大最小算法转化为代码\\n\\n```cl\\n(defun rate-position (tree player)\\n  (let ((moves (caddr tree)))\\n    (if moves\\n      (apply (if (eq (car tree) player)\\n               #'max\\n               #'min)\\n             (get-ratings tree player))\\n      (let ((w (winners (cadr tree))))\\n        (if (member player w)\\n          (/ 1 (length w))\\n          0)))))\\n(defun get-ratings (tree player)\\n  (mapcar (lambda (move)\\n            (rate-position (cadr move) player))\\n          (caddr tree)))\\n```\\n\\n## 创造一个有AI的游戏循环\\n\\n先写个电脑处理函数，像我们的handle-human函数,首先找出每个移动的评分，然后选择评分最高的移动。\\n\\n```cl\\n(defun handle-computer (tree)\\n  (let ((ratings (get-ratings tree (car tree))))\\n    (cadr (nth (position (apply #'max ratings) ratings) (caddr tree)))))\\n```\\n最后，创造一个游戏环境即游戏循环\\n\\n```cl\\n(defun play-vs-computer (tree)\\n  (print-info tree)\\n  (cond ((null (caddr tree)) (announce-winner (cadr tree)))\\n        ((zerop (car tree)) (play-vs-computer (handle-human tree)));因为游戏中player1即代码0为人类玩家\\n        (t (play-vs-computer (handle-computer tree)))))\\n```\\n\\nfinished!!\\n\\n## 试试人类vs电脑游戏\\n\\n在repl中输入\\n\\n```cl\\n(play-vs-computer (game-tree (gen-board) 0 0 t))\\n```\\n\\n\\n## 写在最后\\n\\n终于考完试了，好久没看这本书。发现很多东西都生疏了，还好作者每次解释都很详细。这一章一看了好久，回头看看common lisp，东西真是相当之多……正好从图书馆找到HTDP的中文版，看完这本书全面转向scheme。\\n\\n最后引用首爱默生《人生苦旅》中的诗：\\n\\n> 我们把美归于简单\\n> \\n> 不含多余部分\\n> \\n> 边界清晰\\n> \\n> 与一切相关联\\n> \\n> 是中庸之道\\n\\n[1]: /lisp/2012/05/23/dice-of-doom/\\n\",\n\t\t\"metaData\": {\n\t\t\t\"layout\": \"post\",\n\t\t\t\"title\": \"First AI in lisp\",\n\t\t\t\"excerpt\": \"用lisp实现一个简单的AI。\",\n\t\t\t\"category\": \"lisp\",\n\t\t\t\"tags\": [\n\t\t\t\t\"land-of-lisp\"\n\t\t\t],\n\t\t\t\"disqus\": true\n\t\t}\n\t};\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** static/js/143.d7b274f7f89115230258.js\n **/","module.exports = {\n\t\"rawContent\": \"\\n\\n## 创造一个智能的对手\\n\\n我们的[Dice of Doom][1]游戏树代码有个分开的游戏树生成使向游戏引擎添加AI很容易。事实上，让我们跟着作者添加23行代码来实现AI！！\\n\\n让我们先看看AI如何决定移动：\\n\\n- 查看每个可允许的移动\\n- 对每一步的后的board评分\\n- 选择分值最高的移动\\n\\n看起来很容易，那么怎么实现评分？如果一步后就赢了，很容易评分。如果不是的话怎么办？我们的移动将取决于对手的移动，为了不陷入不断考虑对手的境地中，提出一种算法。\\n\\n## 最小最大算法\\n\\n当赛场上只有两个玩家时，有这么个规则：对他人好的对我不好。这意味着我们可以采取如下模式决定对手的移动：\\n\\n- 查看每个可行移动\\n- 对每一步后的board评分\\n- 选择最小的评分的移动\\n\\n综上，这就是最大最小算法。这很关键，结果是我们可以避免分别为自己和对手计算评分，然后向下搜索游戏树中好的移动变得更简单和更快。为了让算法成为代码，还需要做少许调整。\\n\\n## 将最大最小算法转化为代码\\n\\n```cl\\n(defun rate-position (tree player)\\n  (let ((moves (caddr tree)))\\n    (if moves\\n      (apply (if (eq (car tree) player)\\n               #'max\\n               #'min)\\n             (get-ratings tree player))\\n      (let ((w (winners (cadr tree))))\\n        (if (member player w)\\n          (/ 1 (length w))\\n          0)))))\\n(defun get-ratings (tree player)\\n  (mapcar (lambda (move)\\n            (rate-position (cadr move) player))\\n          (caddr tree)))\\n```\\n\\n## 创造一个有AI的游戏循环\\n\\n先写个电脑处理函数，像我们的handle-human函数,首先找出每个移动的评分，然后选择评分最高的移动。\\n\\n```cl\\n(defun handle-computer (tree)\\n  (let ((ratings (get-ratings tree (car tree))))\\n    (cadr (nth (position (apply #'max ratings) ratings) (caddr tree)))))\\n```\\n最后，创造一个游戏环境即游戏循环\\n\\n```cl\\n(defun play-vs-computer (tree)\\n  (print-info tree)\\n  (cond ((null (caddr tree)) (announce-winner (cadr tree)))\\n        ((zerop (car tree)) (play-vs-computer (handle-human tree)));因为游戏中player1即代码0为人类玩家\\n        (t (play-vs-computer (handle-computer tree)))))\\n```\\n\\nfinished!!\\n\\n## 试试人类vs电脑游戏\\n\\n在repl中输入\\n\\n```cl\\n(play-vs-computer (game-tree (gen-board) 0 0 t))\\n```\\n\\n\\n## 写在最后\\n\\n终于考完试了，好久没看这本书。发现很多东西都生疏了，还好作者每次解释都很详细。这一章一看了好久，回头看看common lisp，东西真是相当之多……正好从图书馆找到HTDP的中文版，看完这本书全面转向scheme。\\n\\n最后引用首爱默生《人生苦旅》中的诗：\\n\\n> 我们把美归于简单\\n> \\n> 不含多余部分\\n> \\n> 边界清晰\\n> \\n> 与一切相关联\\n> \\n> 是中庸之道\\n\\n[1]: /lisp/2012/05/23/dice-of-doom/\\n\",\n\t\"metaData\": {\n\t\t\"layout\": \"post\",\n\t\t\"title\": \"First AI in lisp\",\n\t\t\"excerpt\": \"用lisp实现一个简单的AI。\",\n\t\t\"category\": \"lisp\",\n\t\t\"tags\": [\n\t\t\t\"land-of-lisp\"\n\t\t],\n\t\t\"disqus\": true\n\t}\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/.npminstall/json-loader/0.5.4/json-loader!./loader/post-loader.js!./src/posts/2012-06-08-first-ai-in-lisp.md\n ** module id = 266\n ** module chunks = 143\n **/"],"sourceRoot":""}