webpackJsonp([153,191],{298:function(n,e){n.exports={rawContent:'\n\n# Dice of Doom v2\n\n我已经不怎么看得懂在讲什么了，所以胡言乱语请见谅,有几个问题:\n\n# 记不起之前的游戏树什么样了，我又懒得回头去看。是不是某种决策树？\n# 不停的函数接着函数扩展看起来很方便，但又要求你时刻记得之前实现的细节，以实现正确的改进\n# 作者的编程风格，以后还是按htdp里说的玩去吧，起码不会像现在这样晕。\n# 英语还是障碍啊，有时候看完一大段文字后不知道在讲什么，囧了。\n\n## Dice of Doom v2\n\n首先加载之前我们完成的 [Dice of Doom][dice] 源码和为惰性求值所实现的一系列库文件。没有的话就从land of lisp网站上下载吧，话说这本书真贵要40刀左右，豆瓣上竟然380元人民币……\n\n```cl\n(load "dice_of_doom_v1.lisp")\n(load "lazy.lisp")\n```\n\n然后先把游戏board扩大到4x4。\n\n```cl\n(defparameter *board-size* 4)\n(defparameter *board-hexnum* (* *board-size* *board-size*))\n```\n\n下面把Dice of Doom游戏全面lazy化吧\n\n```cl\n(defun add-passing-move (board player spare-dice first-move moves)\n  (if first-move\n    moves\n    (lazy-cons (list nil\n                     (game-tree (add-new-dice board player\n                                              (1- spare-dice))\n                                (mod (1+ player) *num-players*)\n                                0\n                                t))\n               moves)))\n(defun attacking-moves (board cur-player spare-dice)\n  (labels ((player (pos)\n             (car (aref board pos)))\n           (dice (pos)\n             (cadr (aref board pos))))\n    (lazy-mapcan\n      (lambda (src)\n        (if (eq (player src) cur-player)\n          (lazy-mapcan\n            (lambda (dst)\n              (if (and (not (eq (player dst)\n                                cur-player))\n                       (> (dice src) (dice dst)))\n                (make-lazy\n                  (list (list (list src dst)\n                              (game-tree (board-attack board\n                                                       cur-player\n                                                       src\n                                                       dst\n                                                       (dice src))\n                                         cur-player\n                                         (+ spare-dice (dice dst))\n                                         nil))))\n                (lazy-nil)))\n            (make-lazy (neighbors src)))\n          (lazy-nil)))\n      (make-lazy (loop for n below *board-hexnum*\n                       collect n)))))\n```\n\n注意lazy-mapcan要求被创建的列表是惰性的，现在你知道htdp标明每个函数输入输出的习惯多好了吧……\n\nlazy化handle-human函数和play-vs-human函数\n\n```cl\n(defun handle-human (tree)\n  (fresh-line)\n  (princ "choose your move:")\n  (let ((moves (caddr tree)))\n    (labels ((print-moves (moves n)\n               (unless (lazy-null moves)\n                 (let* ((move (lazy-car moves))\n                        (action (car move)))\n                   (fresh-line)\n                   (format t "~a. " n)\n                   (if action\n                     (format t "~a -> ~a" (car action) (cadr action))\n                     (princ "end turn")))\n                 (print-moves (lazy-cdr moves) (1+ n)))))\n      (print-moves moves 1))\n    (fresh-line)\n    (cadr (lazy-nth (1- (read)) moves))))\n(defun play-vs-human (tree)\n  (print-info tree)\n  (if (not (lazy-null (caddr tree)))\n    (play-vs-human (handle-human tree))\n    (announce-winner (cadr tree))))\n```\n\n现在你可以试试人人对战了，速度不错。\n\n## 让AI运行在更大的游戏区域\n\n对AI的惰性化之前，我们先做一些修剪的工作，这是对AI决策树/游戏树算法的优化[1]。\n\n我们现在的AI很尽职尽责的搜索计算所有的可能的结果。但在大的游戏面板中这样很累，为了在效率上取得平衡，限制AI的考虑决策树深度\n\n```cl\n(defun limit-tree-depth (tree depth)\n  (list (car tree)\n        (cadr tree)\n        (if (zerop depth)\n          (lazy-nil)\n          (lazy-mapcar (lambda (move)\n                         (list (car move)\n                               (limit-tree-depth (cadr move) (1- depth))))\n                       (caddr tree)))))\n(defparameter *ai-level* 4)\n(defun handle-computer (tree)\n  (let ((ratings (get-ratings (limit-tree-depth tree *ai-level*)\n                              (car tree))))\n    (cadr (lazy-nth (position (apply #\'max ratings) ratings)\n                    (caddr tree)))))\n(defun play-vs-computer (tree)\n  (print-info tree)\n  (cond ((lazy-null (caddr tree)) (announce-winner (cadr tree)))\n        ((zerop (car tree)) (play-vs-computer (handle-human tree)))\n        (t (play-vs-computer (handle-computer tree)))))\n```\n\n我没看懂……已经深深迷失在car cadr caddr的海洋之中，总之它限制了AI的思考深度，让它把评分限制在4步之内。[2]\n\n### 启发算法[3]\n\n让AI只思考较少的深度来实现投入和产出的统一。\n\n让我们用更复杂的启发算法来重新对游戏面板评分:对一个自己的地盘，如果附近有比自己强大的敌人则评分1,否则则评分2。若该地盘属于对手则评分为-1\n\n```cl\n(defun score-board (board player)\n  (loop for hex across board\n        for pos from 0\n        sum (if (eq (car hex) player)\n              (if (threatened pos board)\n                1\n                2)\n              -1)))\n;附近有更多骰子的位置有威胁\n(defun threatened (pos board)\n  (let* ((hex (aref board pos))\n         (player (car hex))\n         (dice (cadr hex)))\n    (loop for n in (neighbors pos)\n          do (let* ((nhex (aref board n))\n                    (nplayer (car nhex))\n                    (ndice (cadr nhex)))\n               (when (and (not (eq player nplayer)) (> ndice dice))\n                 (return t))))))\n```\n\n有意思的是，关于启发式作者这么说：在开发这个例子时，我模拟了使用不同版本score-board的各种对手，这个版本效果很好，开发启发式算法不是什么科学。囧～\n\n惰性化get-ratings和rate-position函数\n\n```cl\n(defun get-ratings (tree player)\n  (take-all (lazy-mapcar (lambda (move)\n                           (rate-position (cadr move) player))\n                         (caddr tree))))\n(defun rate-position (tree player)\n  (let ((moves (caddr tree)))\n    (if (not (lazy-null moves))\n      (apply (if (eq (car tree) player)\n               #\'max\n               #\'min)\n             (get-ratings tree player))\n      (score-board (cadr tree) player))))\n```\n\n现在可以试试和计算机过招了。\n\n```cl\n(play-vs-computer (game-tree (gen-board) 0 0 t))\n```\n\n据说先行者有优势，计算机大概有3/4的几率获胜。\n\n### alpha-beta 算法[4]\n\n @此部分不只所云，请见谅。@\n\nAI实际上执行一种深度优先搜索。\n\nalpha-beta算法是把已知的一定更差的子树从决策树中剪掉的算法，熟称剪枝算法。\n\n本游戏中游戏树的顶端上是最大最小算法，非顶端上是score-board评分……\n\n```cl\n(defun ab-get-ratings-max (tree player upper-limit lower-limit)\n  (labels ((f (moves lower-limit)\n             (unless (lazy-null moves)\n               (let ((x (ab-rate-position (cadr (lazy-car moves))\n                                          player\n                                          upper-limit\n                                          lower-limit)))\n                 (if (>= x upper-limit)\n                   (list x)\n                   (cons x (f (lazy-cdr moves) (max x lower-limit))))))))\n    (f (caddr tree) lower-limit)))\n\n(defun ab-get-ratings-min (tree player upper-limit lower-limit)\n  (labels ((f (moves upper-limit)\n             (unless (lazy-null moves)\n               (let ((x (ab-rate-position (cadr (lazy-car moves))\n                                          player\n                                          upper-limit\n                                          lower-limit)))\n                 (if (<= x lower-limit)\n                   (list x)\n                   (cons x (f (lazy-cdr moves) (min x upper-limit))))))))\n    (f (caddr tree) upper-limit)))\n\n(defun ab-rate-position (tree player upper-limit lower-limit)\n  (let ((moves (caddr tree)))\n    (if (not (lazy-null moves))\n      (if (eq (car tree) player)\n        (apply #\'max (ab-get-ratings-max tree\n                                         player\n                                         upper-limit\n                                         lower-limit))\n        (apply #\'min (ab-get-ratings-min tree\n                                         player\n                                         upper-limit\n                                         lower-limit)))\n      (score-board (cadr tree) player))))\n```\n\n这三个函数怎么实现及实现什么……不知道，深感自己英语不行啊，大段大段看完不知道在讲什么，哪天有兴致了对照对弈程序基本技术再看吧……I am confused now.[6]\n\n改进我们的handle-computer函数\n\n```cl\n(defun handle-computer (tree)\n  (let ((ratings (ab-get-ratings-max (limit-tree-depth tree *ai-level*)\n                                     (car tree)\n                                     most-positive-fixnum\n                                     most-negative-fixnum)))\n    (cadr (lazy-nth (position (apply #\'max ratings) ratings) (caddr tree)))))\n```\n\n现在把游戏面板扩大到5x5\n\n```cl\n(defparameter *board-size* 5)\n(defparameter *board-hexnum* (* *board-size* *board-size*))\n```\n\n由于我们记忆化的原因，之前的4x4面板会被缓存。为了修正这个问题重新定义neighbors函数即可。\n\n实验新的经过改进的游戏\n\n```cl\n(play-vs-computer (game-tree (gen-board) 0 0 t))\n```\n\n## 小结\n\n本章我们使用惰性求值方法改进我们的游戏，同时通过一些优化限制AI引擎搜索的决策树数目，我们学到了以下几点：\n\n- 惰性列表使你有可能使用无穷的列表和数据结构，并且很有效率\n- 一旦你有了lazy宏和force函数，你就可以基于此创造更复杂的惰性列表库\n- 启发性算法是不完美的算法，通过一些创造性的想法可以显著提高代码的性能。在我们的例子中我们使用启发式的算法来为游戏树的顶端评分。\n- 一旦我们把游戏转化为惰性树，为了限制AI思考的移动的深度我们可以优雅地[5]修剪游戏树。\n- Alpha-beta算法让我们更多地优化了性能，通过修剪不会影响AI最后所思考的移动的评分。\n\n<hr />\n\n## Footnotes\n\n[^1]: 我胡扯的，个人理解。\n\n[^2]: Note在讲什么我也不知道，只知道作者说这个虽然做的不够精细，但已经足够优化了。\n\n[^3]: 参见 "http://en.wikipedia.org/wiki/Heuristic_(computer_science)":http://en.wikipedia.org/wiki/Heuristic_(computer_science)\n\n[^4]: 参见 "http://en.wikipedia.org/wiki/Alpha-beta_pruning":http://en.wikipedia.org/wiki/Alpha-beta_pruning\n\n[^5]: 编写新的函数，看上去很优雅……\n\n[^6]: 可以先看看 "alpha-beta剪枝算法":http://www.xqbase.com/computer/search_alphabeta.htm\n\n[dice]: /lisp/2012/05/23/dice-of-doom/\n\n<hr />\n\n## 废话\n\n说实话，看不懂了，愈发的看不懂。生命中某种虚空感强烈的袭来，明知自己做的是“没有意义”，也没有人在意的的东西，可我就是关心那些。\n\n有时候真是不想理人，与很多人不怎么谈得来，我不喜欢到头来毫无建树的胡扯，也不喜欢扯不喜欢的东西。可有时无话可说无人可诉，人与人的差别就是这么大，不知何时。\n\n有时侯如此疯狂，讨厌别人的干扰，不能容忍自己浪费生命。在他人眼里我不也是在浪费生命？我不知道，安慰我的人永远安慰我，另一个部分人永远看不起我。\n\n我应该追求哪个世界与人生？一边是迷人的，我不知道余生还有多长，不想放手错过它，但它只在我的梦中。一条在横亘在这个世界，我却没有一丝爱意。\n\n也许一切都是宿命。\n',metaData:{layout:"post",title:"Dice of Doom v2",excerpt:"关于Dice of Doom游戏的第二个版本优化，实用惰性求值方法和搜索树修剪算法",category:"lisp",tags:["land-of-lisp"],disqus:!0}}}});