webpackJsonp([14,192],{607:function(n,e){n.exports={rawContent:"\ndotcloud悄无声息的远去了。我收到让转移应用的邮件才知道公司已经破产。\n\n就在几天前，往dotcloud上部署微信机器人时还饶有兴趣瞎折腾了一下。当时发在[cnodejs上](https://cnodejs.org/topic/56a310f28dcd3e826233708a)\n\n昨天，看到dotcloud[提供一个secure shell](https://www.dotcloud.com/dev-center/platform-documentation#secure-shell-ssh)，忽然脑洞大开，我觉得又可以花式Tunnel了。\n\n```bash\n┌─[reverland@reverland-R478-R429] - [~] - [2016-01-23 11:55:29]\n└─[0] <> export PATH=$PATH:$HOME/.local/bin\n┌─[reverland@reverland-R478-R429] - [~] - [2016-01-23 11:55:34]\n└─[0] <> dcapp wechat/default run bash\nConnecting...\n[wechat/default]:~$\n```\n\n好奇，我能不用dcapp直接连接吗？什么原理？\n\n于是翻了翻下载到dotcloudng的源码，开源软件就是好啊就是好。看到里头有个[ssh命令](https://github.com/cloudControl/cctrl/blob/c9e015920f52ca971d9dd6640f26b504d055f973/cctrl/app.py#L1162)\n\n    cmd = ssh_cmd(host_name, 'delete-cache', deployment_name)\n\n于是打印了一下，发现就是普通的ssh连接。于是抱着试试看的心理连了一次，还真可以。。\n\n    ssh -t -p 2222 -- wechat-default@sshforwarder.dotcloudapp.com TOKEN=t9Nd9ECasAgSD9UsYfcFwgysAF4bCL bash\n\n翻翻源码没什么问题。但是，`--`是啥？，token又是啥？\n\n`--`很快查到，为了防止bash解析后面的内容。[但token呢？](https://github.com/cloudControl/cctrl/blob/c9e015920f52ca971d9dd6640f26b504d055f973/cctrl/app.py#L126)\n\n    env = 'TOKEN={token}'.format(token=self.api.get_token()['token'])\n\n搜索了下没找到，cctrl引用了cclib，看到[get_token](https://github.com/cloudControl/pycclib/blob/d7688352abc1a2e71e8d5fbdac806e6ea9f68680/pycclib/cclib.py#L188)\n\n```python\ndef get_token(self):\n    \"\"\"\n        We use get_token to get the token.\n    \"\"\"\n    return self._token\n```\n\n\n那又是哪里设置了token呢？一眼看到上面的`set_token`。。。\n\n```python\ndef set_token(self, token):\n    \"\"\"\n        We use set_token to set the token.\n    \"\"\"\n    self._token = token\n```\n\n[检查set_token是在api init的时候](https://github.com/cloudControl/pycclib/blob/d7688352abc1a2e71e8d5fbdac806e6ea9f68680/pycclib/cclib.py#L97)\n\n看看Api类，就抱着试试看的心理用试验了下。。。然而401？\n\n```javascript\nvar getSshToken = new Promise((resolve, reject) => {\n  var req = https.request({\n    method: 'POST',\n    path: '/token/',\n    hostname: 'api.dotcloudapp.com',\n    headers: {\n      'User-Agent': 'pycclib/1.6.2',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Content-length': 0,\n    }\n  }, (res)=> {\n\t\tresolve(res);\n    }\n  });\n\n  req.end();\n})\n```\n\n我在想要不要把mitmproxy打开看看呢。忽然在文件中赫然看到个DEBUG标志，于是打开，清晰看到几次请求。发现第一次请求是不带任何参数的，就是401，在header中返回了一个sshtoken。紧接着第二次请求。这次http header中Authorization中多了一些东西：\n\n    ccssh signature=rqsolg/L43mTokqnwVCgfGpCxxxxxxxxxxxxxvsdv6HxXiyXkmEAg6kKvOHSjFhCprq2AuDQbU2Z7DHUcryu9bVRmBQvNOd2xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/92uN4C6aUkXqCmlp16G0VC2qqE/QrEuvO72OXeMC8tL4RrU3Qn7tRzablDo2sNaCXkXMcjMtqM+DpuzqbOHZnn7lEwynbCPOtRGaGYnVRQtxxxxxxxxxxxufi6oxomKGk/6ch8C7yjEE9hfbbqFcXBZQw==,fingerprint=c6:xx:92:8a:86:xx:6b:af:fe:xx:19:62:1b:xx:2b:f0,sshtoken=unBVe7F36pCfVhtZEmPCaT,email=xxx@linuxer.me\n\n虽然公钥和数据签名也没什么影响，还是打上码= =\n\nsshtoken是第一步在response header中www-authenticate中给的，其他的呢。\n\nemail很显然。。fingerprint，我自己的太熟悉了。。signature是啥？\n\n看了下源码，发现是[这个函数生成的signature](https://github.com/cloudControl/cctrl/blob/c9e015920f52ca971d9dd6640f26b504d055f973/cctrl/keyhelpers.py#L212)\n\n```python\nsignature = sign_token(key_path, fingerprint, sshtoken)\n```\n\n数据签名函数简化如下，把错误处理去掉了，还懒得管缩进。\n\n```python\ndef sign_token(key_path, fingerprint, data):\n    # from agent\n    pkey = get_key_from_agent(fingerprint)\n        # paramiko is inconsistent here in that the agent's key\n        # returns Message objects for 'sign_ssh_data' whereas RSAKey\n        # objects returns byte strings.\n        # Workaround: cast both return values to string and build a\n        # new Message object\n        s = str(pkey.sign_ssh_data(data))\n        m = Message(s)\n        m.rewind()\n       m.get_string() # == 'ssh-rsa':\n        return base64.b64encode(m.get_string())\n```\n\n于是自己查看文档试验了一下，\n\n```bash\n┌─[reverland@reverland-R478-R429] - [~/tmp/dcwall] - [2016-01-23 01:05:51]\n└─[0] <> ssh -v -t -p 2222 -- wechat-default@sshforwarder.dotcloudapp.com TOKEN=tv8NczygRPK6cgp78azgXyKKrX9KPN bash \nOpenSSH_6.6.1, OpenSSL 1.0.1f 6 Jan 2014\ndebug1: Reading configuration data /home/reverland/.ssh/config\ndebug1: Reading configuration data /etc/ssh/ssh_config\ndebug1: /etc/ssh/ssh_config line 19: Applying options for *\ndebug1: Connecting to sshforwarder.dotcloudapp.com [130.211.165.15] port 2222.\ndebug1: fd 3 clearing O_NONBLOCK\ndebug1: Connection established.\ndebug1: identity file /home/reverland/.ssh/id_rsa type 1\ndebug1: identity file /home/reverland/.ssh/id_rsa-cert type -1\ndebug1: identity file /home/reverland/.ssh/id_dsa type 2\ndebug1: identity file /home/reverland/.ssh/id_dsa-cert type -1\ndebug1: identity file /home/reverland/.ssh/id_ecdsa type -1\ndebug1: identity file /home/reverland/.ssh/id_ecdsa-cert type -1\ndebug1: identity file /home/reverland/.ssh/id_ed25519 type -1\ndebug1: identity file /home/reverland/.ssh/id_ed25519-cert type -1\ndebug1: Enabling compatibility mode for protocol 2.0\ndebug1: Local version string SSH-2.0-OpenSSH_6.6.1p1 Ubuntu-2ubuntu2.4\ndebug1: Remote protocol version 2.0, remote software version Twisted\ndebug1: no match: Twisted\ndebug1: SSH2_MSG_KEXINIT sent\ndebug1: SSH2_MSG_KEXINIT received\ndebug1: kex: server->client aes128-ctr hmac-md5 none\ndebug1: kex: client->server aes128-ctr hmac-md5 none\ndebug1: SSH2_MSG_KEX_DH_GEX_REQUEST(1024<3072<8192) sent\ndebug1: expecting SSH2_MSG_KEX_DH_GEX_GROUP\ndebug1: SSH2_MSG_KEX_DH_GEX_INIT sent\ndebug1: expecting SSH2_MSG_KEX_DH_GEX_REPLY\ndebug1: Server host key: RSA 5a:83:13:7c:d7:a1:cb:7c:ec:29:99:91:e4:bc:9d:01\ndebug1: Host '[sshforwarder.dotcloudapp.com]:2222' is known and matches the RSA host key.\ndebug1: Found key in /home/reverland/.ssh/known_hosts:3689\ndebug1: ssh_rsa_verify: signature correct\ndebug1: SSH2_MSG_NEWKEYS sent\ndebug1: expecting SSH2_MSG_NEWKEYS\ndebug1: SSH2_MSG_NEWKEYS received\ndebug1: SSH2_MSG_SERVICE_REQUEST sent\ndebug1: SSH2_MSG_SERVICE_ACCEPT received\ndebug1: Authentications that can continue: publickey\ndebug1: Next authentication method: publickey\ndebug1: Offering DSA public key: /home/reverland/.ssh/id_dsa\ndebug1: Authentications that can continue: publickey\ndebug1: Offering RSA public key: /home/reverland/.ssh/id_rsa\ndebug1: Server accepts key: pkalg ssh-rsa blen 279\ndebug1: Authentication succeeded (publickey).\nAuthenticated to sshforwarder.dotcloudapp.com ([130.211.165.15]:2222).\ndebug1: channel 0: new [client-session]\ndebug1: Entering interactive session.\ndebug1: Sending environment.\ndebug1: Sending env LC_IDENTIFICATION = zh_CN.UTF-8\ndebug1: Sending env LC_TIME = zh_CN.UTF-8\ndebug1: Sending env LC_NUMERIC = zh_CN.UTF-8\ndebug1: Sending env LC_PAPER = zh_CN.UTF-8\ndebug1: Sending env LC_MEASUREMENT = zh_CN.UTF-8\ndebug1: Sending env LC_ADDRESS = zh_CN.UTF-8\ndebug1: Sending env LC_MONETARY = zh_CN.UTF-8\ndebug1: Sending env LANG = en_US.UTF-8\ndebug1: Sending env LC_NAME = zh_CN.UTF-8\ndebug1: Sending env LC_TELEPHONE = zh_CN.UTF-8\ndebug1: Sending env LC_CTYPE = en_US.UTF-8\ndebug1: Sending command: TOKEN=tv8NczygRPK6cgp78azgXyKKrX9KPN bash\nConnecting...\n[wechat/default]:~$\n```\n\n想了想这个认证过程。\n\n*   https请求服务器，得到sshtoken\n*   用私钥给sshtoken的sha1哈希签名，连同公钥fingerprint，email，sshtoken一并发送给服务器\n*   （这一步是我猜的）服务器验证fingerprint身份（之前dcuser时应该已经密码认证传过公钥，待验证），服务器使用客户公钥解密签名，将解密得到的哈希和sshtoken的sha1哈希进行对比，实现身份验证和sshtoken 验证。返回再下一步ssh连接时要传递的token\n*   客户端ssh连接forward.dotcloudapp.com，认证通过后，服务器端需要检查Token的值来启动程序实例。为什么要检查呢？我猜，因为dotcloud免费用户控制只能运行一个Worker实例。。。\n\n于是，自己实现了下这个过程。\n\n```javascript\nvar exec = require('child_process').exec;\n\nvar https = require('https');\nvar EMAIL = 'sa@linuxer.me';\n\nvar getSshToken = new Promise((resolve, reject) => {\n  var req = https.request({\n    method: 'POST',\n    path: '/token/',\n    hostname: 'api.dotcloudapp.com',\n    headers: {\n      'User-Agent': 'pycclib/1.6.2',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'Content-length': 0,\n    }\n  }, (res)=> {\n    if ('www-authenticate' in res.headers) {\n      //console.log(res.headers['www-authenticate']);\n      var result = /sshtoken=(.+)$/mg.exec(res.headers['www-authenticate'])\n      if (!result) {\n        reject(\"fail to get ssh token\");\n      }\n      var sshtoken = result[1];\n      resolve(sshtoken);\n    }\n  });\n\n  req.end();\n})\n\nfunction getAuth(sshtoken) {\n  var p1 = getSignature(sshtoken);\n  var p2 = getFingerPrint();\n  var p3 = Promise.all([p1, p2]).then((k)=>{\n    return new Promise((resolve, reject)=>{\n      var authorization = 'ccssh ';\n      authorization += ('signature=' + k[0] + ',');\n      authorization += ('fingerprint=' + k[1] + ',');\n      authorization += ('sshtoken=' + sshtoken + ',');\n      authorization += ('email=' + EMAIL);\n      console.log(authorization);\n      resolve(authorization);\n    });\n  });\n  return p3;\n}\n\nfunction getSignature(sshtoken) {\n  return new Promise((resolve, reject)=>{\n    var cmd = 'echo -ne \"' + sshtoken + '\" | openssl sha1 -binary | openssl pkeyutl -sign -inkey ~/.ssh/id_rsa -pkeyopt digest:sha1';\n    //console.log(cmd);\n    exec(cmd,\n         // 以下两个参数非常重要\n         {\n           encoding: 'binary',\n           shell: '/bin/bash',\n         },\n         (error, stdout, stderr) => {\n           if (error) {\n             reject(error);\n           }\n           // 注意要binary而不是utf8\n           resolve(new Buffer(stdout, 'binary').toString('base64'));\n         });\n  });\n}\n\nfunction getFingerPrint() {\n  return new Promise((resolve, reject)=>{\n    exec('ssh-keygen -lf ~/.ssh/id_rsa.pub', (error, stdout, stderr) => {\n      if (error) {\n        reject(error);\n      }\n      resolve(stdout.toString().split(' ')[1]);\n    });\n  });\n}\n\nfunction getToken(authorization){\n  var p = new Promise((resolve, reject)=>{\n    var req = https.request({\n      method: 'POST',\n      path: '/token/',\n      hostname: 'api.dotcloudapp.com',\n      headers: {\n        'User-Agent': 'pycclib/1.6.2',\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-length': 0,\n        'Authorization': authorization,\n      }\n    }, (res)=> {\n      if (res.statusCode != 200) {\n        reject(\"fail to get token\");\n      }\n      var data = '';\n      res.on('data', (chunk)=>{\n        data += chunk;\n      });\n      res.on('end', ()=>{\n        resolve(data);\n      })\n    });\n\n    req.end();\n  });\n  return p;\n}\n\ngetSshToken.then(getAuth).then(getToken).then(console.log).catch(console.error);\n```\n\n一点也不顺利：\n\n我用的v5.0.0，看了看[文档里赫然写着stderror是Buffer好么](https://nodejs.org/docs/v5.0.0/api/child_process.html#child_process_child_process_exec_command_options_callback)\n\n```\ncallback Function called with the output when process terminates\n\n    error Error\n    stdout Buffer\n    stderr Buffer\n```\n\n_然而实际上怎么是String…..是我理解不对么？_\n\n其次，echo在/bin/sh和/bin/bash中不是一回事，一个是内置命令，一个是单独程序。。。\n\n再次，深刻体会到该binary的时候一定得binary，字符串在我这里只能utf-8。。再Buffer后完全不是之前的binary数据。被坑得半死不活。\n\n最后，Cheers\n\n```bash\n[wechat/default]:~$ curl https://twitter.com | md5sum\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100 70740  100 70740    0     0   219k      0 --:--:-- --:--:-- --:--:--  262k\n9f9f288dbfb5fbf379244ed9a75f7ebf  -\n```\n\n不过tunnel还是没成功，不过也不是为了tunnel不是。\n\n## 总结\n\nJust for fun！\n\n学习下dotcloud的cli认证原理\n\n不知道heroku是不是类似的认证方式\n\n我要好好研究下ssh forward原理。",metaData:{layout:"post",title:"记一次瞎逼折腾",excerpt:"纪念远去的dotcloud，ssh tunnel逆向",category:"hack",tags:["javascript","hack"],disqus:!0}}}});