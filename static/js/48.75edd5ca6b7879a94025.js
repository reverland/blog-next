webpackJsonp([48,192],{580:function(n,e){n.exports={rawContent:'\n\n\n源自：[blackhat.life/Shellcode/Environment](http://blackhat.life/Shellcode/Environment)，意译，原文是用gas的，我比较喜欢nasm语法。。。。。。\n\n一般汇编文件开头这样写入口：\n\n    global _start\n    _start:\n\n然后，比如64位，\n\n    nasm -f elf64 get_pc_64.s\n\n最后链接：\n\n    ld get_pc_64.o -o get_pc_64\n\n可以用gdb来载入查看\n\n     ~/Work/project/blackhat/shellcode  gdb -q a.out\n    Reading symbols from /home/reverland/Work/project/blackhat/shellcode/a.out...(no debugging symbols found)...done.\n    (gdb) disassemble _start,+10\n    Dump of assembler code from 0x4000b0 to 0x4000ba:\n       0x00000000004000b0 <_start+0>:       jmp    0x4000b3 <startup>\n       0x00000000004000b2 <pc+0>:   nop\n       0x00000000004000b3 <startup+0>:      lea    rax,[rip+0xfffffffffffffff8]        # 0x4000b2 <pc>\n    End of assembler dump.\n\n不过只是为了看汇编效果的话，不用链接直接看就是\n\n    ~ objdump -d -M intel last_call_32.o\n    last_call_32.o:     file format elf32-i386\n    \n    Disassembly of section .text:\n    \n    00000000 <_start>:\n       0:   8b 44 24 fc             mov    eax,DWORD PTR [esp-0x4]\n\n另外`ndisasm`和`rasm2`用不顺手，怎么和我想得到的结果不一样= =\n\n好了，废话完了，正文。\n\n---\n\nshellcode能在当前环境下，探测指令集架构，程序指针，上一个返回的地址，或者绕过和探测int3断点。\n\n## 探测指令集架构\n\n[Architecture Spanning Shellcode](http://phrack.org/issues/57/17.html)\n\n## GetPc\n\nGetPc是用来获得当前指令指针的技术。如果写自修改shellcode这个挺游泳，或者对那些必须知道自己所处环境的shellcode，因为环境信息在代码执行前不可预知。\n\n### x86\n\ncall会把下一行地址压栈\n\n    jmp startup\n    getpc:\n       mov eax [esp]\n       ret\n    startup:\n    call getpc       ; the %eax register now contains %eip on the next line\n\n### x64\n\n同理\n\n    jmp startup\n    getpc:\n       mov rax, [rsp]\n       ret\n    startup:\n    call getpc       ; the %rax register now contains %rip on the next line \n\n或者x64可以直接操作rip\n\n    jmp startup\n    pc:\n      nop\n    startup:\n      lea rax, [rel pc]  ; the %rax register now contains the address of `pc\'.\n\n## 上次调用返回地址\n\n一般情况下，在缓冲区溢出攻击中执行shellcode，假设nop sled没有改变堆栈，函数的返回地址是`[rsp-0x8]`或者`[esp-0x4]`，就是在溢出过程中覆盖的掉那个堆栈返回的地址。很多情况下，这能在写多态shellcode时替代GetPc. alphanumeric last call在64位系统中有13字节。\n\n### 32位\n\nNull-free的shellcode(没有`\\x00`)\n\n    mov eax, [esp-0x4]\n\n### 64位\n\nNull-free\n\n    mov [rax], [rsp-0x8]\n\n## int3断点\n\nint3断点可以被探测出来。\n\n    global _start\n    _start:\n    jmp startup\n    \n    go_retro:\n    pop rcx\n    inc rcx\n    jmp [rcx]\n    \n    startup:\n    call go_retro\n    \n    volatile_segment:\n    push 0x3458686a\n    push 0x0975c084\n    nop\n\n关键的代码在\n\n    push 0x3458686a\n    push 0x0975c084\n\n这是啥呢？\n\n     ~/Work/project/blackhat/shellcode  rasm2 -d "6a6858346885c07509"\n    push 0x68\n    pop eax\n    xor al, 0x68\n    test eax, eax\n    jne 0x12\n\n当在第二个push加断点时，会把上一个字节暂改为`\\xcc`\n\n    000000000000000d <volatile_segment>:\n       d:   68 6a 68 58 cc          push   0xcc58686a\n      12:   68 84 c0 75 09          push   0x975c084\n      17:   90                      nop\n\n这时，推到栈上的就是：\n\n     ~/Work/project/blackhat/shellcode  rasm2 -d "6a685834cc85c07509"\n    push 0x68\n    pop eax\n    xor al, 0xffffffcc\n    test eax, eax\n    jne 0x12\n\n这样就会向前跳0x12而不是激发断点。\n\n我们可以试试，下次再写loader，所以。。。\n\n     ~/Work/project/blackhat/shellcode  gdb -q detect_breakpoint\n    Reading symbols from /home/lyy/Work/project/blackhat/shellcode/detect_breakpoint...(no debugging symbols found)...done.\n    (gdb) disassemble _start,+20\n    Dump of assembler code from 0x4000b0 to 0x4000c4:\n       0x00000000004000b0 <_start+0>:       jmp    0x4000b8 <startup>\n       0x00000000004000b2 <go_retro+0>:     pop    rcx\n       0x00000000004000b3 <go_retro+1>:     inc    rcx\n       0x00000000004000b6 <go_retro+4>:     jmp    QWORD PTR [rcx]\n       0x00000000004000b8 <startup+0>:      call   0x4000b2 <go_retro>\n       0x00000000004000bd <volatile_segment+0>:     push   0x3458686a\n       0x00000000004000c2 <volatile_segment+5>:     push   0x975c084\n    End of assembler dump.\n    (gdb) b *0x00000000004000c2\n    Breakpoint 1 at 0x4000c2\n    (gdb) r\n    Starting program: /home/lyy/Work/project/blackhat/shellcode/detect_breakpoint \n    warning: no loadable sections found in added symbol-file system-supplied DSO at 0x7ffff7ffd000\n    \n    Program received signal SIGSEGV, Segmentation fault.\n    0x00000000004000b6 in go_retro ()\n    (gdb) \n\n没有碰到断点！！(那啥sigsegv了，看样子shellcode loader应该先写。。。)\n\nps: 这让我想起来之前反gdb调试的一些学习，下次再写吧\n\n## 跑题的吐槽\n\n作为一个什么都会点什么都不会的渣，也被推到投简历找实习的浪潮之中，立马被北邮的互联网求职氛围吓尿了，看到[bswgd在《谈谈在校程序员技能培养》](http://yanyiwu.com/work/2015/03/06/programmer-in-school.html)中谈到：\n\n> 几乎是从事互联网行业的人都知道，北邮人找互联网的工作特别拿手。 甚至被说成如蝗虫过境一般。事实却是也是如此。\n\n往身边看看，真是这感觉。。。\n\n看了[依云仙子的《再三错过》](http://lilydjwg.is-programmer.com/posts/58837.html)中心理好难过，阴影一直如影随形。\n\n于是在大家都投完简历我还是拖延着什么也没写，只是把仙子当年的感慨找来看了看。\n\n至于我自己，还是趁着没毕业多调查下吧\n\n\n\n\n\n',metaData:{layout:"post",title:"Shellcode/Environment",excerpt:"blackhat.life/shellcode系列",category:"exploit",tags:["shellcode"],disqus:!0}}}});