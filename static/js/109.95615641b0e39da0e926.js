webpackJsonp([109,170],{300:function(n,e){n.exports={rawContent:"\n\n# Image manipulation and processing using Numpy and Scipy\n\n翻译自：[http://scipy-lectures.github.com/advanced/image\\_processing/index.html](http://scipy-lectures.github.com/advanced/image_processing/index.html)\n\n作者：Emmanuelle Gouillart, Gaël Varoquaux\n\n    图像 = 2-D 数值数组\n    \n    (或者 3-D: CT, MRI, 2D + 时间; 4-D, ...)\n    \n    这里 图像 == Numpy数组 np.array\n\n这个教程中使用的工具：\n\n- numpy：基本数组操作\n- scipy：`scipy.ndimage`子模块致力于图像处理(n维图像)。参见[http://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html](http://docs.scipy.org/doc/scipy/reference/tutorial/ndimage.html)\n\n      from scipy import ndimage\n\n- 一些例子用到了使用np.array的特殊的工具箱：\n  - [Scikit Image](http://scikits-image.org/)\n  - [scikit-learn](http://scikit-learn.org/)\n\n图像中的常见问题有：\n\n- 输入/输出，呈现图像\n- 基本操作：裁剪、翻转、旋转……\n- 图像滤镜：消噪，锐化\n- 图像分割：不同对应对象的像素标记\n\n更有力和完整的模块：\n\n- [OpenCV](http://opencv.willowgarage.com/documentation/python/cookbook.html) (Python绑定)\n- [CellProfiler](http://www.cellprofiler.org/)\n- [ITK](http://www.itk.org/),Python绑定\n- 更多……\n\n**目录**\n\n* toc\n{: toc}\n\n## 打开和读写图像文件\n\n将一个数组写入文件：\n\n    In [1]: from scipy import misc\n    \n    In [2]: l = misc.lena()\n    \n    In [3]: misc.imsave('lena.png', l)  # uses the Image module (PIL)\n    \n    In [4]: import pylab as pl\n    \n    In [5]: pl.imshow(l)\n    Out[5]: <matplotlib.image.AxesImage at 0x4118110>\n\n从一个图像文件创建数组：\n\n    In [7]: lena = misc.imread('lena.png')\n    \n    In [8]: type(lena)\n    Out[8]: numpy.ndarray\n    \n    In [9]: lena.shape, lena.dtype\n    Out[9]: ((512, 512), dtype('uint8'))\n\n8位图像(0-255)的dtype是uint8\n\n打开一个raw文件(相机， 3-D图像)\n\n    In [10]: l.tofile('lena.raw')  # 创建一个raw文件\n\n    In [14]: lena_from_raw = np.fromfile('lena.raw', dtype=np.int64)\n    \n    In [15]: lena_from_raw.shape\n    Out[15]: (262144,)\n    \n    In [16]: lena_from_raw.shape = (512, 512)\n    \n    In [17]: import os\n    \n    In [18]: os.remove('lena.raw')\n\n需要知道图像的shape和dtype(如何区分隔数据字节)\n\n对于大数据，使用`np.memmap`进行内存映射：\n\n    In [21]: lena_memmap = np.memmap('lena.raw', dtype=np.int64, shape=(512,512))\n\n(数据从文件读取，而不是载入内存)\n\n处理一个列表的图像文件：\n\n    In [22]: for i in range(10):\n       ....:     im = np.random.random_integers(0, 255, 10000).reshape((100, 100))\n       ....:     misc.imsave('random_%02d.png' % i, im)\n       ....:     \n    \n    In [23]: from glob import glob\n    \n    In [24]: filelist = glob('random*.png')\n    \n    In [25]: filelist.sort()\n\n## 呈现图像\n\n使用`matplotlib`和`imshow`将图像呈现在matplotlib图像(figure)中：\n\n    In [29]: l = misc.lena()\n    \n    In [30]: import matplotlib.pyplot as plt\n    \n    In [31]: plt.imshow(l, cmap=plt.cm.gray)\n    Out[31]: <matplotlib.image.AxesImage at 0x4964990>\n\n通过设置最大最小之增加对比：\n\n    In [33]: plt.imshow(l, cmap=plt.cm.gray, vmin=30, vmax=200)\n    Out[33]: <matplotlib.image.AxesImage at 0x50cb790>\n    \n    In [34]: plt.axis('off')  # 移除axes和ticks\n    Out[34]: (-0.5, 511.5, 511.5, -0.5)\n\n绘制等高线：[^1]\n\n    ln[7]: plt.contour(l, [60, 211])\n\n更好地观察强度变化，使用`interpolate=‘nearest’`：\n\n    In [7]: plt.imshow(l[200:220, 200:220], cmap=plt.cm.gray)\n    Out[7]: <matplotlib.image.AxesImage at 0x3bbe610>\n    \n    In [8]: plt.imshow(l[200:220, 200:220], cmap=plt.cm.gray, interpolation='nearest')\n    Out[8]: <matplotlib.image.AxesImage at 0x3ed3250>\n\n其它包有时使用图形工具箱来可视化(GTK，Qt)：[^2]\n\n    In [9]: import skimage.io as im_io\n\n    In [21]: im_io.use_plugin('gtk', 'imshow')\n    \n    In [22]: im_io.imshow(l)\n\n**3-D可视化：Mayavi**\n\n参见[可用Mayavi进行3-D绘图](http://scipy-lectures.github.com/advanced/3d_plotting/index.html#mayavi-label)和[体积数据](http://scipy-lectures.github.com/advanced/3d_plotting/3d_plotting_functions.html#mayavi-voldata-label)\n\n- 图形平面工具\n- 等值面\n- ……\n\n## 基本操作\n\n图像是数组：使用整个`numpy`机理。\n\n![basic](http://scipy-lectures.github.com/_images/axis_convention.png)\n\n    >>> lena = misc.lena()\n    >>> lena[0, 40]\n    166\n    >>> # Slicing\n    >>> lena[10:13, 20:23]\n    array([[158, 156, 157],\n    [157, 155, 155],\n    [157, 157, 158]])\n    >>> lena[100:120] = 255\n    >>>\n    >>> lx, ly = lena.shape\n    >>> X, Y = np.ogrid[0:lx, 0:ly]\n    >>> mask = (X - lx/2)**2 + (Y - ly/2)**2 > lx*ly/4\n    >>> # Masks\n    >>> lena[mask] = 0\n    >>> # Fancy indexing\n    >>> lena[range(400), range(400)] = 255\n\n### 统计信息\n\n    >>> lena = scipy.lena()\n    >>> lena.mean()\n    124.04678344726562\n    >>> lena.max(), lena.min()\n    (245, 25)\n\n`np.histogram`\n\n### 几何转换\n\n    >>> lena = scipy.lena()\n    >>> lx, ly = lena.shape\n    >>> # Cropping\n    >>> crop_lena = lena[lx/4:-lx/4, ly/4:-ly/4]\n    >>> # up <-> down flip\n    >>> flip_ud_lena = np.flipud(lena)\n    >>> # rotation\n    >>> rotate_lena = ndimage.rotate(lena, 45)\n    >>> rotate_lena_noreshape = ndimage.rotate(lena, 45, reshape=False)\n\n![Geometrical transformations](http://scipy-lectures.github.com/_images/plot_geom_lena_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_geom_lena.html#example-plot-geom-lena-py)\n\n## 图像滤镜\n\n**局部滤镜**：用相邻像素值的函数替代当前像素的值。\n\n相邻：方形(指定大小)，圆形， 或者更多复杂的_结构元素_。\n\n### 模糊/平滑\n\n`scipy.ndimage`中的_高斯滤镜_：\n\n    >>> from scipy import misc\n    >>> from scipy import ndimage\n    >>> lena = misc.lena()\n    >>> blurred_lena = ndimage.gaussian_filter(lena, sigma=3)\n    >>> very_blurred = ndimage.gaussian_filter(lena, sigma=5)\n\n_均匀滤镜_\n\n    >>> local_mean = ndimage.uniform_filter(lena, size=11)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_blur.html#example-plot-blur-py)\n\n### 锐化\n\n锐化模糊图像：\n\n    >>> from scipy import misc\n    >>> lena = misc.lena()\n    >>> blurred_l = ndimage.gaussian_filter(lena, 3)\n\n通过增加拉普拉斯近似增加边缘权重：\n\n    >>> filter_blurred_l = ndimage.gaussian_filter(blurred_l, 1)\n    >>> alpha = 30\n    >>> sharpened = blurred_l + alpha * (blurred_l - filter_blurred_l)\n\n![sharpen](http://scipy-lectures.github.com/_images/plot_sharpen_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_sharpen.html#example-plot-sharpen-py)\n\n### 消噪\n\n向lena增加噪声：\n\n    >>> from scipy import misc\n    >>> l = misc.lena()\n    >>> l = l[230:310, 210:350]\n    >>> noisy = l + 0.4*l.std()*np.random.random(l.shape)\n\n_高斯滤镜_平滑掉噪声……还有边缘：\n\n    >>> gauss_denoised = ndimage.gaussian_filter(noisy, 2)\n\n大多局部线性各向同性滤镜都模糊图像(`ndimage.uniform_filter`)\n\n_中值滤镜_更好地保留边缘：\n\n    >>> med_denoised = ndimage.median_filter(noisy, 3)\n\n![guassian&median](http://scipy-lectures.github.com/_images/plot_lena_denoise_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_lena_denoise.html#example-plot-lena-denoise-py)\n\n中值滤镜：对直边界效果更好(低曲率)：\n\n    >>> im = np.zeros((20, 20))\n    >>> im[5:-5, 5:-5] = 1\n    >>> im = ndimage.distance_transform_bf(im)\n    >>> im_noise = im + 0.2*np.random.randn(*im.shape)\n    >>> im_med = ndimage.median_filter(im_noise, 3)\n\n![median](http://scipy-lectures.github.com/_images/plot_denoising_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_denoising.html#example-plot-denoising-py)\n\n其它排序滤波器：`ndimage.maximum_filter`,`ndimage.percentile_filter`\n\n其它局部非线性滤波器：维纳滤波器(`scipy.signal.wiener`)等\n\n**非局部滤波器**\n\n_总变差(TV)_消噪。找到新的图像让图像的总变差(正态L1梯度的积分)变得最小，当接近测量图像时：\n\n    >>> # from skimage.filter import tv_denoise\n    >>> from tv_denoise import tv_denoise\n    >>> tv_denoised = tv_denoise(noisy, weight=10)\n    >>> # More denoising (to the expense of fidelity to data)\n    >>> tv_denoised = tv_denoise(noisy, weight=50)\n\n总变差滤镜`tv_denoise`可以从`skimage`中获得，(文档:[http://scikit-image.org/docs/dev/api/skimage.filter.html#denoise-tv](http://scikit-image.org/docs/dev/api/skimage.filter.html#denoise-tv))，但是为了方便我们在这个教程中作为一个_单独模块_导入。\n\n![tv](http://scipy-lectures.github.com/_images/plot_lena_tv_denoise_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_lena_tv_denoise.html#example-plot-lena-tv-denoise-py)\n\n### 数学形态学\n\n参见：[http://en.wikipedia.org/wiki/Mathematical\\_morphology](http://en.wikipedia.org/wiki/Mathematical_morphology)\n\n_结构元素_：\n\n    >>> el = ndimage.generate_binary_structure(2, 1)\n    >>> el\n    array([[False,  True, False],\n           [ True,  True,  True],\n           [False,  True, False]], dtype=bool)\n    >>> el.astype(np.int)\n    array([[0, 1, 0],\n           [1, 1, 1],\n           [0, 1, 0]])\n\n_腐蚀_ = 最小化滤镜。用结构元素覆盖的像素的最小值替代一个像素值：\n\n    >>> a = np.zeros((7,7), dtype=np.int)\n    >>> a[1:6, 2:5] = 1\n    >>> a\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 1, 1, 1, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0]])\n    >>> ndimage.binary_erosion(a).astype(a.dtype)\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 0, 0, 0],\n           [0, 0, 0, 1, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0]])\n    >>> #Erosion removes objects smaller than the structure\n    >>> ndimage.binary_erosion(a, structure=np.ones((5,5))).astype(a.dtype)\n    array([[0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0, 0]])\n\n![erosion](http://scipy-lectures.github.com/_images/morpho_mat.png)\n\n_膨胀_：最大化滤镜:\n\n    >>> a = np.zeros((5, 5))\n    >>> a[2, 2] = 1\n    >>> a\n    array([[ 0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  1.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.]])\n    >>> ndimage.binary_dilation(a).astype(a.dtype)\n    array([[ 0.,  0.,  0.,  0.,  0.],\n           [ 0.,  0.,  1.,  0.,  0.],\n           [ 0.,  1.,  1.,  1.,  0.],\n           [ 0.,  0.,  1.,  0.,  0.],\n           [ 0.,  0.,  0.,  0.,  0.]])\n\n对灰度值图像也有效：\n\n    >>> np.random.seed(2)\n    >>> x, y = (63*np.random.random((2, 8))).astype(np.int)\n    >>> im[x, y] = np.arange(8)\n    \n    >>> bigger_points = ndimage.grey_dilation(im, size=(5, 5), structure=np.ones((5, 5)))\n    \n    >>> square = np.zeros((16, 16))\n    >>> square[4:-4, 4:-4] = 1\n    >>> dist = ndimage.distance_transform_bf(square)\n    >>> dilate_dist = ndimage.grey_dilation(dist, size=(3, 3), \\\n    ...         structure=np.ones((3, 3)))\n\n![gray-delation](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_greyscale_dilation.html)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_greyscale_dilation.html#example-plot-greyscale-dilation-py)\n\n_开操作_：腐蚀+膨胀：\n\n_应用_：移除噪声\n\n    >>> square = np.zeros((32, 32))\n    >>> square[10:-10, 10:-10] = 1\n    >>> np.random.seed(2)\n    >>> x, y = (32*np.random.random((2, 20))).astype(np.int)\n    >>> square[x, y] = 1\n    \n    >>> open_square = ndimage.binary_opening(square)\n    \n    >>> eroded_square = ndimage.binary_erosion(square)\n    >>> reconstruction = ndimage.binary_propagation(eroded_square, mask=square)\n\n![application](http://scipy-lectures.github.com/_images/plot_propagation_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_propagation.html#example-plot-propagation-py)\n\n_闭操作_：膨胀+腐蚀\n\n许多其它数学分形：击中(hit)和击不中(miss)变换，tophat等等。\n\n## 特征提取\n\n### 边缘检测\n\n合成数据：\n\n    >>> im = np.zeros((256, 256))\n    >>> im[64:-64, 64:-64] = 1\n    >>>\n    >>> im = ndimage.rotate(im, 15, mode='constant')\n    >>> im = ndimage.gaussian_filter(im, 8)\n\n使用_梯度操作(Sobel)_来找到搞强度的变化：\n\n    >>> sx = ndimage.sobel(im, axis=0, mode='constant')\n    >>> sy = ndimage.sobel(im, axis=1, mode='constant')\n    >>> sob = np.hypot(sx, sy)\n\n![sob](http://scipy-lectures.github.com/_images/plot_find_edges_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_find_edges.html#example-plot-find-edges-py)\n\n_canny滤镜_\n\nCanny滤镜可以从`skimage`中获取([文档](http://scikit-image.org/docs/dev/api/skimage.filter.html#canny))，但是为了方便我们在这个教程中作为一个_单独模块_导入：\n\n    >>> #from skimage.filter import canny\n    >>> #or use module shipped with tutorial\n    >>> im += 0.1*np.random.random(im.shape)\n    >>> edges = canny(im, 1, 0.4, 0.2) # not enough smoothing\n    >>> edges = canny(im, 3, 0.3, 0.2) # better parameters\n\n![edge](http://scipy-lectures.github.com/_images/plot_canny_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_canny.html#example-plot-canny-py)\n\n需要调整几个参数……过度拟合的风险\n\n### 分割\n\n- 基于_直方图_的分割(没有空间信息)\n\n        >>> n = 10\n        >>> l = 256\n        >>> im = np.zeros((l, l))\n        >>> np.random.seed(1)\n        >>> points = l*np.random.random((2, n**2))\n        >>> im[(points[0]).astype(np.int), (points[1]).astype(np.int)] = 1\n        >>> im = ndimage.gaussian_filter(im, sigma=l/(4.*n))\n        \n        >>> mask = (im > im.mean()).astype(np.float)\n        >>> mask += 0.1 * im\n        >>> img = mask + 0.2*np.random.randn(*mask.shape)\n        \n        >>> hist, bin_edges = np.histogram(img, bins=60)\n        >>> bin_centers = 0.5*(bin_edges[:-1] + bin_edges[1:])\n        \n        >>> binary_img = img > 0.5\n\n![segmente](http://scipy-lectures.github.com/_images/plot_histo_segmentation_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_histo_segmentation.html#example-plot-histo-segmentation-py)\n\n自动阈值：使用高斯混合模型：\n\n    >>> mask = (im > im.mean()).astype(np.float)\n    >>> mask += 0.1 * im\n    >>> img = mask + 0.3*np.random.randn(*mask.shape)\n    \n    >>> from sklearn.mixture import GMM\n    >>> classif = GMM(n_components=2)\n    >>> classif.fit(img.reshape((img.size, 1))) \n    GMM(...)\n    \n    >>> classif.means_\n    array([[ 0.9353155 ],\n           [-0.02966039]])\n    >>> np.sqrt(classif.covars_).ravel()\n    array([ 0.35074631,  0.28225327])\n    >>> classif.weights_\n    array([ 0.40989799,  0.59010201])\n    >>> threshold = np.mean(classif.means_)\n    >>> binary_img = img > threshold\n\n![gauss-mixture](http://scipy-lectures.github.com/_images/image_GMM.png)\n\n使用数学形态学来清理结果：\n\n    >>> # Remove small white regions\n    >>> open_img = ndimage.binary_opening(binary_img)\n    >>> # Remove small black hole\n    >>> close_img = ndimage.binary_closing(open_img)\n\n![cleanup](http://scipy-lectures.github.com/_images/plot_clean_morpho_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_clean_morpho.html#example-plot-clean-morpho-py)\n\n**练习**\n\n参看重建(reconstruction)操作(腐蚀+传播(propagation))产生比开/闭操作更好的结果：\n\n    >>> eroded_img = ndimage.binary_erosion(binary_img)\n    >>> reconstruct_img = ndimage.binary_propagation(eroded_img, mask=binary_img)\n    >>> tmp = np.logical_not(reconstruct_img)\n    >>> eroded_tmp = ndimage.binary_erosion(tmp)\n    >>> reconstruct_final = np.logical_not(ndimage.binary_propagation(eroded_tmp, mask=tmp))\n    >>> np.abs(mask - close_img).mean()\n    0.014678955078125\n    >>> np.abs(mask - reconstruct_final).mean()\n    0.0042572021484375\n\n**练习**\n\n检查首次消噪步骤(中值滤波，总变差)如何更改直方图，并且查看是否基于直方图的分割更加精准了。\n\n- _基于图像_的分割：使用空间信息\n\n        >>> from sklearn.feature_extraction import image\n        >>> from sklearn.cluster import spectral_clustering\n        \n        >>> l = 100\n        >>> x, y = np.indices((l, l))\n        \n        >>> center1 = (28, 24)\n        >>> center2 = (40, 50)\n        >>> center3 = (67, 58)\n        >>> center4 = (24, 70)\n        >>> radius1, radius2, radius3, radius4 = 16, 14, 15, 14\n        \n        >>> circle1 = (x - center1[0])**2 + (y - center1[1])**2 < radius1**2\n        >>> circle2 = (x - center2[0])**2 + (y - center2[1])**2 < radius2**2\n        >>> circle3 = (x - center3[0])**2 + (y - center3[1])**2 < radius3**2\n        >>> circle4 = (x - center4[0])**2 + (y - center4[1])**2 < radius4**2\n        \n        >>> # 4 circles\n        >>> img = circle1 + circle2 + circle3 + circle4\n        >>> mask = img.astype(bool)\n        >>> img = img.astype(float)\n        \n        >>> img += 1 + 0.2*np.random.randn(*img.shape)\n        >>> # Convert the image into a graph with the value of the gradient on\n        >>> # the edges.\n        >>> graph = image.img_to_graph(img, mask=mask)\n        \n        >>> # Take a decreasing function of the gradient: we take it weakly\n        >>> # dependant from the gradient the segmentation is close to a voronoi\n        >>> graph.data = np.exp(-graph.data/graph.data.std())\n        \n        >>> labels = spectral_clustering(graph, k=4, mode='arpack')\n        >>> label_im = -np.ones(mask.shape)\n        >>> label_im[mask] = labels\n\n![graph-base](http://scipy-lectures.github.com/_images/image_spectral_clustering.png)\n\n---\n\n## 测量对象属性：ndimage.measurements\n\n合成数据：\n\n    >>> n = 10\n    >>> l = 256\n    >>> im = np.zeros((l, l))\n    >>> points = l*np.random.random((2, n**2))\n    >>> im[(points[0]).astype(np.int), (points[1]).astype(np.int)] = 1\n    >>> im = ndimage.gaussian_filter(im, sigma=l/(4.*n))\n    >>> mask = im > im.mean()\n\n- _连接成分分析_\n\n    标记连接成分：`ndimage.label`\n\n        >>> label_im, nb_labels = ndimage.label(mask)\n        >>> nb_labels # how many regions?\n        23\n        >>> plt.imshow(label_im)        \n        <matplotlib.image.AxesImage object at ...>\n\n![label](http://scipy-lectures.github.com/_images/plot_synthetic_data_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_synthetic_data.html#example-plot-synthetic-data-py)\n\n计算每个区域的尺寸，均值等等：\n\n    >>> sizes = ndimage.sum(mask, label_im, range(nb_labels + 1))\n    >>> mean_vals = ndimage.sum(im, label_im, range(1, nb_labels + 1))\n\n计算小的连接成分：\n\n    >>> mask_size = sizes < 1000\n    >>> remove_pixel = mask_size[label_im]\n    >>> remove_pixel.shape\n    (256, 256)\n    >>> label_im[remove_pixel] = 0\n    >>> plt.imshow(label_im)        \n    <matplotlib.image.AxesImage object at ...>\n\n现在使用`np.searchsorted`重新分配标签：\n\n    >>> labels = np.unique(label_im)\n    >>> label_im = np.searchsorted(labels, label_im)\n\n![reassign](http://scipy-lectures.github.com/_images/plot_measure_data_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_measure_data.html#example-plot-measure-data-py)\n\n找到关注的封闭对象区域：[^3]\n\n    >>> slice_x, slice_y = ndimage.find_objects(label_im==4)[0]\n    >>> roi = im[slice_x, slice_y]\n    >>> plt.imshow(roi)     \n    <matplotlib.image.AxesImage object at ...>\n\n![find](http://scipy-lectures.github.com/_images/plot_find_object_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_find_object.html#example-plot-find-object-py)\n\n其它空间测量：`ndiamge.center_of_mass`,`ndimage.maximum_position`等等。\n\n可以在分割应用限制范围之外使用。\n\n示例：块平均(block mean)：\n\n    m scipy import misc\n    >>> l = misc.lena()\n    >>> sx, sy = l.shape\n    >>> X, Y = np.ogrid[0:sx, 0:sy]\n    >>> regions = sy/6 * (X/4) + Y/6  # note that we use broadcasting\n    >>> block_mean = ndimage.mean(l, labels=regions, index=np.arange(1,\n    ...     regions.max() +1))\n    >>> block_mean.shape = (sx/4, sy/6)\n\n![block mean](http://scipy-lectures.github.com/_images/plot_block_mean_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_block_mean.html#example-plot-block-mean-py)\n\n当区域不是正则的[^4]块状时，使用stride技巧更有效([示例：fake dimensions with strides](http://scipy-lectures.github.com/advanced/advanced_numpy/index.html#stride-manipulation-label))\n\n非正则空间(Non-regular-spaced)区块：径向平均：\n\n    >>> sx, sy = l.shape\n    >>> X, Y = np.ogrid[0:sx, 0:sy]\n    >>> r = np.hypot(X - sx/2, Y - sy/2)\n    >>> rbin = (20* r/r.max()).astype(np.int)\n    >>> radial_mean = ndimage.mean(l, labels=rbin, index=np.arange(1, rbin.max() +1))\n\n![radial](http://scipy-lectures.github.com/_images/plot_radial_mean_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_radial_mean.html#example-plot-radial-mean-py)\n\n- _其它测量_\n\n相关函数，傅里叶/小波谱等。\n\n一个使用数学形态学的例子：_粒度_([http://en.wikipedia.org/wiki/Granulometry\\_%28morphology%29](http://en.wikipedia.org/wiki/Granulometry_%28morphology%29))\n\n    >>> def disk_structure(n):\n    ...     struct = np.zeros((2 * n + 1, 2 * n + 1))\n    ...     x, y = np.indices((2 * n + 1, 2 * n + 1))\n    ...     mask = (x - n)**2 + (y - n)**2 <= n**2\n    ...     struct[mask] = 1\n    ...     return struct.astype(np.bool)\n    ...\n    >>>\n    >>> def granulometry(data, sizes=None):\n    ...     s = max(data.shape)\n    ...     if sizes == None:\n    ...         sizes = range(1, s/2, 2)\n    ...     granulo = [ndimage.binary_opening(data, \\\n    ...         structure=disk_structure(n)).sum() for n in sizes]\n    ...     return granulo\n    ...\n    >>>\n    >>> np.random.seed(1)\n    >>> n = 10\n    >>> l = 256\n    >>> im = np.zeros((l, l))\n    >>> points = l*np.random.random((2, n**2))\n    >>> im[(points[0]).astype(np.int), (points[1]).astype(np.int)] = 1\n    >>> im = ndimage.gaussian_filter(im, sigma=l/(4.*n))\n    >>>\n    >>> mask = im > im.mean()\n    >>>\n    >>> granulo = granulometry(mask, sizes=np.arange(2, 19, 4))\n\n![granulometry](http://scipy-lectures.github.com/_images/plot_granulo_1.png)\n\n[示例源码](http://scipy-lectures.github.com/advanced/image_processing/auto_examples/plot_granulo.html#example-plot-granulo-py)\n\n## Footnotes\n\n[^1]:占位\n[^2]:ValueError: can not convert int64 to uint8.\n[^3]:根据以上操作剩下的区域选择区域，因为是随机生成可能结果不通，label_im==4未必留下来了。\n[^4]:[正则空间](https://en.wikipedia.org/wiki/Regular_space)\n",metaData:{layout:"post",title:"使用Numpy和Scipy处理图像",excerpt:"scipy lecture notes",category:"python",tags:["scipy-lecture-notes","python"],disqus:!0}}}});