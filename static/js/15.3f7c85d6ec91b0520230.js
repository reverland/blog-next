webpackJsonp([15,194],{611:function(n,e){n.exports={rawContent:"\n这里的第一篇文章标示的日期是2012年2月7日，到今天，眨眼间4年多过去了。没想到竟然断断续续写了四年。\n\n感谢vimwiki，感谢jekyll，感谢hexo，感谢开源社区和贡献者们。\n\n感谢bitbucket，感谢github，感谢gitcafe，感谢凤凰君曾经的嗯静态博客托管。\n\n感谢每一个鼓励的朋友。\n\n竟然四年了。去年想就这么算了吧，域名也没续费。结果服务商凤凰君给设置自动续费了，现在域名才继续能用。。\n\n开始正题吧。\n\n希望在这里写下的每篇文章，简单而快乐。\n\n## A GAME\n\n我编程的入门从一本叫Land of Lisp的书开始，这里给我揭开了web server的迷雾，揭开了socket的迷雾，揭开了svg的迷雾，甚至揭开了AI的迷雾。\n\n这本书中有一个模拟自然界的小游戏[使用loop来进化](http://reverland.org/lisp/2012/05/06/using-loop-to-evolve/)。\n\n一个非常简单但非常有意思的游戏，我还记得为了想要更大的世界，让cpu和io卡顿异常的记忆。\n\n多年以后，看到有本叫eloquent javascript的书中有另外一个类似的例子[电子生命](http://eloquentjavascript.net/07_elife.html)。\n\n我就想说这个游戏。\n\n## 图形界面\n\n感谢Marijn Haverbeke，面向对象带来了非常好的组件化效果，随便加个函数就实现了图形界面的变更。\n\n我这里将实现4种界面：\n\n*   terminal\n*   dom\n*   canvas\n*   webGL\n\n首先，world类的constructor需要根据准备画布，如果试canvas或者webgl还要做好调整和准备工作。\n\n```javascript\n/**\n * class World\n */\nclass World {\n  constructor(map, legend, canvas, canvasLegend, size, flag) {\n    this.grid = new Grid(map[0].length, map.length);\n    this.legend = legend;\n    if (canvas) {\n      //canvas\n      this._canvasLegend = canvasLegend;\n      this._canvas = canvas;\n\n      this._canvas.width = map[0].length * size;\n      this._canvas.height = map.length * size;\n\n      this._size = size;\n\n      if (flag == 'dom') {\n        this._canvas.style.width = this._canvas.width + 'px';\n        this._canvas.style.height = this._canvas.height + 'px';\n        this.draw = this.drawDom;\n      } else if (flag == 'canvas') {\n        this._ctx = canvas.getContext('2d');\n        this.draw = this.drawCanvas;\n      } else if (flag == 'webgl'){\n        let gl = canvas.getContext('webgl');\n        this._gl = gl;\n        gl.clearColor(1, 1, 1, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.viewport(0, 0, this._canvas.width, this._canvas.height);\n\n        let v = `\n        //这部分是顶点着色器  \n        attribute vec2 aVertexPosition;\n        void main() {\n            gl_Position = vec4(aVertexPosition, 0.0, 1.0);\n        }\n        `;\n\n        let f = `\n        //这部分是片段着色器  \n        precision highp float;\n\n        uniform vec4 uColor;\n\n        void main() {\n           gl_FragColor = uColor;\n        }\n        `;\n\n\n        let vs = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vs, v);\n        gl.compileShader(vs);\n\n        var fs = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fs, f);\n        gl.compileShader(fs);\n\n        this.program = gl.createProgram();\n        gl.attachShader(this.program, vs);\n        gl.attachShader(this.program, fs);\n        gl.linkProgram(this.program);\n\n        // debugging\n        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))\n          console.log(gl.getShaderInfoLog(vs));\n\n        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))\n          console.log(gl.getShaderInfoLog(fs));\n\n        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS))\n          console.log(gl.getProgramInfoLog(this.program));\n\n        this.draw = this.drawWebGL;\n\n        gl.useProgram(this.program);\n\n      }\n    } else if (canvasLegend) {\n      this._canvasLegend = canvasLegend;\n      this.draw = this.drawTerminal;\n    }\n\n    let self = this;\n    map.forEach(((line, y) => {\n      for (let x = 0; x < line.length; x++) {\n        this.grid.set(new Vector(x, y),\n                      elementFromChar(legend, line[x]));\n      }\n    }).bind(self));\n\n    this._stastics = {};\n    this.clearstastics();\n  }\n```\n\n### Terminal Animation\n\n最最早的时候，我当时在nodejs中实现了这个游戏，试图在终端中不断打印刷新来生成动画。\n\n你知道的，终端的IO效率非常低，世界一大，非常之卡，那是第一个UI实现。一个古老的终端动画思路。\n\n```javascript\ndrawTerminal() {\n    process.stdout.clearScreenDown();\n    let element\n        let line = '';\n    for (let y = 0; y < this.grid.height; y++) {\n        for (let x = 0; x < this.grid.width; x++) {\n            element = this.grid.get(new Vector(x, y));\n            line += (charFromElement(element) || \" \");\n            if (x == this.grid.width-1) {\n                line += '\\n';\n            }\n        }\n    }\n    process.stdout.write(line);\n    process.stdout.cursorTo(0, 0);\n}\n```\n\n![Terminal Animation UI](http://img.vim-cn.com/b1/109b70f577066d82883688bef88cdb59d337b1.gif)\n\n这不好看，我们希望是色彩鲜艳用户界面\n\n```javascript\ndrawTerminal() {\n  process.stdout.clearScreenDown();\n  let line = '';\n  for (let y = 0; y < this.grid.height; y++) {\n    for (let x = 0; x < this.grid.width; x++) {\n      let element = this.grid.get(new Vector(x, y));\n      let color = this._canvasLegend[charFromElement(element)];\n      if (!color) {\n        line += \"\\x1b[107m \\x1b[0m\";\n      } else {\n        let colorC = terminalColors[color];\n        line += (colorC + \" \" + \"\\x1b[0m\");\n      }\n    }\n    line += '\\n';\n  }\n  process.stdout.write(line);\n  process.stdout.cursorTo(0, 0);\n}\n```\n\n![Terminal Animation UI colored](http://img.vim-cn.com/22/7fc0abccc74290dce1eb72a1bfba4f066f20c4.gif)\n\n我们能实现的更漂亮，通过字体和颜色的搭配，但，我马上得去滑雪了，不试了。\n\n聪明的我于是就把这个任务交给感兴趣的读者，如果有人实现了请联系我让我膜拜下。\n\n### DOM Animation\n\n然后嘛，就是DOM版本的了，Marijn Haverbeke给出了默认的draw实现。不过既然到了浏览器上，就可以画出些色彩花样。  \n我们可以动态插入一些div并根据legend来附上色彩甚至图像。\n\n实现起来也多样，可以不停操作DOM(下面的代码我没试过哈)\n\n```javascript\ndrawDom() {\n  this._canvas.innerHTML = '';\n  for (let y = 0; y < this.grid.height; y++) {\n    for (let x = 0; x < this.grid.width; x++) {\n      element = this.grid.get(new Vector(x, y));\n      let color = this._canvasLegend[charFromElement(element)];\n      let e = document.createElement('div');\n      e.style.width = size + 'px';\n      e.style.height = size + 'px';\n      e.style.backgroundColor = color;\n      this._canvas.appendChild(e);\n    }\n  }\n}\n```\n\n当然，也可以生成一堆html然后每次刷新只插入一次。妄图效率能高一些。\n\n```javascript\ndrawDom() {\n  let html = '';\n  let size = this._size;\n  this._canvas.innerHTML = '';\n  for (let y = 0; y < this.grid.height; y++) {\n    for (let x = 0; x < this.grid.width; x++) {\n      let element = this.grid.get(new Vector(x, y));\n      let color = this._canvasLegend[charFromElement(element)];\n      html += `<div style='background-color:${color};width:${size}px;height:${size}px;float:left'></div>`\n    }\n  }\n  this._canvas.innerHTML = html;\n}\n```\n\n![DOM Animation UI](http://img.vim-cn.com/d1/05a775e6f58573966fa4693d21056d6ce133e6.gif)\n\n聪明的我留给读者又一个练习，给每种单位一个图片，让最后渲染效果不是色块而是图片。\n\n### Canvas Animation\n\n接下来欢迎来到canvas的世界。\n\n使用canvas很简单，准备画布，然后给出js指令告诉canvas如何绘图。\n\n```javascript\ndrawCanvas() {\n  let element;\n  this._ctx.save();\n  for (let y = 0; y < this.grid.height; y++) {\n    for (let x = 0; x < this.grid.width; x++) {\n      element = this.grid.get(new Vector(x, y));\n      this._ctx.fillStyle = this._canvasLegend[charFromElement(element)];\n      this._ctx.fillRect(x * this._size, y * this._size, this._size, this._size);\n      // deadly slow if so.\n      //this._ctx.beginPath();\n      //this._ctx.arc(x * this._size, y * this._size, this.size / 2, 0, Math.PI * 2);\n      //this._ctx.fill();\n      this._ctx.fillStyle = 'white';\n    }\n  }\n  this._ctx.restore();\n}\n```\n\nIt’s fucking cool!\n\n![canvas Animation UI](http://img.vim-cn.com/08/d056d8ad19af2755c9bada138cced2046d69ab.gif)\n\n当然，如果你尝试试着在每个单位绘制复杂图像，将有意外惊喜。请尝试前保存好当前工作。\n\n聪明的我于是将留给读者又一个练习，给每个单位贴图，给背景贴图。\n\n### WebGL Animation\n\n最后，webGL，我们把绘制交给gpu来完成。使用webGL相对较复杂一些(当然，特定需求three.js这种封装的很方便，但原生接口对陌生的同学需要学习和理解以下)\n\nwebgl暴露了这么一种接口。啊，我不准备讲opengl流水线，一点直观理解就够了。\n\n*   准备画布，调整观察者在空间中的位置。默认情况下，远处和近处物体一样大，画布中心是(0, 0, 0)，空间坐标是右手座标系。\n*   我们使用一种叫GLSL的语言来准备两个shader文件来指导显卡如何渲染数据。其中vertex决定顶点数据，fragment决定如何渲染。\n*   webGL暴露了这么一种接口，你可以创建、编译、链接GLSL语言的程序，而webGL将提供一些接口让你能制定这些程序使用的数据。\n*   webGL也提供了制作让GLSL编译后的程序能理解的数据的接口，这样就能把javascript中的数据传递给显卡。\n\n以下只是一种实现，为了实现类似canvas中`fillRect`效果封装了个`_webGLRect`函数。  \n聪明的读者将会自己实现更好的。。。\n\n聪明的我将留给读者又一个练习，给每个单位贴图，给背景贴图。\n\n```javascript\ndrawWebGL() {\n  let element;\n  let colorName;\n  var wRatio = 2 / this.grid.width ;\n  var hRatio = 2 / this.grid.height;\n  this._gl.clearColor(1, 1, 1, 1.0);\n  this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT);\n  for (let y = 0; y < this.grid.height; y++) {\n    for (let x = 0; x < this.grid.width; x++) {\n      element = this.grid.get(new Vector(x, y));\n      if (element) {\n        colorName = this._canvasLegend[charFromElement(element)];\n        this._webGLRect(x * wRatio, y * hRatio, wRatio, hRatio, colorName);\n      }\n    }\n  }\n}\n\n_webGLRect(x, y, wRatio, hRatio, colorName) {\n  let gl = this._gl;\n  var vertices = new Float32Array([\n    -1 + x, -1 + y,\n    -1 + x + wRatio, -1 + y + 0,\n    -1 + x + wRatio, -1 + y + hRatio,\n    -1 + x + 0, -1 + y + 0,\n    -1 + x + wRatio, -1 + y + hRatio,\n    -1 + x + 0, -1 + y + hRatio\n  ]);\n\n  let vbuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, vbuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n  let itemSize = 2;\n  let numItems = vertices.length / itemSize;\n\n  let uColor = gl.getUniformLocation(this.program, \"uColor\");\n  switch (colorName) {\n      case \"red\":\n          gl.uniform4fv(uColor, [1.0,0.0,0.0,1.0]);\n          break;\n      case \"green\":\n          gl.uniform4fv(uColor, [0.0,1.0,0.0,1.0]);\n          break;\n      case \"blue\":\n          gl.uniform4fv(uColor, [0.0,0.0,1.0,1.0]);\n          break;\n      case \"yellow\":\n          gl.uniform4fv(uColor, [1.0,0.0,1.0,1.0]);\n          break;\n      case \"black\":\n          gl.uniform4fv(uColor, [0.0,0.0,0.0,1.0]);\n          break;\n  }\n\n  let aVertexPosition = gl.getAttribLocation(this.program, \"aVertexPosition\");\n\n  gl.enableVertexAttribArray(aVertexPosition);\n  gl.vertexAttribPointer(aVertexPosition, itemSize, gl.FLOAT, false, 0, 0);\n\n  gl.drawArrays(gl.TRIANGLES, 0, numItems);\n}\n```\n\n![webGL Animation UI](http://img.vim-cn.com/8d/d346f93ee3ad8163e4390bf64c02ada9c768db.gif)\n\n### 性能与瞎想\n\n我本来想给出些科学的探索，然而，我并不能给出谁发热多谁发热少的结论\n\nterminal表现非常好，可惜terminal能画的单位数目有限。\n\nDOM的效率比想象中高很多，能超过canvas很多接近webGL，想想如果用SVG是不是更高2333\n\ncanvas，如果需要绘制成千上万次，请使用贴图。。\n\nwebGL，可以编辑更复杂的shader文件，一次将要绘制的世界准备好，而不是在循环里不断调用绘图接口。\n\n### More?\n\n等待您的指教\n\n## Have Fun With it\n\n实际上、通过web技术我们能和这个世界交互。于是，改造成一个伪God Name。\n\n用鼠标在任何位置随时添加的各种单位，随时拆墙建墙。。。如果有谁有兴趣，\n\n聪明的读者会自己玩~\n\nHave fun~,准备滑雪！",metaData:{layout:"post",title:"Evolving Game Once More",excerpt:"生物模拟游戏，终端动画、div动画、canvas动画、webgl动画全系列实现",category:"javascript",tags:["javascript","webgl","canvas"],disqus:!0}}}});