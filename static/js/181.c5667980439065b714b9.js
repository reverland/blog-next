webpackJsonp([181,191],{270:function(n,e){n.exports={rawContent:"\n## Lisp is amazing,isn't it?\n\n最早的时候，是从emacs听说lisp的，不过emacs这等神器，却并非我的菜，几经折腾最终滚回了简洁的vim。\n\n最早开始学习lisp，是跟着田春译的《实用common lisp编程》，看了几章越看越累，等到看到讲单元测试那章时，我已经不知道在讲什么了。不过很惊叹lisp自动生成程序的能力倒是，还有种让人着迷的数学感。\n\n后来看见网上有人在译[ansi common lisp中文版](http://readthedocs.org/docs/ansi-common-lisp/en/latest/index.html)，沉寂了两个月的lisp情怀陡升，我又开始看了。看了两章也陷入了越看越累的境地，最后到了能读懂却不能写出的境界，相对之前，也算是进步吧。然而才到高级数据结构那部分，我已没看下去的勇气，我觉得自己这种小白应该先修炼本更循序渐进的。\n\n然后找啊找在[common-lisp](http://common-lisp.net/)上有推荐Land of lisp这本书,虽然很贵，但天朝的孩子们总是有办法的：[lisp资料](http://115.com/folder/faujangp#lisp)。\n\n好难得有本图文并茂的书，声称一次一个游戏，我就喜欢这种例子丰富的东西，幽默点不致于无聊更好。找不到中文版，算了，英文版直接上吧。话说还考研，唉，还是想抽空看看这个。\n\n***\n\n## 第一个游戏\n\n猜数的小游戏，不解释。\n\n```cl\n(defun guess-my-number ()\n  (ash (+ *big* *small*) -1))\n(defun bigger ()\n  (setf *small* (1+ (guess-my-number)))\n  (guess-my-number))\n(defun smaller ()\n  (setf *big* (1- (guess-my-number)))\n  (guess-my-number))\n(defun start-over ()\n  (defparameter *small* 1)\n  (defparameter *big* 100)\n  (guess-my-number))\n```\n\n## 一个简单的文本游戏引擎\n\n```cl\n;;定义节点及描述\n(defparameter *nodes* '((living-room (you are in the living-room.\n                                          a wizard is snoring loudly on the couch.))\n                        (garden (you are in a beautiful garden.\n                                     there is a well in front of you.))\n                        (attic (you are in the attic.\n                                    there is a giant welding torch in the corner.))))\n;;定义描述效应位置的函数\n(defun describe-location (location nodes)\n  (cadr (assoc location nodes)))\n;;定义节点-路径\n(defparameter *edges* '((living-room (garden west door)\n                                     (attic upstairs ladder))\n                        (garden (living-room east door))\n                        (attic (living-room downstairs ladder))))\n;;定义描述路径函数\n(defun describe-path (edge)\n  `(there is a ,(caddr edge) going ,(cadr edge) from here.))\n;;定义描述对应位置路径的函数\n(defun describe-paths (location edges)\n  (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))\n;;定义物品列表\n(defparameter *objects* '(whiskey bucket frog chain))\n;;物品-位置对，hash？\n(defparameter *object-locations* '((whiskey living-room)\n                                   (bucket living-room)\n                                   (chain garden)\n                                   (frog garden)))\n;;得到相应位置物品列表\n(defun objects-at (loc objs obj-locs)\n  (labels ((at-loc-p (obj)\n             (eq (cadr (assoc obj obj-locs)) loc)))\n    (remove-if-not #'at-loc-p objs)))\n;;描述相应位置物品\n(defun describe-objects (loc objs obj-loc)\n  (labels ((describe-obj (obj)\n             `(you see a ,obj on the floor.)))\n    (apply #'append (mapcar #'describe-obj (objects-at loc objs obj-loc)))))\n;;给定初始位置\n(defparameter *location* 'living-room)\n;;定义查看函数\n(defun look ()\n  (append (describe-location *location* *nodes*)\n          (describe-paths *location* *edges*)\n          (describe-objects *location* *objects* *object-locations*)))\n;;定义行走函数\n(defun walk (direction)\n  (let ((next (find direction\n                    (cdr (assoc *location* *edges*))\n                    :key #'cadr)))\n    (if next\n      (progn (setf *location* (car next))\n             (look))\n      '(you cannot go that way.))))\n;;定义拾起函数\n(defun pickup (object)\n  (cond ((member object\n                 (objects-at *location* *objects* *object-locations*))\n         (push (list object 'body) *object-locations*)\n         `(you are now carrying the ,object))\n        (t '(you cannot get that.))))\n;;查看现有物品的函数\n(defun inventory ()\n  (cons 'items- (objects-at 'body *objects* *object-locations*)))\n;;登入界面\n(defun say-hello ()\n  (princ \"Please type your name:\")\n  (let ((name (read-line)))\n    (princ \"Nice to meet you, \")\n    (princ name)))\n;;自定义repl\n(defun game-repl ()\n  (let ((cmd (game-read)))\n    (unless (eq (car cmd) 'quit)\n      (game-print (game-eval cmd))\n      (game-repl))))\n;;自定义的read\n(defun game-read ()\n  (let ((cmd (read-from-string\n               (concatenate 'string \"(\" (read-line) \")\"))))\n    (flet ((quote-it (x)\n             (list 'quote x)))\n      (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))\n;;给定可执行命令\n(defparameter *allowed-commands* '(look walk pickup inventory))\n;;自定义eval\n(defun game-eval (sexp)\n  (if (member (car sexp) *allowed-commands*)\n    (eval sexp)\n    '(i do not know that command.)))\n;;转换字符列表大小写函数\n(defun tweak-text (lst caps lit)\n  (when lst\n    (let ((item (car lst))\n          (rest (cdr lst)))\n      (cond ((eq item #\\space) (cons item (tweak-text rest caps lit)))\n            ((member item '(#\\! #\\? #\\.)) (cons item (tweak-text rest t lit)))\n            ((eq item #\\\") (tweak-text rest caps (not lit)))\n            (lit (cons item (tweak-text rest nil lit)))\n            ((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))\n            (t (cons (char-downcase item) (tweak-text rest nil nil)))))))\n;;自定义print\n(defun game-print (lst)\n  (princ (coerce (tweak-text (coerce (string-trim \"() \"\n                                                  (prin1-to-string lst))\n                                     'list)\n                             t\n                             nil)\n                 'string))\n  (fresh-line))\n\n```\n\n然后测试游戏引擎，在repl中输入\n\n```cl\n(game-repl)\n```\n\n首先让我惊异的就repl可以自定义,还有那个quasiquote很好用。\n\n然后学到了以下一堆命令：\n\n- defparameter/defvar\n- cons\n- assoc\n- caxdxr\n- `/，/quote\n- append\n- mapcar\n- apply\n- labels/flet\n- eq\n- remove-if-not\n- find\n- progn\n- cond\n- if/unless\n- and/or\n- member\n- push\n- print/princ/prin1/prin1-to-string/princ-to-string\n- read/read-from-string/read-line\n- concatenate\n- coerce\n- fresh-line\n- char-upcase/char-downcase\n\n",metaData:{layout:"post",title:"a text game engine written by lisp",excerpt:"算是我的《land of lisp》笔记了",category:"lisp",tags:["land-of-lisp"],disqus:!0}}}});