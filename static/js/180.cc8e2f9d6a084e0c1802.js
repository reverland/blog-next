webpackJsonp([180,191],{272:function(n,t){n.exports={rawContent:'\n## lisp中的特殊列表结构\n\n- 点状列表\n- pair\n- circular list\n\n***\n\n## 可视化lisp数据\n\n用graphviz把lisp中数据可视化的方法，代码如下：\n\n```cl\n;;切换到工作目录\n(cd "/home/reverland/Documents/lisp/")\n;;;有向图\n;;定义节点及描述\n(defparameter *wizard-nodes* \'((living-room (you are in the living-room.\n\t\t\t\t\t     a wizard is snoring loudly on the couch.))\n\t\t\t       (garden (you are in a beautiful garden.\n\t\t\t\t\tw\n\t\t\t\t       )\n\t\t\t\t(attic (you are in the attic. there\n\t\t\t\t\tis a giant welding torch in the corner.)))))\n;;定义节点与边\n(defparameter *wizard-edges* \'((living-room (garden west door)\n\t\t\t\t(attic upstairs ladder))\n\t\t\t       (garden (living-room east door))\n\t\t\t       (attic (living-room downstairs ladder))))\n  ;;转换名函数\n(defun dot-name (exp)\n (substitute-if #\\_ (complement #\'alphanumericp) (prin1-to-string exp)))\n  ;将非字母数字的字符转化为下划线 \n  ;;定义标签长度\n(defparameter *max-label-length* 30)\n  ;;处理位置描述\n(defun dot-label (exp)\n (if exp\n  (let ((s (write-to-string exp :pretty nil))); :pretty防止换行或加入tab\n   (if (> (length s) *max-label-length*)\n    (concatenate \'string \n     (subseq s 0 (- *max-label-length* 3)) "...")\n    ;如果标签长度比最长值长，将超长的替换成...\n    s))\n  ""));strange,why not nil?\n  ;;定义节点和标签函数\n(defun nodes->dot (nodes)\n (mapc (lambda (node);mapc不返回列表\n\t(fresh-line)\n\t(princ (dot-name (car node)))\n\t(princ "[label=\\"")\n\t(princ (dot-label node))\n\t(princ "\\"];"))\n  nodes))\n  ;;定义遍历edges中每个元素，再对每个元素进行遍历\n  (defun edges->dot (edges)\n   (mapc (lambda (node)\n\t  (mapc (lambda (edge)\n\t\t (fresh-line)\n\t\t (princ (dot-name (car node)))\n\t\t (princ "->")\n\t\t (princ (dot-name (car edge)))\n\t\t (princ "[label=\\"")\n\t\t (princ (dot-label (cdr edge)))\n\t\t (princ "\\"];"))\n\t   (cdr node)))\n    edges))\n  ;;生成dot文件内容\n(defun graph->dot (nodes edges)\n (princ "digraph{")\n (nodes->dot nodes)\n (edges->dot edges)\n (princ "}"))\n  ;;接受一个trunk，得到trunk的输出而非函数的值\n  ;;to keep this dot->png function as reusable as possible, the graph->dot\n  ;;function isn’t called directly. Instead, we write dot->png to accept a thunk\n(defun dot->png (fname thunk)\n (with-open-file (*standard-output*;类比与let\n\t\t  fname ;输入到fname文件\n\t\t  :direction :output;keyword symbol即本身,方向输出\n\t\t  :if-exists :supersede);如果存在覆盖\n  (funcall thunk));nully function\n (ext:shell (concatenate \'string "dot -Tpng -O " fname)))\n;it\'s an O actually!it\'s not zero!\n;;最后一步\n(defun graph->png (fname nodes edges)\n (dot->png fname\n  (lambda ();relay funcion\n   (graph->dot nodes edges))));which is the trunk,I am not clear.\n  ;;最后执行\n  (graph->png "wizard.dot" *wizard-nodes* *wizard-edges*)\n  ;;;无方向图\n(defun uedges->dot (edges)\n (maplist (lambda (lst);遍历剩下的元素\n\t   (mapc (lambda (edge)\n\t\t  (unless (assoc (car edge) (cdr lst));除非以下不再出现这个位置\n\t\t   (fresh-line)\n\t\t   (princ (dot-name (caar lst)))\n\t\t   (princ "--")\n\t\t   (princ (dot-name (car edge)))\n\t\t   (princ "[label=\\"")\n\t\t   (princ (dot-label (cdr edge)))\n\t\t   (princ "\\"];")))\n\t    (cdar lst)))\n  edges))\n(defun ugraph->dot (nodes edges)\n (princ "graph{")\n (nodes->dot nodes)\n (uedges->dot edges)\n (princ "}"))\n(defun ugraph->png (fname nodes edges)\n (dot->png fname\n  (lambda ()\n   (ugraph->dot nodes edges))))\n  ;;执行命令\n  (ugraph->png "uwizard.dot" *wizard-nodes* *wizard-edges*)\n\n```\n\n结合上回处理文本，觉得lisp在处理列表和文本时挺方便，虽然没有正则什么的。然后学习到lisp和unix环境交互还是比较方便的。\n\n学会了一个生成文本数据的技术，把打印到终端而易于调试的输出包装成一个thunk，传递给其它函数。\n\n学到了很多命令：\n\n- cd(ext)\n- substitute-if\n- complement\n- alphanumericp\n- write-to-string\n- subseq\n- mapc\n- maplist\n- with-open-file\n- funcall\n\n***\n\n## 参考资料\n\n[graphivz中文使用指南](http://blog.openrays.org/blog.php?do=showone&tid=420)\n\n',metaData:{layout:"post",title:"Visualize tree like data in Lisp",excerpt:"list的一些特殊列表及使用开源工具graphivz来可视化树状数据",category:"lisp",tags:["land-of-lisp"],disqus:!0}}}});